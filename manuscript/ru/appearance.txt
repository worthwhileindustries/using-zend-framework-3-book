# Внешний вид страницы и лэйаут {#appearance}

В этой главе вы узнаете, как cделать свои веб-страницы привлекательными внешне
и профессионально выглядящими с помощью CSS-фреймворка Twitter Bootstrap,
а также как расположить элементы на странице, используя механизм лэйаутов ZF3.
Вы также ознакомитесь с общими помощниками видов, которые позволяют
составлять веб-страницы из многократно используемых частей. Если вы ранее не 
сталкивались с Twitter Bootstrap, рекомендуем ознакомиться с [Приложением В. Введение в Twitter Bootstrap](#bootstrap)
для более детального описания возможностей данного фреймворка.

Компоненты ZF3, рассматриваемые в этой главе:

|--------------------------------|---------------------------------------------------------------|
| *Компонент*                    | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Mvc`                     | Поддержка шаблона проектирования MVC. Реализует базовые классы контроллеров, плагины контроллеров и т.д. |
|--------------------------------|---------------------------------------------------------------|
| `Zend\View`                    | Реализует функциональность контейнеров для переменных, визуализацию веб-страницы и помощники видов. |
|--------------------------------|---------------------------------------------------------------|
 
## О таблицах стилей CSS и Twitter Bootstrap
 
Для определения внешнего вида и стиля веб-страниц сайта на базе ZF3 используются
таблицы стилей CSS [^css]. Их файлы, как правило, хранятся в каталоге *APP_DIR/public/css*.

[^css]: Если вы не знакомы с CSS, изучите руководство W3Schools,
        перейдя по [этой ссылке](http://www.w3schools.com/).

Так как правила CSS могут быть довольно сложными и требовать навыков дизайна,
их выделяют в "библиотеки" (фреймворки). Аналогично PHP-фреймворкам, CSS-фреймворки
допускают повторное использование кода.

На сегодняшний день на рынке существует несколько CSS-фреймворков, и [Twitter Bootstrap](http://getbootstrap.com/)
(или просто Bootstrap) является одним из них. Изначально разработанный Twitter, чтобы унифицировать
внешний вид их собственных веб-инструментов, Bootstrap стал популярным CSS-фреймворком, позволяющим
вам сделать сайт профессионально выглядящем и привлекательным внешне, даже если вы
не обладаете продвинутыми навыками дизайна, а также без необходимости создания основных
CSS-правил (однако вы, разумеется, можете определить свои собственные CSS-правила вдобавок к
Bootstrap и настроить внешний вид вашего сайта). Bootstrap распространяется бесплатно по лицензии
[Apache License v.2.0](http://www.apache.org/licenses/LICENSE-2.0.html).

T> Twitter Bootstrap поставляется с Zend Skeleton Application, так что вы 
T> можете использовать его готовую версию; либо скачать фреймворк с 
T> [официальной страницы проекта](http://getbootstrap.com/). 
T> На момент написания этой книги последней версией является v.3.x.

В целом, Bootstrap делает следующее:

* Предоставляет *CSS reset* ("сброс CSS"), таблицу стилей, определяющую стили для всех возможных
  HTML-элементов. Таким образом ваш веб-сайт будет выглядеть одинаково во всех браузерах.
  
* Предоставляет *основные CSS-правила*, которые определяют стиль типографии (заголовки
  и текст), таблицы, формы, кнопки, изображения и пр.

* Определяет *систему сеток*. Система сеток позволяет организовать элементы
  на вашей странице в структуру в виде сетки. Взгляните, например, на главную 
  страницу Skeleton Application (рисунок 6.1), где у нас есть сетка, состоящая
  из трех столбцов. 

* Определяет полезные *компоненты веб-интерфейса* вроде выпадающих меню, панелей
  навигации, навигационных цепочек, пагинации и т.д. Например, на главной странице
  скелетного приложения сверху находится панель навигации, а под ней - заголовок
  (также называемый элемент Hero или Jumbotron). Эти компоненты будут удобны в
  использовании на любом веб-сайте.
  
* Содержит *расширения JavaScript*, позволяющие сделать предоставляемые Bootstrap
  компоненты интерфейса более интерактивными. Например, JavaScript используется для 
  анимирования выпадающих меню и отображения "модальных диалоговых окон". 

![Figure 6.1. Главная страница скелетного приложения и его лэйаут](../en/images/appearance/skeleton-layout.png) 
         
T> Если вы ранее не сталкивались с Bootstrap, рекомендуем ознакомиться
T> с [Приложением В. Введение в Twitter Bootstrap](#bootstrap), где вы найдете больше информации об
T> использовании Twitter Bootstrap и его компонентов.
		 
## Лэйаут страницы в Zend Framework 3

Страницы вашего сайта, как правило, имеют некоторую общую структуру. 
Например, типичная страница содержит объявление `<!DOCTYPE>` для идентификации HTML-документа, 
а также элементы `<head>` и `<body>`:

{line-numbers=off, lang=html, title="Typical page structure"}
~~~
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Welcome</title>
        <!-- Вставьте мета-теги, таблицы стилей и скрипты -->  
    </head>
    <body> 
        <!-- Вставьте содержимое страницы -->  
    </body>
</html>
~~~

Элемент `<head>` содержит текст заголовка страницы, метаданные и 
информацию об использованных таблицах стилей и скриптах. Элемент `<body>`
содержит содержимое страницы, то есть, логотип, панель навигации, текст
страницы и футер с информацией об авторских правах.

В Zend Framework 3 вы определяете подобную структуру с помощью "главного" шаблона 
представления, называемого *лэйаутом*. Лэйаут "украшает" другие шаблоны представления.

Шаблон лэйаута, как правило, имеет *плейсхолдер*,куда ZF3
помещает контент для конкретной указанной страницы (см. рисунок 6.2). 

![Рисунок 6.2. Плейсхолдер в шаблоне лэйаута](../en/images/appearance/layout_placeholder.png) 

В Skeleton Application стандартный файл шаблона лэйаута называется *layout.phtml*.
Он расположен внутри каталога *view/layout* в каталоге модуля *Application* (см. рисунок 6.3).

![Figure 6.3. Каталог лэйаута](../en/images/appearance/layout_dir.png) 

Давайте рассмотрим файл шаблона *layout.phtml* более детально.
Ниже представлено содержимое файла целиком. 
	 
{line-numbers=on, lang=php}
~~~  
<?= $this->doctype() ?>

<html lang="en">
  <head>
    <meta charset="utf-8">
    <?= $this->headTitle('ZF Skeleton Application')
             ->setSeparator(' - ')->setAutoEscape(false) ?>

    <?= $this->headMeta()
          ->appendName('viewport', 'width=device-width, initial-scale=1.0')
          ->appendHttpEquiv('X-UA-Compatible', 'IE=edge')
    ?>

    <!-- Стили -->
    <?= $this->headLink(['rel' => 'shortcut icon', 'type' => 'image/vnd.microsoft.icon', 
                         'href' => $this->basePath() . '/img/favicon.ico'])
        ->prependStylesheet($this->basePath('css/style.css'))
        ->prependStylesheet($this->basePath('css/bootstrap-theme.min.css'))
        ->prependStylesheet($this->basePath('css/bootstrap.min.css'))
    ?>

    <!-- Скрипты -->
    <?= $this->headScript()
        ->prependFile($this->basePath('js/bootstrap.min.js'))
        ->prependFile($this->basePath('js/jquery-2.2.4.min.js'))
    ?>
    </head>
    <body>
      <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" 
                    data-target=".navbar-collapse">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="<?php echo $this->url('home') ?>">
              <img src="<?= $this->basePath('img/zf-logo.png') ?>" 
                   alt="Zend Framework <?= \Application\Module::VERSION ?>"/>
                   &nbsp;Skeleton Application
            </a>
          </div>
          <div class="collapse navbar-collapse">
            <ul class="nav navbar-nav">
              <li class="active">
                <a href="<?= $this->url('home') ?>">Home</a>
              </li>
            </ul>
          </div>
        </div>
      </nav>
      <div class="container">
        <?= $this->content; ?>
        <hr>
        <footer>
          <p>&copy; 2005 - <?= date('Y') ?> by Zend Technologies Ltd. 
            All rights reserved.
          </p>
        </footer>
      </div>
      <?= $this->inlineScript() ?>
  </body>
</html>
~~~

Как видите, файл *layout.phtml* (как и обычный шаблон представления) состоит из HTML-тегов
и фрагментов PHP-кода. При визуализации шаблона ZF3 вычисляет PHP-строки и генерирует 
получившуюся HTML-страницу, доступную пользователям сайта. 

Строка 1 генерирует объявление `<!DOCTYPE>` [^doctype] HTML-страницы с помощью 
помощника видов `Doctype`. 

[^doctype]: Объявление `<!DOCTYPE>` идет первым в HTML-документе, перед тегом
            `<html>`. Объявление предоставляет браузеру инструкции о том, на какой
            версии HTML написана страница (на нашем сайте мы используем объявление
            HTML5-совместимого типа документа). 
         
Строка 3 определяет элемент `<html>`, представляющий собой корень HTML-документа. 
За тегом `<html>` следует тег `<head>` (строка 4), который, как правило, содержит
заголовок документа и может содержать дополнительную информацию вроде скриптов, 
CSS-стилей и метаданных. 

В строке 5 тег `<meta>` сообщает браузеру, что документ закодирован с помощью 
кодировки символов UTF-8 [^utf8]. 

[^utf8]:  UTF-8 позволяет закодировать любой символ любого алфавита в мире,
          поэтому его рекомендуется использовать для кодировки веб-страниц.

В строке 6 мы видим помощник вида `HeadTitle`, который позволяет определить заголовок 
для страницы ("ZF Skeleton Application"). Он будет показан в заголовке окна браузера. 
Метод `setSeparator()` используется для определения символа-разделителя для "составных"
заголовков страниц[^составной заголовок]; метод `setAutoEscape()` повышает безопасность,
"обрабатывая" (escape) небезопасные символы из заголовка страницы.

[^составной заголовок]: "Составной" заголовок страницы состоит из двух частей: первая часть ("ZF Skeleton Application") 
						 определяется лэйаутом, а вторая - определяемая конкретной страницей - является
						 префиксом для первой. Например, у страницы вашего сайта *About* будет заголовок
						 "About - ZF Skeleton Application", а для страницы *Documentation* - "Documentation - ZF Skeleton Application".
          
В строке 9 помощник вида `HeadMeta` позволяет определить тег `<meta name="viewport">`,
содержащий метаданные для веб-браузера, которые предназначены для управления лэйаутом на различных
устройствах, включая мобильные браузеры. Свойство `width` контролирует размер области
просмотра, а свойство `initial-scale` - уровень масштабирования загруженной страницы.
Это делает лэйаут веб-страницы "отзывчивым" к размеру области просмотра устройства.

В строке 15 помощник вида `HeadLink` позволяет определить теги `<link>`. 
С помощью этих тегов `<link>`, как правило, определяется "favicon" (FAVorite ICON — «значок для избранного») 
для страницы (находится в файле `APP_DATA\public\img\favicon.ico`) и таблицы стилей CSS. 

В строках 17-19 методом `prependStylesheet()` помощника вида `HeadLink` подключаются
таблицы стилей, общие для всех страниц сайта. Любая страница нашего веб-сайта будет
загружать три файла таблиц стилей CSS: *bootstrap.min.css* (минифицированная версия
фреймворка Twitter Bootstrap), *bootstrap-theme.min.css* (минифицированная таблица стилей темы)
и *style.css* (файл, позволяющий нам определить свои собственные CSS-правила, переопределяющие
правила CSS-правила Bootstrap).

Строки 23-25 включают JavaScript-файлы, которые будут загружаться всеми вашими веб-страницами. 
Скрипты, выполняемые браузером клиента, позволяют добавить интерактивные функции вашим страницам.
Мы используем скрипты `bootstrap.min.js`(минифицированная версия Twitter Bootstrap) и`jquery-2.2.4.min.js` 
(минифицированная версия библиотеки jQuery). Все скрипты находятся в каталоге *APP_DIR/public/js*.

В строке 28 находится определение тега `<body>`, тела документа, где находится
все его содержимое: панель навигации, текст, гиперссылки, изображения, таблицы,
списки и т.д.

В строках 29-52 находится определение панели навигации Bootstrap.
Скелетное приложение использует складную панель навигации с темной темой.
Панель навигации содержит одну единственную ссылку *Home*.

Если вы посмотрите на строки 53-61, вы заметите элемент `<div>` с классом `container` - 
контейнером для системы сеток. Таким образом, вы можете использовать систему сеток Bootstrap
для организации содержимого ваших веб-страниц.

Строка 54 очень важна: в ней находится PHP-код, представляющий собой плейсхолдер
для содержимого страницы, о которой мы говорили в начале этого раздела. Когда
визуализатор ZF3 работает с шаблоном представления, содержимое текущей страницы
отражается также и здесь.

Строки 56-60 определяют футер страницы. Футер содержит информацию об авторских
правах, например, "2016 by Zend Technologies Ltd. All rights reserved." Вы можете
вставить сюда название своей компании.

Строка 62 - это плейсхолдер для скриптов JavaScript, загружаемых определенной страницей.
Помощник вида `InlineScript` будет заменять здесь все скрипты, которые вы зарегистрировали
(о регистрации скриптов JavaScript вы узнаете позже в этой главе).

И наконец, строки 63-64 содержат закрывающие теги для тела и HTML-документа.

## Видоизменение стандартного лэйаута страницы

Для демонстрации определения своего собственного лэйаута, мы изменим
лэйаут сайта Zend Skeleton Application. Так, нам нужно, чтобы выводилось
заголовок страницы "Hello world", заголовок текста "Hello world!" наверху,
панель навигации и навигационная цепочка под заголовком, плейсхолдер для
содержимого страницы по центру и футер с информацией об авторских правах
в нижней части страницы (пример того, чего мы хотим добиться, на рисунке 6.4):

![Рисунок 6.4. Получившийся лэйаут страницы](../en/images/appearance/mainpage.png)

Начнем с заголовка страницы "Hello World". Заменим строки 6-7 в файле *layout.phtml*
следующим образом:

{line-numbers=off,lang=php}  
~~~
<?= $this->headTitle('Hello World')->setSeparator(' - ')->setAutoEscape(false) ?>
~~~

Затем используем предоставляемую Bootstrap систему сеток для расположения основных блоков страницы. 
Замените HTML-код элемента `<body>` (строки 28-63) на следующий:

{line-numbers=on,lang=php}  
~~~
<body>  
    <div class="container">               
        <div class="row">
            <!-- Заголовок страницы -->
            <div class="col-md-4">
                <div class="app-caption">Hello World!</div>
            </div>                
        </div>
        <div class="row">
            <div class="col-md-12">
                <!-- Панель навигации-->
            </div>
        </div>
        <div class="row">
            <div class="col-md-12">
                <!-- Навигационная цепочка -->        
            </div>
        </div>
        <div class="row">
            <div class="col-md-12">
                <!-- Плейсхолдер для содержимого страницы -->
                <?= $this->content; ?>
            </div>
        </div>
        <div class="row">
            <div class="col-md-12">
                <hr>                
                <p>&copy; 2005 - <?= date('Y') ?> by Your Company. All rights reserved.</p>
            </div>
        </div> <!-- /container -->
    <?php echo $this->inlineScript() ?>
</body>
~~~
Итак, мы определили `<div>` с классом `container` и поместили в сетку элементы
`<div>`. Сетка состоит из 5 строк: 

  * Заголовок страницы, содержащий текст "Hello World!" (строки 3-8). Текст заголовка
    занимает четыре столбца сетки. Для стилизации текста мы используем наш пользовательский CSS-класс 
	`app-caption` (мы определим этот класс чуть позже в файле *style.css*).
    
  * В строке 11 мы оставили место для навигационной панели. 
  
  * В строке 16 - место для навигационной цепочки.
  
  * Строка 22 - плейсхолдер для содержимого страницы. Когда
	визуализатор ZF3 будет обрабатывать страницу, значение переменной `$content`
	также передастся сюда -  здесь будет заменено содержимое текущей страницы.
    
  * И в строках 25-29 мы сделали футер с текстом "(c) 2013 by Your Company. 
    All rights reserved." Если хотите, можете изменить этот текст и вставить сюда название
	своей компании.

Теперь поместим панель навигации в соответствующую строку сетки:

{line-numbers=off, lang=php}  
~~~
<!-- Панель навигации -->
<nav class="navbar navbar-default" role="navigation">
    <div class="collapse navbar-collapse navbar-ex1-collapse">
        <ul class="nav navbar-nav">
            <li class="active">
                <a href="<?= $this->url('home') ?>">Home</a>
            </li>
            <li>
                <a href="<?= $this->url('application', ['action'=>'downloads']) ?>">
                    Downloads
                </a>
            </li>
            <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                    Support <b class="caret"></b>
                </a>
                <ul class="dropdown-menu">
                    <li>
                        <a href="<?= $this->url('doc', ['page'=>'contents']) ?>">
                           Documentation
                        </a>
                    </li>
                    <li>
                        <a href="<?= $this->url('static', ['page'=>'help']) ?>">
                           Help
                        </a>
                    </li>
                </ul>
            </li>
            <li>
                <a href="<?= $this->url('about') ?>">About</a>
            </li>
        </ul>     
    </div>
</nav>
~~~

В этом фрагменте кода мы использовали один из компонентов интерфейса, предоставляемых Bootstrap - панель навигации.
Мы также воспользовались помощником вида `Url`, чтобы вставить ссылки в элементы навигации.

I> Мы обсудили использование помощника вида `Url` в разделе *Генерация URL из маршрута* 
I> главы [Модель-представление-контроллер](#mvc).

После этого поместим компонент навигационной цепочки в соответствующую строку сетки:

{line-numbers=off, lang=php}  
~~~
<!-- Навигационная цепочка -->
<ol class="breadcrumb">
    <li class="active">Home</li>
</ol>
~~~

Затем нам нужны несколько пользовательских CSS-правил, чтобы отрегулировать внешний вид.
Мы определяем их в таблице стилей *style.css*.

Мы хотим, чтобы текст заголовка "Hello World!" использовал крупный жирный шрифт и приятный глазу цвет.
Чтобы это сделать, откройте файл *style.css* и добавьте в его конец следующие строки:

{line-numbers=off,lang=css}  
~~~
div.app-caption {
    padding: 25px 0px;    
    font-size: 3.0em;
    font-weight: bold;
    color: #6aacaf
}
~~~

В представленном выше коде мы создали класс `app-caption`, который можно применить к элементу
`<div>`, определяющий вертикальный отступ в 25 пикселей, большой размер шрифта, жирный стиль
текста и шестнадцатеричное представление цвета текста.

По умолчанию, в скелетном приложении панель навигации расположена в верхней части
страницы, а CSS-правило для тела страницы определяет отступ сверху в 20 пикселей, чтобы
оставить для нее место. Так как в нашем примере Hello World мы перенесли панель навигации из
верхней части страницы в поток страниц, нам нужно убрать этот отступ. Чтобы это сделать,
внесите изменения в CSS-правило `body` в файле `style.css`, чтобы оно выглядело, как показано ниже:

{line-numbers=off,lang=css}  
~~~
body {
    padding-bottom: 40px;
}
~~~

Отлично, мы завершили создание шаблона лэйаута страницы! Чтобы увидеть результат наших изменений
откройте сайт в своем браузере - вы должны будете увидеть страницу как на рисунке 6.4. Вы можете
нажать на ссылки на панели навигации, чтобы перейти на страницы *About*, *Documentation* и т.д.
Содержимое каждой отдельной страницы помещено в соответствующий плейсхолдер нашего лэйаута.

T> Результат можно увидеть в действии в образце приложения 
T> *Hello World*, которое является частью кода, выложенного на
T> GitHub в качестве примеров для данной книги.

## Переключение между лэйаутами

По умолчанию, ZF3 предоставляет вам один единственный шаблон лэйаута - *layout.phtml*.
В реальных приложениях вам, скорее всего, нужно будет иметь несколько лэйаутов и менять
лэйаут для определенного контроллера/действия.

Например, у вас могут быть следующие части сайта: фронтэнд (front-end) и бэкэнд (back-end). Часть front-end будет состоять из веб-страниц, видимых для всех пользователей,
и будет использовать стандартный лэйаут для всех подобных страниц. Часть back-end будет состоять из страниц, доступных
только администратору и использовать другой лэйаут, содержащий административное меню.

Для начала подготовьте файл шаблона другого лэйаута. Назовите его, например, *layout2.phtml*.
Чтобы упростить подготовку файла, скопируйте содержимое файла *layout.phtml* и внесите необходимые
изменения.

Когда второй шаблон лэйаута будет готов, вы сможете переключаться между лэйаутами для
определенного действия контроллера, используя следующий код:

{line-numbers=on, lang=php}  
~~~
// Метод действия контроллера, который использует
// альтернативный шаблон лэйаута.
public function indexAction() 
{
    //...

    // Используем плагин Layout для доступа к объекту ViewModel,
    // связанному с шаблоном лэйаута.
    $this->layout()->setTemplate('layout/layout2');
  
    //...
}
~~~

В примере метода действия выше мы используем плагин контроллера `Layout` (строка 9),
который позволяет обращаться к экземпляру класса `ViewModel`, связанного с шаблоном
лэйаута. Чтобы поменять шаблон лэйаута для этого метода действия, мы вызвали метод
`setTemplate()` класса `ViewModel`.

T> В дополнение к плагину контроллера `Layout`, существует помощник вида `Layout`, который
T> имеет те же возможности. С его помощью вы можете, например, переключить лэйаут со
T> "статической" страницы, у которой нет необходимого действия контроллера.

### Установка лэйаута для всех действий контроллера 

Если вам нужно, чтобы все методы действия класса контроллера использовали
один и тот же альтернативный лэйаут, вы можете переопределить метод `onDispatch()`
класса `AbstractActionController` и вызвать в нем метод `setTemplate()`, как показано в примере ниже:

{line-numbers=off, lang=php}  
~~~
// Добавьте этот псевдоним в начало файла контроллера
use Zend\Mvc\MvcEvent;

// ...

class IndexController extends AbstractActionController 
{
    /** 
     * Мы переопределяем метод родительского класса onDispatch(),
     * чтобы установить альтернативный лэйаут для всех действий в этом контроллере.
     */
    public function onDispatch(MvcEvent $e) 
    {
        // Вызываем метод базового класса onDispatch() и получаем ответ
        $response = parent::onDispatch($e);        
	
        // Устанавливаем альтернативный лэйаут
        $this->layout()->setTemplate('layout/layout2');                
	
        // Возвращаем ответ
        return $response;
    }
}
~~~

## Частичные представления

*Частичные представления (partial views)* - это файлы шаблонов представлений *.phtml*, которые могут быть визуализированы
другим шаблоном представления. Частичные представления позволяют собирать вашу страницу по частям и повторно
использовать детали алгоритма визуализации представления в различных шаблонах представления.

В качестве примера использования частичных представлений, представьте, что нам нужно отобразить таблицу
некоторых продуктов. У каждого продукта есть ID, название и цена. Мы можем использовать шаблон частичного
представления для отображения одной строки таблицы несколько раз.

Для начала добавим метод `partialDemoAction()` контроллеру Index:

{line-numbers=off, lang=php}  
~~~
// Действие, демонстрирующее использование частичных представлений.
public function partialDemoAction() 
{
    $products = [
        [
            'id' => 1,
            'name' => 'Digital Camera',
            'price' => 99.95,
        ],
        [
            'id' => 2,
            'name' => 'Tripod',
            'price' => 29.95,
        ],
        [
            'id' => 3,
            'name' => 'Camera Case',
            'price' => 2.99,
        ],
        [
            'id' => 4,
            'name' => 'Batteries',
            'price' => 39.99,
        ],
        [
            'id' => 5,
            'name' => 'Charger',
            'price' => 29.99,
        ],
    ];
	
    return new ViewModel(['products' => $products]);
}
~~~

Этот метод действия просто подготавливает массив продуктов для отображения
и передает его шаблону представления с помощью контейнера для переменных `ViewModel`.

Затем добавим файл шаблона *partial-demo.phtml*:

{line-numbers=on, lang=php}  
~~~
<?php
$this->headTitle('Partial View Demo');
?>

<h1>Partial View Demo</h1>
<p>
    Ниже представлена таблица продуктов. Она была визуализирована с помощью
	частичных представлений.
</p>
<table class="table table-striped table-hover">
    <tr>
        <th>ID</th>
        <th>Product</th>
        <th>Price</th>
    </tr>

    <?php 
        foreach ($this->products as $product) {
            echo $this->partial('application/index/table-row', ['product'=>$product]);
        }    
    ?>    
</table>
~~~

В представленном выше шаблоне представления мы определяем разметку таблицы продуктов
(строки 10-22). В строке 18 мы проходим по элементам массива продуктов и отображаем
каждую строку с помощью помощника вида `Partial`.

Первый аргумент помощника вида `Partial` - это имя файла шаблона частичного 
представления ("application/index/table-row").

Второй аргумент - массив аргументов, передаваемых шаблону представления. К ним можно
будет обращаться так же, как если бы вы передавали их с помощью контейнера для
переменных `ViewModel`.

Наконец, создадим шаблон представления *table-row.phtml*, который будет использоваться
как шаблон частичного представления:

{line-numbers=off, lang=php}  
~~~
<tr>
  <td> <?= $this->product['id'] ?> </td>
  <td> <?= $this->product['name'] ?> </td>
  <td> <?= $this->product['price'] ?> </td>
</tr>
~~~

В этом шаблоне представления мы визуализируем одну строку таблицы.

Чтобы увидеть получившуюся веб-страницу, наберите URL "http://localhost/application/partial-demo"
в адресной строке своего браузера. Вы увидите что-то наподобие рисунка 6.5.

![Рисунок 6.5. Строки таблицы отображены с помощью частичных представлений](../en/images/appearance/partial_demo.png) 

## Placeholder View Helper

Помощник вида Placeholder - еще один полезный помощник вида, позволяющий сохранить с веб-страницы
ее содержимое и хранить его [^хранение] для дальнейшего пользования. Таким образом, он, как и 
помощник вида `Partial`, позволяет собрать страницу из нескольких частей. 

[^хранение]: Помощник вида `Placeholder` хранит данные в хранилище сессий PHP. Так что теоретически
             вы можете сохранить содержимое одной страницы и затем использовать/отобразить его на другой.

Например, можно использовать помощник вида `Placeholder` в паре с помощником вида `Partial` для "украшения"
содержимого шаблона представления с помощью другого шаблона представления. Полезное практическое применение
этому - "наследование" лэйаутов.

Представьте ситуацию, в которой вам необходимо создать альтернативный лэйаут, который буде иметь абсолютно
такие же заголовок и футер, но отличаться центральным разделом страницы. Можно использовать метод "грубой силы" 
для создания такого лэйаута - скопировать содержимое оригинального шаблона лэйаута и внести необходимых изменений.
Другой метод (и он лучше) - "наследование", при котором получившийся лэйаут будет повторно использовать общие части.
		  
Чтобы показать, как наследовать лэйаут, мы создадим шаблон представления *layout2.phtml*, который будет наследовать
стандартный шаблон *layout.phtml*, и добавим панель рекламы в правую часть страницы. Иметь рекламу в лэйауте будет 
полезно, если вы планируете извлекать прибыль от показа коммерческой рекламы на всех (или большинстве) страницах вашего сайта.

Поместите следующий код в файл шаблона *layout2.phtml* template file:
		  
{line-numbers=on, lang=php}  
~~~
<?php $this->placeholder('content')->captureStart(); ?>

<div class="row">
    <div class="col-md-8">
    <?= $this->content; ?>
    </div>
    <div class="col-md-4">
        <div class="panel panel-default">
            <div class="panel-heading">
                <h3 class="panel-title">Ads</h3>
            </div>
            <div class="panel-body">
                <strong>Zend Framework 3 Book</strong>
                <p>Learn how to create modern web applications with PHP 
                   and Zend Framework 3</p>            
                <a target="_blank" 
                   href="https://github.com/olegkrivtsov/using-zend-framework-3-book">
                   Learn More
                </a>
            </div>
        </div>
    </div>
</div>

<?php 
    $this->placeholder('content')->captureEnd(); 
    echo $this->partial('layout/layout', 
          ['content'=>$this->placeholder('content')]); 
?>
~~~

В этом фрагменте кода мы вызываем метод `captureStart()` (строка 1) и метод `captureEnd()` 
(строка 26) помощника вида `Placeholder`, чтобы определить границы HTML-разметки,
которая будет сохранена помощником вида и будет храниться во внутреннем хранилище (вместо
передачи в стандартный поток вывода). 

В строках 3-23 представлен код разметки "унаследованного" лэйаута. Этот лэйаут использует 
сетку из двух ячеек. Первая ячейка сетки (охватывающая 8 столбцов) будет содержать
содержимое определенной страницы, а вторая (охватывающая 4 столбца)- рекламу. Для стилизации
рекламы мы используем компонент интерфейса *Panel*, предоставляемый Twitter Bootstrap.

В строке 27 мы используем помощник вида `Partial`, который используется для визуализации "родительского"
лэйаута (*layout.phtml*). Мы передаем данные, сохраненные помощником вида `Placeholder`, помощнику
вида `Partial` в качестве второго аргумента.

Таким способом, мы создали приятный глазу лэйаут, который наследуется от стандартного лэйаута
и улучшает возможность повторного использования кода.

Теперь, если вы выберите *layout2.phtml* для всех действий, скажем, контроллера Index, 
вы должны будете увидеть результат как на рисунке 6.6.

![Рисунок 6.6. Унаследованный лэйаут](../en/images/appearance/inherited_layout.png) 

## Добавление скриптов на веб-страницу

Вы можете добавить JavaScript-код на ваши HTML-страницы и сделать их интерактивными.
Скрипты должны быть вставлены между тегами `<script>` и `</script>`. 
Ниже представлен пример JavaScript-кода:

{line-numbers=off, lang=php}  
~~~
<script type="text/javascript">
// Показывает простое окно оповещения с текстом "Hello World!".
$(document).ready(function() { 
    alert('Hello World!');
});
</script>
~~~

В примере выше мы создали элемент `<script>` и поместили в него функцию обратного вызова jQuery.
jQuery обязывает функцию выполниться, когда DOM завершит загрузку. После выполнения функции, появится простое окно
оповещения с текстом "Hello World!" и кнопкой "ОК".

Так как вы поместили этот JavaScript-код внутрь HTML-файла, мы будем называть его *встроенным* скриптом.
Другой способ хранить JavaScript-код - разместить его во *внешнем* `.js`-файле.
Внешние файлы, как правило, содержат код, предназначенный для использования несколькими
веб-страницами. Обычно такие файлы хранятся в каталоге *APP_DIR/public/js/*. Чтобы 
привязать внешний JS-файл к HTML-странице, добавьте элемент `<script>` таким образом:

{line-numbers=off, lang=php}  
~~~
<script type="text/javascript" src="/js/yourscript.js"></script>
~~~

Когда браузер встретится с этим элементом, он прочитает внешний JS-файл и выполнит код.

В целом, вы можете разместить скрипт в двух местах HTML-файла:

* JavaScript-код можно разместить в раздел `<head>` HTML-страницы.
  Этот способ рекомендуется использовать, когда вам нужно, чтобы JavaScript
  загружался до содержимого страницы. Мы использовали этот способ для загрузки
  расширений Twitter Bootstrap и библиотеки jQuery.

* Скрипт может быть помещен в нижнюю часть раздела `<body>` HTML-страницы,
  прямо перед закрывающим тегом `</body>`. Этот метод допустим для случаев,
  когда вам нужно, чтобы вся DOM [^dom] загружалась перед тем, как скрипт может начать работу.
 
[^dom]: DOM (Document Object Model - объектная модель документа) - это удобное представление структуры
        HTML-документа в виде дерева элементов.

Если какой-либо JavaScript-файл должен использоваться на всех (или большинстве) веб-страницах,
лучше поместить его в шаблон представления лэйаута. Однако когда скрипт должен использоваться
лишь на одной странице, помещать его в шаблон лэйаута - не лучшая идея. Если вы это сделаете,
скрипт загрузится на всех страницах, что может создавать ненужный трафик и увеличивать время
загрузки страницы. Чтобы этого избежать, добавляйте такой скрипт только на желаемую страницу.

Чтобы добавить скрипт для конкретной страницы, который будет размещен в разделе `<head>`,
используйте помощник вида `HeadScript`. Его методы описаны в таблице 6.1:

{title="Таблица 6.1. Методы, предоставляемые помощником вида HeadScript"}
|--------------------------------|---------------------------------------------------------------|
| *Method name*                  | *Description*                                                 |
|--------------------------------|---------------------------------------------------------------|
| `appendFile()`                 | Помещает ссылку на внешний JS-файл в конец.                   |
|--------------------------------|---------------------------------------------------------------|
| `offsetSetFile()`              | Вставляет ссылку на внейшний JS-файл в список на заданную позицию. |
|--------------------------------|---------------------------------------------------------------|
| `prependFile()`                | Помещает ссылку на внешний JS-файл в начало.                  |
|--------------------------------|---------------------------------------------------------------|
| `setFile()`                    | Очищает список скриптов и помещает в него один внешний JS-файл. |
|--------------------------------|---------------------------------------------------------------|
| `appendScript()`               | Помещает встроенный скрипт в конец.                           |
|--------------------------------|---------------------------------------------------------------|
| `offsetSetScript()`            | Вставляет встроенный скрипт в список на заданную позицию.     |
|--------------------------------|---------------------------------------------------------------|
| `prependScript()`              | Помещает встроенный скрипт в начало.                          |
|--------------------------------|---------------------------------------------------------------|
| `setScript()`                  | Очищает список встроенных скриптов и помещает в него          |
|                                | один встроенный скрипт.                                       |
|--------------------------------|---------------------------------------------------------------|
		
Чтобы добавить ссылку на внешний JS-файл в раздел страницы `<head>`, поместите следующий PHP-код
в начало вашего файла шаблона представления (*.phtml*):

{line-numbers=off, lang=php}
~~~
<?php
$this->headScript()->appendFile('/js/yourscript.js', 'text/javascript');
?>
~~~

В представленном выше фрагменте мы вызываем метод `appendFile()` помощника вида `HeadScript`.
Этот метод принимает два аргумента. Первый - путь к внешнему JS-файлу (если файл хранится внутри
каталога *APP_DIR/public/js*) или URL JS-файла (если файл находится на другом веб-сервере).
Второй аргумент - это тип скрипта (как правило, "text/javascript").

Другие методы, предоставляемые помощником вида `HeadScript` (такие как `prependFile()`, `offsetSetFile()`
и `setFile()`) различаются только позицией в списке скриптов, на которую будет помещен новый скрипт.

Методы `prependScript()`, `appendScript()`, `offsetSetScript()` и `setScript()`
предназначены для вставки JavaScript-кода. Они используются довольно редко, так
как обычно внешние JS-скрипты вставляются в раздел заголовка документа.

Чтобы вставить скрипт в конец раздела `<body>`, воспользуйтесь помощником вида
`InlineScript` [^inlinescript]. Он предоставляет точно такие же методы, как и 
помощник вида `HeadScript`. Ниже приведен пример, который можно использовать
для добавления встроенного JavaScript-кода в конец тела документа:

[^inlinescript]: Имя `InlineScript` (inline script - встроенный скрипт) не полностью отражает возможности этого помощника вида.
                 На самом деле, с его помощью можно вставить и встроенные, и внешние скрипты. Более подходящим
				 именем было бы `BodyScript`, так как этот помощник вида предназначен для вставки скриптов в 
				 тело документа.

{line-numbers=off, lang=php}
~~~
<?php 
$script = <<<EOT
$(document).ready(function() {
    alert('Hello World!');
});
EOT;
$this->inlineScript()->appendScript($script);
~~~

В этом примере мы использовали Heredoc-синтаксис [^heredoc] чтобы заполнить переменную `$script`
встроенным JavaScript-кодом. Затем мы вызываем функцию `appendScript()` помощника вида
`InlineScript` и передаем этот код как аргумент.

[^heredoc]: Heredoc ("здесь документ") - альтернативный способ определения строк. 
            Он хорошо работает с многострочными переменными.

Однако, при использовании помощника вида `InlineScript` могут возникнуть проблемы с читаемостью. 
Более того, проверка синтаксиса NetBeans застрянет на Heredoc-записи и не распознает
JavaScript-код. Чтобы это исправить, просто поместите элемент `<script>` 
в конец вашего шаблона представления, как показано на этом примере:

{line-numbers=off, lang=php}
~~~
<!-- Содержимое страницы идет первым -->

<!-- Встроенный скрипт - последним -->
<script type="text/javascript">
$(document).ready(function() {
    // Show a simple alert window with the "Hello World!" text.
    alert("Hello World!");
});
</script>
~~~

Таким образом можно добиться того же эффекта, что и с помощником вида `InlineScript`, но с
лучшей читаемостью скрипта и автоматической проверкой синтаксиса в NetBeans.

I> Чтобы помощники видов `HeadScript` и `InlineScript` работали, их содержимое должно 
I> отображаться в шаблоне представления лэйаута (смотрите строки 23 и 62 файла *layout.phtml*). Если 
I> вы уберете эти строки из шаблона лэйаута, скрипты не будут вставлены на веб-страницу. 

### Пример

В качестве практического примера вставки JavaScript-кода на веб-страницу, добавим страницу
с автозаполнением. С помощью этой функции браузер будет "предсказывать" слово или фразу, которые
хочет набрать пользователь, по первым набранным им буквам. Мы используем библиотеку JavaScript
*Twitter Typeahead*.
Аналогично Twitter Bootstrap, библиотека Typeahead была изначально разработана в компании Twitter для их
нужд и на данный момент распространяется свободно.

Скачайте файл *typeahead.min.js* (минифицированная версия библиотеки Typeahead) из официальной
[страницы проекта](http://twitter.github.io/typeahead.js/). Затем поместите этот файл в каталог
*APP_DIR/public/js*.

После этого добавьте файл *typeahead.phtml* в подкаталог *application/index/static* под
каталогом модуля *view*.
Этот каталог обслуживается типом маршрута `StaticRoute`, который мы создали и настроили
ранее, в главе [Маршрутизация](#routing), и все "статические" страницы, помещенные сюда,
будут автоматически доступными для всех пользователей сайта.

В файле шаблона представления *typeahead.phtml* разместите следующий код:

{line-numbers=on, lang=php}
~~~
<?php
$this->headTitle('Typeahead');
// Добавляем JavaScript-файл
$this->headScript()->appendFile('/js/typeahead.min.js', 'text/javascript');
?>

<h1>Typeahead</h1>
<p>Type a continent name (e.g. Africa) in the text field below:</p>
<input type="text" class="typeahead" title="Type here"/>

<script type="text/javascript">
$(document).ready(function() { 
    $('input.typeahead').typeahead({
       name: 'continents',
       local: [
            'Africa', 
            'Antarctica',
            'Asia',
            'Europe',
            'South America', 
            'North America'            
        ]
    });
});
</script>
~~~

В этом фрагменте мы задали заголовок страницы (строка 2), затем
добавили файл *typeahead.min.js* в раздел страницы `<head>`, используя
помощник вида`HeadScript` (строка 4).

В строке 9 мы создаем поле ввода текста, куда пользователь сможет ввести
некоторый текст. Мы помечаем поле ввода CSS-классом `typeahead`.

Строки 11-25 содержат встроенный JavaScript-код, находящийся в конце шаблона
представления (мы не используем помощник вида `InlineScript` для лучшей читаемости кода).

В строке 12 находится обработчик событий jQuery, привязанный к событию "document is ready" 
(документ готов). Событие вызывается, когда целиком загрузится DOM-дерево.

В строке 13 находится селектор jQuery("input.typeahead"), который выбирает
все поля ввода с CSS-классом `typeahead` и выполняет для них функцию `typeahead()`.

Функция `typeahead()` связывает обработчик события "change" (изменение значения)
и поле ввода текста. Как только пользователь вводит символ в поле, начинает работу
обработчик и проверяет введенные буквы. Затем он выводит выпадающее меню с предлагаемыми
вариантами автозаполнения.

Функция `typeahead()` принимает два аргумента: аргумент `name`, определяющий
набор данных, и аргумент `local` - JSON-массив, содержащий варианты автозаполнения.

Чтобы придать полю автозаполнения и его выпадающему меню привлекательный вид,
добавьте в файл *style.css* следующие CSS-правила.

{line-numbers=off, lang=css}
~~~
.typeahead,
.tt-query,
.tt-hint {
    width: 396px;
    height: 30px;
    padding: 0px 12px;
    font-size: 1.1em;
    border: 2px solid #ccc;
    border-radius: 4px;
    outline: none;
}

.tt-dropdown-menu {
    width: 422px;
    margin-top: 12px;
    padding: 8px 0;
    background-color: #fff;
    border: 1px solid #ccc;
    border: 1px solid rgba(0, 0, 0, 0.2);
    border-radius: 4px; 
}

.tt-suggestion {
    padding: 3px 20px;
    font-size: 1.1em;
    line-height: 24px;
}

.tt-suggestion.tt-is-under-cursor {
    color: #fff;
    background-color: #0097cf;
}

.tt-suggestion p {
    margin: 0;
}
~~~

Чтобы увидеть автозаполнение в действии, наберите в браузере URL
"http://localhost/typeahead" и нажмите Enter.
Появится страница *Typeahead*, и вам будет предложено ввести название континента.
Например, наберите букву *a* и увидите, как Typeahead предлагает вам имеющиеся
варианты (рисунок 6.7).

![Рисунок 6.7. Функция автозаполнения](../en/images/appearance/typeahead.png) 

T> Вы можете увидеть образец выше в работе в примере *Hello World*, поставляемом с этой книгой,
T> набрав в своем браузере "http://localhost/typeahead".

## Добавление таблиц стилей CSS на веб-страницу

Таблицы стилей CSS, как правило, помещаются в раздел `<head>` HTML-документа: 
либо в качестве ссылки на внешний файл (внешние файлы таблиц стилей CSS обычно хранятся в каталоге `APP_DIR/public/css`).

{line-numbers=off, lang=text}
~~~
<link rel="stylesheet" type="text/css" href="/css/style.css">
~~~

либо в качестве встроенного элемента `<style>`

{line-numbers=off, lang=php}
~~~
<style>
body {
    padding-top: 60px;
    padding-bottom: 40px;
}
</style>
~~~

Для хранения CSS-правил рекомендуются внешние таблицы стилей CSS. Например, базовые CSS-правила,
предоставляемые фреймворком Twitter Bootstrap, загружаются из файлов *bootstrap.min.css* и 
*bootstrap-theme.min.css*. Пользовательские CSS-правила для конкретного сайта можно хранить 
в файле *style.css*. Так как эти таблицы стилей нужны вам для большинства страниц, лучше
поместить ссылку на них в разделе заголовка шаблона лэйаута. Однако, если определенная
таблица стилей CSS должна быть загружена лишь для одной страницы, ее размещают на шаблоне
представления этой страницы.

Чтобы добавить внешнюю таблицу стилей CSS к шаблону представления, используйте помощник вида `HeadLink`:

{line-numbers=on, lang=php}
~~~
<?php
$this->headLink()->appendStylesheet('/css/style.css'); 
$this->headLink()->appendStylesheet(
       '//code.jquery.com/ui/1.10.3/themes/smoothness/jquery-ui.css'); 
~~~

В примере кода выше мы использовали метод `appendStylesheet` помощника вида `HeadLink`, чтобы
добавить внешнюю таблицу стилей CSS в раздел заголовка документа. Метод принимает путь
к локальному CSS-файлу (строка 2) или URL к CSS-файлу, расположенному на другом сервере (строка 3).

Краткое описание методов помощника вида `HeadLink` представлено в таблице 6.2.

{title="Таблица 6.2. Методы, предоставляемые помощником вида HeadLink"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `appendStylesheet()`           | Помещает ссылку на файл таблицы стилей CSS в конец.           |
|--------------------------------|---------------------------------------------------------------|
| `offsetSetStylesheet()`        | Вставляет ссылку на файл таблицы стилей CSS в список на заданную позицию.|
|--------------------------------|---------------------------------------------------------------|
| `prependStylesheet()`          | Помещает ссылку на файл внешней таблицы стилей CSS в начало.  |
|--------------------------------|---------------------------------------------------------------|
| `setStylesheet()`              | Очищает список и помещает в него один CSS-файл.               |
|--------------------------------|---------------------------------------------------------------|

Если хотите добавить встроенный элемент `<style>` в раздел заголовка документа, вы можете
использовать помощник вида `HeadStyle`. Его методы представлены ниже в таблице 6.3:

{title="Таблица 6.3. Методы помощника вида HeadStyle"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `appendStyle()`               | Добавляет встроенный CSS-код в конец.                         |
|--------------------------------|---------------------------------------------------------------|
| `offsetSetStyle()`             | Вставляет файл встроенной таблицы стилей CSS в список на заданную позицию.|
|--------------------------------|---------------------------------------------------------------|
| `prependStyle()`               | Помещает ссылку на файл внешей таблицы стилей CSS в начало.   |
|--------------------------------|---------------------------------------------------------------|
| `setStyle()`                   | Очищает список и помещает в него один CSS-файл.               |
|--------------------------------|---------------------------------------------------------------|

### Пример

Для демонстрации добавления таблицы стилей CSS на веб-страницу, рассмотрим реальный пример.
Допустим, вам нужно, чтобы пользователь мог вводить дату (в формате ГГГГ-ММ-ДД) в поле
ввода текста. Кроме того, для удобства пользователя необходимо добавить также всплывающий
виджет-календарь, где можно выбрать дату.

Чтобы это сделать, воспользуемся сторонней библиотекой jQuery UI [^jqueryui]. Для ее интеграции
скачайте два файла с [официальной страницы проекта](http://jqueryui.com/):

* *jquery-ui.min.js* -- минифицированная версия JavaScript-кода jQuery UI;

* *jquery-ui.min.css* -- минифицированная версия стилей jQuery UI.

[^jqueryui]:  jQuery UI предоставляет набор "взаимодействий с пользовательским интерфейсом, эффектов, виджетов, 
              и тем"; она основана на библиотеке jQuery. jQuery UI, как и Twitter Bootstrap предоставляет многократно
			  используемые компоненты пользовательского интерфейса.

Поместите файл *jquery-ui.min.js* в *APP_DIR/public/js*, а файл *jquery-ui.min.css* в 
*APP_DIR/public/css*. Затем добавьте шаблон представления *datepicker.phtml* в каталог *application/index/static*
под каталогом модуля *view*:

{line-numbers=on, lang=php}
~~~
<?php
$this->headTitle('Datepicker');

$this->headScript()->appendFile('/js/jquery-ui.min.js', 'text/javascript'); 
$this->headLink()->appendStylesheet('/css/jquery-ui.min.css'); 
?>

<h1>Datepicker</h1>

<p>
    Нажмите на окно редактирования ниже, чтобы воспользоваться календарем.
</p>

<input type="text" class="datepicker" title="Type here"/>

<script>      
$(document).ready(function() {
    $("input.datepicker").datepicker({ dateFormat: 'yy-mm-dd' });     
});
</script>
~~~

В этом примере мы используем метод `appendFile()` помощника вида `HeadScript` (строка 4),
чтобы добавить ссылку на файл *jquery-ui.min.js* в раздел заголовка документа.

В строке 5 мы используем метод `appendStylesheet()` помощника вида `HeadLink` (строка 5),
чтобы добавить ссылку на таблицу стилей CSS *jquery-ui.min.js* в раздел заголовка документа.

В строке 14 мы добавили поле ввода текста, которое будет использоваться для ввода даты.

В строках 16-20 мы добавили встроенный JavaScript-код, чтобы привязать обработчик событий
jQuery к полю ввода текста. Когда пользователь кликнет на поле, появится виджет-календарь,
в котором можно будет выбрать дату.

Чтобы посмотреть на результат, наберите URL "http://localhost/datepicker" в адресной строке
браузера (см. рисунок 6.8).

![Рисунок 6.8. Календарь](../en/images/appearance/datepicker.png) 

## Написание собственных помощников видов

Ранее в этой главе мы создали лэйаут, общий для всех страниц веб-сайта.
Однако нужно сделать еще пару вещей, чтобы лэйаут стал полностью функционирующим.
Если помните, шаблон лэйаута содержит панель навигации и навигационную цепочку.
Но оба этих компонента интерфейса на данный момент "статичны", а их необходимо
сделать более интерактивными.

Например, активный элемент панели навигации должен зависеть от действия контроллера,
выполняемого в данный момент. А навигационная цепочка должна отображать путь к текущей
просматриваемой странице. В этом разделе мы сделаем эти виджеты полностью готовыми
для работы на сайте с помощью наших собственных помощников видов.

Типичный помощник вида - это PHP-класс, который наследуется от класса
`Zend\View\Helper\AbstractHelper`, который в свою очередь реализует
интерфейс `Zend\View\Helper\HelperInterface` (диаграмма наследования классов
представлена на рисунке 6.9).

![Рисунок 6.9. Диаграмма класса помощника вида](../en/images/appearance/view_helper_inheritance.png)

### Меню 

Для начала реализуем класс помощника вида `Menu`, который будет визуализировать
HTML-код навигационной панели. Класс `Menu` будет содержать несколько методов, позволяющих
задать элементы меню в виде массива, определить активный пункт меню и отобразить меню (описание методов 
см. в таблице 6.4)

{title="Таблица 6.4. Методы помощника вида Menu"}
|----------------------------------|---------------------------------------------------------------|
| *Имя метода*                     | *Описание*                                                    |
|----------------------------------|---------------------------------------------------------------|
| `__construct($items)`            | Конструктор класса.                                           |
|----------------------------------|---------------------------------------------------------------|
| `setItems($items)`               | Метод для задания пунктов меню.                               |
|----------------------------------|---------------------------------------------------------------|
| `setActiveItemId($activeItemId)` | Метод для задания активного пункта меню.                      |
|----------------------------------|---------------------------------------------------------------|
| `render()`                       | Визуализирует меню.                                           |
|----------------------------------|---------------------------------------------------------------|
| `renderItem($item)`              | Визуализирует один пункт меню.                                |
|----------------------------------|---------------------------------------------------------------|

Информация, описывающая один пункт меню будет представлена в виде
массива, как показано ниже (например, у элемента *Home* будут ID, текстовая 
надпись и URL для гиперссылки):

{line-numbers=off,lang=php}  
~~~
[
    'id' => 'home',
    'label' => 'Home',
    'link' => $this->url('home')
]
~~~

Помимо этого мы хотим добавить поддержку выпадающих меню в качестве элементов навигации. Например,
в случае с выпадающим меню *Support*, содержащим подэлементы *Documentation* и *Help*, описание элемента
будет выглядеть следующим образом:

{line-numbers=off,lang=php}  
~~~
[
    'id' => 'support',
    'label' => 'Support',
    'dropdown' => [
        [
            'id' => 'documentation',
            'label' => 'Documentation',
            'link' => $this->url('doc', ['page'=>'contents'])
        ],
        [
            'id' => 'help',
            'label' => 'Help',
            'link' => $this->url('static', ['page'=>'help'])
        ]
    ]                        
]
~~~

Мы хотим поместить класс `Menu` в пространство имен `Application\View\Helper`. Поэтому, начнем с
создания файла `Menu.php` в директории *View/Helper* под корневым каталогом модуля *Application*
(рисунок 6.10). 

![Рисунок 6.10. Каталог помощника вида ](../en/images/appearance/view_helper_dir.png)

Q> **Почему мы размещаем класс помощника вида под корневым каталогом модуля?**
Q>
Q> Помощники видов (в отличие от шаблонов представления `.phtml`) хранятся под корневой директорией модуля `src/`,
Q> потому что они являются обычными PHP-классами и должны быть разрешены (resolve)
Q> функцией автозагрузки. С другой стороны, шаблоны представления разрешаются специальным ZF3-классом,
Q> называемым *разрешатель представления* (view resolver), и по этой причине шаблоны представления хранятся
Q> под каталогом модуля `view/`.

Затем напишем код класса `Menu`:

{line-numbers=on,lang=php}  
~~~
<?php
namespace Application\View\Helper;

use Zend\View\Helper\AbstractHelper;

// Этот класс помощника вида отображает панель меню.
class Menu extends AbstractHelper 
{
    // Массив пунктов меню.
    protected $items = [];
    
    // ID активного пункта.
    protected $activeItemId = '';
    
    // Конструктор.
    public function __construct($items=[]) 
    {
        $this->items = $items;
    }
    
    // Задаем пункты меню.
    public function setItems($items) 
    {
        $this->items = $items;
    }
    
    // Задаем ID активных пунктов.
    public function setActiveItemId($activeItemId) 
    {
        $this->activeItemId = $activeItemId;    
    }  
}
~~~

В этом фрагменте мы определили несколько private-полей для класса `Menu`. Поле `$items`
(строка 10) - это массив, который будет хранить информацию об элементах меню; а поле
`$activeItemId` - ID активного пункта меню. Этот пункт будет визуально выделен.

В строках 16-19 мы определили метод конструктора класса, который (опционально)
принимает массив элементов для инициализации меню. Другой способ инициализировать меню - 
через метод `setItems()` (строки 22-25). И наконец, метод `setActiveItemId()` задает
ID текущего активного пункта меню.

Теперь давайте добавим метод `render()`, который будет генерировать HTML-код для
всей панели навигации и вернет его в виде строки:

{line-numbers=on,lang=php}  
~~~
// Визуализация меню.
public function render() 
{
    if (count($this->items)==0)
        return ''; // Do nothing if there are no items.
        
    $result = '<nav class="navbar navbar-default" role="navigation">';
    $result .= '<div class="navbar-header">';
    $result .= '<button type="button" class="navbar-toggle" ';
    $result .= 'data-toggle="collapse" data-target=".navbar-ex1-collapse">';
    $result .= '<span class="sr-only">Toggle navigation</span>';
    $result .= '<span class="icon-bar"></span>';
    $result .= '<span class="icon-bar"></span>';
    $result .= '<span class="icon-bar"></span>';
    $result .= '</button>';
    $result .= '</div>';
       
    $result .= '<div class="collapse navbar-collapse navbar-ex1-collapse">';
    $result .= '<ul class="nav navbar-nav">';
        
    // Визуализация элементов
    foreach ($this->items as $item) {
        $result .= $this->renderItem($item);
    }
        
    $result .= '</ul>';
    $result .= '</div>';
    $result .= '</nav>';
        
    return $result;
}
~~~

В представленном выше коде мы создаем HTML-разметку для компонента панели навигации Bootstrap.
Панель будет использовать стандартную тему и будет складной (то есть, адаптироваться к различным
размерам экрана). Также у нее не будет текста с названием компании в заголовке.
В строках 22-24 мы перебираем все пункты меню и визуализируем каждый с помощью метода `renderItem()`.
После этого метод `render()` возвращает получившийся HTML-код в виде строки.

В завершение создания класса `Menu`, реализуем метод `renderItem()`. Он будет создавать
HTML-код для одного пункта меню:

{line-numbers=on,lang=php}  
~~~
// Визуализирует элемент.
protected function renderItem($item) 
{
    $id = isset($item['id']) ? $item['id'] : '';
    $isActive = ($id==$this->activeItemId);
    $label = isset($item['label']) ? $item['label'] : '';
        
    $result = ''; 
        
    if(isset($item['dropdown'])) {
            
        $dropdownItems = $item['dropdown'];
            
        $result .= '<li class="dropdown ' . ($isActive?'active':'') . '">';
        $result .= '<a href="#" class="dropdown-toggle" data-toggle="dropdown">';
        $result .= $label . ' <b class="caret"></b>';
        $result .= '</a>';
           
        $result .= '<ul class="dropdown-menu">';
 
        foreach ($dropdownItems as $item) {
            $link = isset($item['link']) ? $item['link'] : '#';
            $label = isset($item['label']) ? $item['label'] : '';
                
            $result .= '<li>';
            $result .= '<a href="'.$link.'">'.$label.'</a>';
            $result .= '</li>';
        }
    
        $result .= '</ul>';
        $result .= '</a>';
        $result .= '</li>';
            
    } else {        
        $link = isset($item['link']) ? $item['link'] : '#';
            
        $result .= $isActive?'<li class="active">':'<li>';
        $result .= '<a href="'.$link.'">'.$label.'</a>';
        $result .= '</li>';
    }
    
    return $result;
}
~~~

Итак, выше, в коде метода `renderItem()` мы проделали следующее.
Сначала мы проверили, является ли элемент выпадающим меню или обычным элементом (строка 10).
В первом случае мы проходим по всем пунктам выпадающего меню и визуализируем их по очереди (строки 21-28).
Строки 35-39 содержат код визуализации для второго случая.

Чтобы иметь возможность использовать помощник вида `Menu` в шаблоне представления, нужно зарегистрировать
его в конфигурации. Для этого добавьте ключ `view_helpers` в файл *module.config.php*:

{line-numbers=off,lang=php}  
~~~
<?php
return [

    // ...
    
    // Следующие строки регистрируют наши пользовательские классы
    // помощников видов в менеджере плагинов.
    'view_helpers' => [
        'factories' => [
            View\Helper\Menu::class => InvokableFactory::class,                    
        ],
       'aliases' => [
            'mainMenu' => View\Helper\Menu::class
       ]
    ],    
];
~~~

В примере выше мы зарегистрировали наш класс `Menu` как помощник вида `mainMenu`.
Мы сможем обращаться к нему из любого шаблона представления.

{line-numbers=on,lang=php}  
~~~
<!-- Панель навигации -->
<?php      
$this->mainMenu()->setItems([
    [
        'id' => 'home',
        'label' => 'Home',
        'link' => $this->url('home')
    ],
    [
        'id' => 'downloads',
        'label' => 'Downloads',
        'link' => $this->url("application", ['action'=>'downloads'])
    ],
    [
        'id' => 'support',
        'label' => 'Support',
        'dropdown' => [
            [
                'id' => 'documentation',
                'label' => 'Documentation',
                'link' => $this->url('doc', ['page'=>'contents'])
            ],
            [
                'id' => 'help',
                'label' => 'Help',
                'link' => $this->url('static', ['page'=>'help'])
            ]
        ]                        
    ],
    [
        'id' => 'about',
        'label' => 'About',
        'link' => $this->url('about')
    ],
]);

echo $this->mainMenu()->render(); 
?>
~~~

В этом фрагменте мы обращаемся к зарегистрированному ранее помощнику вида `mainMenu` и
задаем элементы панели навигации с помощью метода `setItems()` (строка 3).
В качестве параметра мы передаем методу массив элементов.
Затем мы визуализируем панель навигации с помощью метода `render()`.

Для задания активного элемента панели навигации, можно вызвать метод `setActiveItemId()` 
из любого шаблона представления. Например, добавьте следующий код в начало шаблона представления
страницы *About* (*application/index/about.phtml*).

{line-numbers=off,lang=php}  
~~~
<?php
$this->mainMenu()->setActiveItemId('about');
?>
~~~

Если вы теперь откроете страницу *About* в своем браузере, вы увидите, что
пункт *About* меню навигации выделен другим цветом. Чтобы должным образом
отобразить активный элемент, надо вызывать метод `setActiveItemId()` для каждой
страницы, находящейся в панели навигации (*Home*, *Downloads*, *Documentation* и т.д.)
Можете посмотреть, как это сделано, в нашем примере *Hello World*.

### Навигационная цепочка

Теперь, когда вы знаете, как реализовать помощник вида, давайте создадим еще один
для отображения навигационной цепочки. Он полностью аналогичен помощнику вида
`Menu`, так что мы просто приведем код класса `Breadcrumbs` целиком.

{line-numbers=on,lang=php}  
~~~
<?php
namespace Application\View\Helper;

use Zend\View\Helper\AbstractHelper;

// Этот класс помощника вида визуализирует навигационную цепочку.
class Breadcrumbs extends AbstractHelper 
{
    // Массив элементов.
    private $items = [];
    
    // Конструктор.
    public function __construct($items=[]) 
    {                
        $this->items = $items;
    }
    
    // Задаем элементы.
    public function setItems($items) 
    {
        $this->items = $items;
    }
    
    // Визуализируем навигационную цепочку.
    public function render() 
    {
        if(count($this->items)==0)
            return ''; // Ничего не делать, если элементов нет.
        
        // Полученный HTML-код будет храниться в этой переменной
        $result = '<ol class="breadcrumb">';
        
        // Получаем количество элементов
        $itemCount = count($this->items); 
        
        $itemNum = 1; // счетчик элементов
        
        // Проходим по элементам
        foreach ($this->items as $label=>$link) {
            
            // Делаем последний элемент неактивным
            $isActive = ($itemNum==$itemCount?true:false);
            
            // Визуализируем текущий элемент
            $result .= $this->renderItem($label, $link, $isActive);
                        
            // Инкрементируем счетчик элементов
            $itemNum++;
        }
        
        $result .= '</ol>';
        
        return $result;
    }
    
    // Визуализируем элемент.
    protected function renderItem($label, $link, $isActive) 
    {
        $result = $isActive?'<li class="active">':'<li>';
       
        if(!$isActive)
            $result .= '<a href="'.$link.'">'.$label.'</a>';
        else
            $result .= $label;
                    
        $result .= '</li>';
    
        return $result;
    }
}
~~~

Чтобы иметь возможность использовать помощник вида `Breadcrumbs`, нужно зарегистрировать
его в файле *module.config.php* следующим образом:

{line-numbers=on,lang=php}  
~~~
<?php
return [

    //...
    
    // The following registers our custom view helper classes.
    'view_helpers' => [
        'factories' => [      
            View\Helper\Breadcrumbs::class => InvokableFactory::class,          
        ],
        'aliases' => [
            'pageBreadcrumbs' => View\Helper\Breadcrumbs::class,
        ]
    ],
];
~~~

Так как мы планируем использовать помощник вида `Breadcrumbs` в шаблоне представления лэйаута, 
замените разметку навигационной цепочки в файле *layout.phtml* следующим кодом:

{line-numbers=off,lang=php}  
~~~
<!-- Навигационная цепочка -->
<?= $this->pageBreadcrumbs()->render(); ?>
~~~

В этих строках мы обращаемся к помощнику вида `pageBreadcrumbs()` и вызываем
его методом `render()`. Оператор `echo` затем выводит HTML-код навигационной
цепочки.

После этого нужно передать элементы навигационной цепочки для каждого шаблона представления.
Например, для страницы *About* добавьте следующий фрагмент кода в шаблоне представления.

{line-numbers=off,lang=php}  
~~~
<?php
$this->pageBreadcrumbs()->setItems([
            'Home'=>$this->url('home'),
            'About'=>$this->url('about'),
            ]);
?>
~~~

Теперь при открытии страницы вы увидите навигационную цепочку как на рисунке 6.11.
Пользователям сайта будет видно, на какой странице они находятся в данный момент, и 
они не смогут заблудиться.

![Figure 6.11. Навигационная цепочка для страницы About](../en/images/appearance/about_breadcrumbs.png)

## Класс ViewModel и композиция страницы

Ранее, при написании методов действия для классов контроллеров, мы использовали класс `ViewModel`
(view model - модель представления) как контейнер для переменных для передачи переменных от контроллера 
шаблону представления. Кроме того, мы использовали `ViewModel` для переопределения имени шаблона представления по умолчанию.

Однако, в действительности, класс `ViewModel` - больше, чем просто контейнер для переменных и имя шаблона
представления. На самом деле, он тесно связан  с лэйаутом и композицией страницы.

Третья важная возможность класса модели представления заключается в том, что он позволяет *комбинировать*
несколько моделей представления в древовидную структуру. Каждая модель представления в дереве имеет
связанное имя шаблона представления и переменные, которые могут быть переданы шаблону представления для
управления процессом визуализации.

Эта особенность внутренне используется Zend Framework 3 при "комбинировании" шаблона представления
лэйаута и шаблона представления, связанного с методом действия контроллера. ZF3 создает модель представления
для шаблона лэйаута и присваивает ему имя шаблона представления `layout/layout`. Когда метод действия
контроллера возвращает объект `ViewModel`, этот объект прикрепляется в качестве дочернего к модели представления
лэйаута (см. рисунок 6.12)

![Рисунок 6.12. Древовидная структура моделей представления](../en/images/appearance/viewmodel_tree.png)

В итоге, мы имеем следующий процесс визуализации страницы:

* Сперва идет обращение к дочерней модели представления, и визуализируется связанный с ней шаблон представления;
  получившаяся HTML-разметка сохраняется во временном хранилище.
* Затем эта разметка передается модели представления лэйаута как переменная
  `$content`. Таким образом шаблон представления лэйаута может визуализировать
  содержимое определенной страницы.

Таблица 6.5 содержит краткое описание методов для композиции страницы, предоставляемых классом `ViewModel`:

{title="Table 6.5. Methods of the ViewModel class for page composition"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `addChild()`                   | Добавляет дочернюю модель представления                       |
|--------------------------------|---------------------------------------------------------------|
| `getChildren()`                | Получает список дочерних моделей представления.               |
|--------------------------------|---------------------------------------------------------------|
| `hasChildren()`                | Проверяет, есть ли у модели представления дочерние модели.    |
|--------------------------------|---------------------------------------------------------------|
| `clearChildren()`              | Удаляет все дочерние модели представления.                    |
|--------------------------------|---------------------------------------------------------------|
| `count()`                      | Возвращает количество моделей представления.                  |
|--------------------------------|---------------------------------------------------------------|
| `getIterator()`                | Возвращает итератор для дочерних моделей представления        |
|--------------------------------|---------------------------------------------------------------|
| `setTerminal()`                | Устанавливает флаг конечной точки.                            |
|--------------------------------|---------------------------------------------------------------|
| `terminate()`                  | Проверяет, является ли модель представления концевой.         |
|--------------------------------|---------------------------------------------------------------|
| `setCaptureTo()`               | Задает имя переменной для захвата вывода.                     |
|--------------------------------|---------------------------------------------------------------|
| `setAppend()`                  | Устанавливает флаг присоединения.                             |
|--------------------------------|---------------------------------------------------------------|
| `isAppend()`                   | Проверяет, присоединять ли эту модель представления к другой. |
|--------------------------------|---------------------------------------------------------------|

Ниже мы опишем эти методы чуть подробнее.

Методы `addChild()`, `getChild()`, `hasChildren()` и `clearChildren()` используются для, соответственно,
добавления дочерней модели представления к родительской, извлечения массива прикрепленных моделей
представления, проверки, является ли модель листовой (не имеющей дочерних моделей), и отсоединения
всех дочерних моделей.

Метод `setCaptureTo()` позволяет задать переменную в родительском шаблоне представления, в которую будет
вставлен код HTML-разметки, созданный дочерним шаблоном представления. Если две дочерние модели представления
используют одну и ту же переменную, вторая перезапишет первую.
Метод `setAppend() может быть использован, когда вам необходимо вставить результаты двух или более шаблонов
представления в одну переменную. Следующий визуализируемый шаблон представления будет добавлен к существующему
содержимому переменной. Модели представления, возвращаемой контроллером, присваивается переменная `$content`.

Модель представления может быть отмечена *концевой* (terminal) с помощью метода `setTerminal()`. Этот метод
принимает один булевый параметр. При значении `true` модель представления считается концевой (родителем верхнего
уровня) и визуализатор возвращает выходные данные шаблона представления приложению; иначе его родители тоже
визуализируются. Метод `terminate()` проверяет, является ли модель представления концевой или нет.

T> Метод `setTerminal()` очень полезен в некоторых ситуациях, так как с его помощью вы
T> можете отключить визуализацию шаблона представления лэйаута. Если вы вернете из контроллера 
T> модель представления, отмеченную концевой, лэйаут не будет применен. Это можно использовать,
T> например, когда вы хотите загрузить часть страницы AJAX-запросом [^ajax] асинхронно и вам нужно
T> вставить ее HTML-код в DOM-дерево имеющейся страницы.
 
[^ajax]: AJAX (Asynchronous JavaScript and XML - асинхронный JavaScript и XML) - технология,
         предоставляемая современными браузерами, используемая для отправки данных серверу, а также
		 их извлечения, асинхронно (в фоновом режиме), не вмешиваясь в отображение и поведение
		 имеющейся страницы.
  
## Выводы

Zend Framework 3 поставляется с Twitter Bootstrap - CSS-фреймворком, позволяющим
создавать привлекательные внешне и профессионально выглядящие веб-приложения. Он
предоставляет базовые CSS-правила, простую сетку лэйаута и полезные компоненты
интерфейса (панели навигации, навигационные цепочки, пагинации и др.)

Страницы типичного веб-сайта имеют общую структуру (например, типичная страница содержит
панель навигации наверху, тело с содержимым страницы и футер с информацией об авторских
правах внизу). В Zend Framework 3 вы определяете эту общую структуру с помощью файла
шаблона представления, называемого лэйаутом. Лэйаут может иметь плейсхолдер(ы), куда
ZF3 помещает содержимое определенной веб-страницы.

Помощники видов - это простые (относительно) PHP-классы, которые инкапсулируют часть
процесса визуализации. Например, они позволяют собирать страницу из нескольких частей,
задавать заголовок страницы и метатеги, а также создавать многократно используемые виджеты
вроде панели навигации или навигационной цепочки.
