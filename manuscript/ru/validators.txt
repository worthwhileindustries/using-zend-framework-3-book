# Проверка входных данных с помощью валидаторов {#validators}

В этой главе мы рассмотрим стандартные валидаторы ZF, которые можно использовать для веб-форм, а также
покажем, как написать свой собственный валидатор. Валидатор - это класс, который принимает входные данные, 
проверяет их на корректность и возвращает булевый результат, сообщающий, корректны ли данные (и сообщения
об ошибках, если данные их содержат).

I> В целом, валидаторы можно использовать даже *вне* форм для обработки произвольных данных.
I> Например, вы можете использовать валидаторы в действии контроллера для обеспечения того, что
I> данные переданные в виде переменных GET и/или POST безопасны и соответствует определенному формату.

Компоненты ZF3, рассматриваемые в этой главе:

|--------------------------------|---------------------------------------------------------------|
| *Компонент*                    | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Validator`               | Реализует различные классы валидаторов.                       |
|--------------------------------|---------------------------------------------------------------|
| `Zend\InputFilter`             | Реализует контейнер для фильтров/валидаторов.                 |
|--------------------------------|---------------------------------------------------------------|

## О валидаторах

*Валидатор* предназначен для приема входных данных, проверки их на корректность и возврата булевого
результата, сообщающего, корректны ли данные. Если данные некорректны, валидатор генерирует список ошибок,
описывающих, почему проверка не была пройдена.

### ValidatorInterface

В ZF3 *валидатор* - это PHP-класс, реализующий интерфейс `ValidatorInterface` (он принадлежит
пространству имен `Zend\Validator`). Определение интерфейса представлено ниже:

{line-numbers=on, lang=php}
~~~
<?php
namespace Zend\Validator;

interface ValidatorInterface
{
  // Возвращает значение true тогда и только тогда, когда $value отвечает требованиям валидации.
  public function isValid($value);

  // Возвращает массив сообщений объясняющих, почему 
  // последний вызов isValid() вернул значение false. 
  public function getMessages();
}
~~~	

Как видите, `ValidatorInterface` имеет два метода: `isValid()` (строка 7) и `getMessages()` (строка 11).

Первый метод, `isValid()`, предназначен для осуществления проверки входного
значения (параметра `$value`). Если валидация `$value` проходит, метод `isValid()`
возвращает булевое true; при неудаче возвращается false.

T> В отдельных случаях класс валидатора, реализующий интерфейс `ValidatorInterface`, может иметь и другие методы.
T> Например, у большого количества классов есть методы для настройки валидатора (задания опций валидации).

## Обзор стандартных валидаторов

Стандартные валидаторы ZF3 предоставлены компонентом `Zend\Validator` [^std-validators].
Диаграмма наследования классов стандартных валидаторов показана на рисунке 9.1. Как видите из рисунка,
большинство из них наследуется от базового класса `AbstractValidator`.

[^std-validators]: В этом разделе мы считаем стандартными только те валидаторы, которые принадлежат пространству имен `Zend\Validator`.
              Однако существуют и другие валидаторы, которые можно считать стандартными. Мы рассмотрим их в следующих главах.
			 
![Рисунок 9.1. Наследование классов валидаторов](../en/images/validators/validator_inheritance.png)
 
Стандартные валидаторы вместе с их кратким описанием перечислены в таблице 9.1. Как видите из этой таблицы, стандартные 
валидаторы можно приблизительно разделить на следующие группы:

 * валидаторы для проверки соответствия значения определенному формату (IP-адрес, имя хоста, адрес эл. почты, номер кредитной карты и т.д.);
 * валидаторы для проверки того, что числовое значение лежит в заданном диапазоне (меньше чем, больше чем, между и т.д.);
 * валидаторы, выступающие "заместителями" (proxies) для других валидаторов (`ValidatorChain`, `StaticValidator` и `Callback`).

{title="Таблица 9.1. Стандартные валидаторы"}
|--------------------------------|---------------------------------------------------------------|
| *Имя класса*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `EmailAddress`                 | Возвращает булевое `true`, если значение - действительный адрес эл. почты; иначе возвращает `false`. |
|--------------------------------|---------------------------------------------------------------|
| `Hostname`                     | Проверяет, является ли значение действительным именем хоста.  |
|--------------------------------|---------------------------------------------------------------|
| `Barcode`                      | Возвращает булевое `true` тогда и только тогда, когда значние содержит действительый штрих-код. |
|--------------------------------|---------------------------------------------------------------|
| `CreditCard`                   | Возвращает `true` тогда и только тогда, когда значение соответствует общему формату номера кредитной карты (Алгоритм Луна, контрольная сумма кратна 10). |   
|--------------------------------|---------------------------------------------------------------|
| `Iban`                         | Возвращает `true`, если значение - действительный международный номер банковского счёта (International Bank Account Number - IBAN); иначе возвращает `false`. |
|--------------------------------|---------------------------------------------------------------|
| `Isbn`                         | Возвращает булевое `true` тогда и только тогда, когда значение - действительный международный стандартный книжный номер (International Standard Book Number - ISBN). |
|--------------------------------|---------------------------------------------------------------|
| `Ip`                           | Возвращает `true`, если значение - действительный IP-адрес; иначе возвращает `false`. |
|--------------------------------|---------------------------------------------------------------|
| `Uri`                          | Возвращает `true` тогда и только тогда, когда значение - единообразный идентификатор ресурса (Uniform Resource Identifier - URI). |
|--------------------------------|---------------------------------------------------------------|
| `Between`                      | Возвращает `true`, если значение находится в определенном диапазоне; иначе возвращает `false`. |
|--------------------------------|---------------------------------------------------------------|
| `LessThan`                     | Возвращает булевое `true`, если значение меньше определенного числа; иначе возвращает `false`. |
|--------------------------------|---------------------------------------------------------------|
| `GreaterThan`                  | Возвращает `true` тогда и только тогда, когда значение больше определенного числа. |
|--------------------------------|---------------------------------------------------------------|
| `Identical`                    | Возвращает булевое `true`, если значение совпадает с заданным токеном. |
|--------------------------------|---------------------------------------------------------------|
| `Step`                         | Проверяет, является ли значение скалярным и действительной величиной шага. |
|--------------------------------|---------------------------------------------------------------|
| `Csrf`                         | Этот валидатор проверяет, совпадает ли заданный токен с сгенерированным ранее и хранящимся в PHP-сессии. |
|--------------------------------|---------------------------------------------------------------|
| `Date`                         | Возвращает `true`, если значение - действительная дата определенного формата. |
|--------------------------------|---------------------------------------------------------------|
| `DateStep`                     | Возвращает булевое `true`, если дата находится внутри действительного шага. |
|--------------------------------|---------------------------------------------------------------|
| `InArray`                      | Возвращает `true`, если значение содержится в заданном массиве; иначе возвращает false.|
|--------------------------------|---------------------------------------------------------------|
| `Digits`                       | Возвращает булевое `true` тогда и только тогда, когда $value содержит только цифровые символы. |
|--------------------------------|---------------------------------------------------------------|
| `Hex`                          | Возвращает `true` тогда и только тогда, когда значение содержит только шестнадцатеричные символы. |
|--------------------------------|---------------------------------------------------------------|
| `IsInstanceOf`                 | Возвращает `true`, если значение является экземпляром определенного класса; иначе возвращает `false`. |
|--------------------------------|---------------------------------------------------------------|
| `NotEmpty`                     | Возвращает `true`, если значение не является пустым массивом. |
|--------------------------------|---------------------------------------------------------------|
| `Regex`                        | Возвращает `true`, если значение соответствует заданному шаблону; иначе возвращает `false`.|
|--------------------------------|---------------------------------------------------------------|
| `StringLength`                 | Возвращает `true`, если длина строки лежит в заданном диапазоне. |
|--------------------------------|---------------------------------------------------------------|
| `Explode`                      | Разделяет принимаемое значение на части и возвращает `true`, если все части проходят заданную проверку. |
|--------------------------------|---------------------------------------------------------------|
| `StaticValidator`              | Этот валидатор позволяет выполнить другой валидатор без явного инстанцирования второго. |
|--------------------------------|---------------------------------------------------------------|
| `Callback`                     | Этот валидатор позволяет выполнить пользовательский алгоритм валидации, используя предоставляемую пользователем функцию обратного вызова. |
|--------------------------------|---------------------------------------------------------------|
| `ValidatorChain`               | Валидатор-обертка, позволяющий организовать несколько валидаторов в цепь. Присоединенные валидаторы запускаются в том же порядке, в котором они были добавлены в цепочку (FIFO - «первым пришёл — первым ушёл»).|
|--------------------------------|---------------------------------------------------------------|

## Поведение валидаторов в случае недействительных или недопустимых данных

Если вы передаете валидатору какие-либо данные, которые не проходят проверку,
валидатор внутренне создает список сообщений об ошибках, который можно извлечь
методом `getMessages()`. Посмотрим, например, на возможные ошибки валидации,
которые вернет `EmailValidator`, если вы передадите ему значение "abc@ewr"
(обратный слеш `\` обозначает переводы строки там, где код не помещается на странице книги):

{line-numbers=off, lang=text}
~~~
array(3) { 
  ["emailAddressInvalidHostname"] => 
    string(51) "'ewr' is not a valid hostname for the email address" 
  ["hostnameInvalidHostname"] => 
    string(66) "The input does not match the expected structure for a DNS hostname" 
  ["hostnameLocalNameNotAllowed"] => 
    string(84) "The input appears to be a local network name but local network names are not allowed" 
}
~~~
   
Метод валидатора `getMessages()` вернет массив сообщений, объясняющих, почему валидация была неудачной.
Ключи массива - это идентификаторы сообщений об ошибках валидации, а значения - соответствующие 
строки в удобном для человеческого восприятия виде.
   
Если метод `isValid()` никогда не вызывался или последний вызов `isValid()` вернул `true`, тогда
метод `getMessages()` возвращает пустой массив. Кроме того, когда вы вызываете `isValid()` несколько
раз, предыдущие сообщения о валидации удаляются, и вы видите только ошибки валидации из последнего
вызова.
   
Некоторые валидаторы могут работать только с данными в определенном формате (например, валидатор может требовать, чтобы
входные данные были в виде строки, но не массива). Если вы передадите такому валидатору данные в недопустимом формате,
валидатор может выбросить исключение `Zend\Validator\Exception\RuntimeException` или выдать PHP-предупреждение.

I> Рекомендуется проверять документацию определенного валидатора, чтобы знать о его поведении 
I> в случае недопустимых данных.

## Инстанцирование валидатора

В Zend Framework 3 существует несколько способов создания валидатора:

 * инстанцировать его вручную (с помощью оператора `new`);
 * создать его с помощью класса фабрики (передав описание в виде массива), 
   этот способ чаще всего используется при добавлении правил валидации к форме; и
 * инстанцировать его неявно с помощью класса-обертки `StaticValidator`.

Далее мы рассмотрим эти три способа более детально. 

### Способ 1: Инстанцирование валидатора вручную

Валидатор, в целом, можно использовать не только с формами, но и для валидации
произвольных данных. Для того, чтобы это сделать, просто создайте экземпляр класса 
валидатора, настройте валидатор с помощью предоставляемых им методов и вызовите для
него метод `isValid()`.

В качестве образца рассмотрим использование валидатора `EmailAddress`, который проверяет
адрес электронной почты на соответствие стандарту [RFC-2822](https://tools.ietf.org/html/rfc2822).
Электронный адрес, как правило, состоит из локальной части (имени пользователя), за которой
следует символ "at" (@), также называемый "собакой", за которым в свою очередь следует имя 
хоста. Например, в адресе "name@example.com", "name" - локальная часть, а "example.com" - имя хоста.

I> Валидатор `EmailAddress` полезен для проверки введенных пользователями на формах электронных адресов
I> на корректность.
I> Валидатор будет проверять адрес на корректность локальной части и имени хоста,
I> наличие символа "at" (@), а также (опционально) будет подключаться к хосту 
I> получателя и спрашивать DNS-сервер о существовании MX-записи (MX расшифровывается как Mail 
eXchanger - «почтовый обменник») [^mx_record]. 

[^mx_record]: MX-запись - это тип записи, используемый в системе доменных имен (Domain Name System - DNS).
              MX-записи определяют один или несколько адресов почтовых серверов, принимающих почту для
			  домена получателя. 			  

Методы, предоставляемые валидатором `EmailAddress` перечислены в таблице 9.2:

{title="Table 9.2. Public-методы валидатора EmailAddress"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор валидатора. Принимает список опций для его настройки. |
|--------------------------------|---------------------------------------------------------------|
| `isValid($value)`              | Вовращает `true`, если значение является действительным адресом эл. почты согласно RFC-2822; иначе возвращает `false`. |
|--------------------------------|---------------------------------------------------------------|
| `getMessages()`                | Если валидация была неудачной, этот метод вернет массив сообщений об ошибках. |
|--------------------------------|---------------------------------------------------------------|
| `useDomainCheck($domain)`      | Указывает валидатору проверить имя хоста на корректность.     |
|--------------------------------|---------------------------------------------------------------|
| `getDomainCheck()`             | Возвращает `true`, если включена проверка имени хоста.        |
|--------------------------------|---------------------------------------------------------------|
| `setHostnameValidator($hostnameValidator)` | Добавляет валидатор для проверки части эл. адреса, содержащей имя хоста. |
|--------------------------------|---------------------------------------------------------------|
| `getHostnameValidator()`       | Возвращает валидатор, использованный для проверки части эл. адреса, содержащей имя хоста. |
|--------------------------------|---------------------------------------------------------------|
| `setAllow($allow)`             | Задает допустимые типы имен хостов в адресе электронной почты.|
|--------------------------------|---------------------------------------------------------------|
| `getAllow()`                   | Возвращает допустимые типы имен хостов.                       |
|--------------------------------|---------------------------------------------------------------|
| `useMxCheck($mx)`              | Определяет, осуществлять ли проверку MX-записи через DNS.     |
|--------------------------------|---------------------------------------------------------------|
| `getMxCheck($mx)`              | Возвращает`true`, если включен режим проверки MX.             |
|--------------------------------|---------------------------------------------------------------|
| `useDeepMxCheck($deep)`        | Определяет, использовать ли глубокую проверку для MX-записей. |
|--------------------------------|---------------------------------------------------------------|
| `getDeepMxCheck()`             | Возвращает `true`, если включен режим глубокой проверки MX; иначе возвращает `false`. |
|--------------------------------|---------------------------------------------------------------|                       
| `isMxSupported()`              | Возвращает `true`, если системой поддерживается проверка MX через PHP-функцию `getmxrr()`; иначе возвращает `false`. |
|--------------------------------|---------------------------------------------------------------|
| `getMXRecord()`                | После проверки возвращает найденную MX-запись.                |
|--------------------------------|---------------------------------------------------------------|

Как видите из таблицы выше, валидатор `EmailAddress`, вдобавок к методам `isValid()` и `getMessages()`, предоставляет
метод конструктора, которому вы можете при желании передать полный список опций для инициализации валидатора.

I> У всех стандартных валидаторов есть метод конструктора, принимающий (опционально) массив опций
I> для настройки валидатора при его инстанцировании вручную.

Класс `EmailAddress` также предоставляет большое количество методов, которые можно использовать
для задания определенных опций валидатора.

Метод `useDomainCheck()` указывает, нужно ли проверять имя хоста на корректность или нет.
По умолчанию, эта проверка включена. Метод `setAllow()` позволяет указать, какие типы
имен хостов разрешены. Вы можете передать комбинацию ИЛИ констант с префиксом `ALLOW_`
[^allow_constants] методу `setAllow()`:

  * `ALLOW_DNS`  Разрешить доменное имя (по умолчанию), 
  * `IP_ADDRESS` Разрешить IP-адрес,
  * `ALLOW_LOCAL` Разрешить имя локальной сети,
  * `ALLOW_ALL`  Разрешить все вышеперечисленные.

[^allow_constants]: Константы с префиксом `ALLOW_` предоставляются валидатором `Hostname`.
  
I> Валидатор `EmailAddress` внутренне использует валидатор `Hostname` для проверки части имени хоста
I> адреса электронной почты. Вы также можете добавить пользовательский валидатор имени хоста, используя метод 
I> `setHostnameValidator()`, однако вам вряд ли понадобится это делать. 

Метод `useMxCheck()` определяет, нужно ли валидатору подключаться к хосту отправителя и запрашивать
у DNS-сервера MX-запись(-и). Если у сервера нет MX-записей, валидация будет неудачной.
Кроме этого, вы можете использовать метод `useDeepMxCheck()`, чтобы валидатор сравнивал адреса
почтовых серверов, полученных из MX-записей, с черным списком зарезервированных доменных имен
и осуществлял дополнительную проверку для каждого обнаруженного адреса.

T> Вообще, проверку MX (как и глубокую проверку MX) осуществлять не рекомендуется, так как это может занять
T> много времени и уменьшить скорость загрузки веб-страницы. По умолчанию, эти проверки отключены.

Ниже мы приведем образцы кода, показывающие два эквивалентных способа создания экземпляра
валидатора `EmailAddress` вручную, задания его опций и проверки входного значения:

**Пример 1. Передача опций методу конструктора.**

{line-numbers=on, lang=php}
~~~
<?php
// Определяем псевдоним для имени класса валидатора (опционально).
use Zend\Validator\EmailAddress;
use Zend\Validator\Hostname;

// Создаем экземпляр валидатора, передавая опции конструктору.
$validator = new EmailAddress([
		'allow' => Hostname::ALLOW_DNS|Hostname::ALLOW_IP|Hostname::ALLOW_LOCAL,
		'mxCheck' => true,
		'deepMxCheck' => true
	]);

// Валидируем адрес эл. почты.
$isValid = $validator->isValid('name@example.com'); // Возвращает true.
$isValid2 = $validator->isValid('abc'); // Возвращает false.

if(!$isValid2) {
  // Получаем сообщения об ошибках в случае неудачной валидации.
  $errors = $validator->getMessages();
}
~~~

Во фрагменте выше мы создаем объект валидатора `EmailAddres` с помощью оператора `new` (строка 7).
Мы передаем конструктору массив опций. Чтобы разрешить адресу эл. почты быть либо доменным именем,
либо IP-адресом, либо адресом локальной сети мы используем ключ `allow`. Кроме этого, мы используем
`mxCheck` и `deepMxCheck`, чтобы включить проверку соответственно проверки MX-записи и глубокую
проверку MX-записи.

В строке 14 мы вызываем метод `isValid()` и передаем ему строковое значение "name@example.com" 
для проверки. Ожидаемый результат этого вызова - булевое `true`.

В строке 15 мы передаем валидатору строковое значение "abc". Процедура валидации должна быть неудачной
(возвращается `false`). Затем сообщения об ошибках извлекаются с помощью метода `getMessages()` (строка 19).

**Пример. Без передачи опций конструктору.**

{line-numbers=on, lang=php}
~~~
<?php
// Определяем псевдоним для имени класса валидатора (опционально).
use Zend\Validator\EmailAddress;
use Zend\Validator\Hostname;

// Создаем экземпляр валидатора.
$validator = new EmailAddress();

// Настраиваем валидатор (опционально).
$validator->setAllow(
       Hostname::ALLOW_DNS|Hostname::ALLOW_IP|Hostname::ALLOW_LOCAL);
$validator->useMxCheck(true);
$validator->useDeepMxCheck(true);

// Валидируем адрес эл. почты.
$isValid = $validator->isValid('name@example.com'); // Returns true.
$isValid2 = $validator->isValid('abc'); // Returns false.

if(!$isValid2) {
  // Получаем сообщения об ошибках в случае неудачной валидации.
  $errors = $validator->getMessages();
}
~~~

Во фрагменте выше мы создаем объект валидатора `EmailAddres` с помощью оператора `new` (строка 7).

В строках 10-13 мы настраиваем валидатор. Мы вызываем метод `setAllow()`, чтобы разрешить адресу
эл. почты быть либо доменным именем, либо IP-адресом, либо адресом локальной сети. Помимо этого,
мы используем `mxCheck` и `deepMxCheck`, чтобы включить проверку соответственно проверки MX-записи 
и глубокую проверку MX-записи.

В строке 16  мы вызываем метод `isValid()` и передаем ему строковое значение "name@example.com" 
для проверки. Ожидаемый результат этого вызова - булевое `true`.

В строке 17 мы передаем валидатору строковое значение "abc". Процедура валидации должна быть неудачной
(возвращается `false`). Затем сообщения об ошибках извлекаются с помощью метода `getMessages()` (строка 21).

### Способ 2. Использование обертки StaticValidator

Альтернативный способ ручного инстанцирования валидатора - с использованием класса `StaticValidator`. 
Класс `StaticValidator` - что-то вроде "заместителя" ("proxy"), который предназначен для автоматического 
инстанцирования валидатора, настройки и выполнения. Рассмотрим, например, как создать 
тот же валидатор `EmailAddress`, настроить его и вызывать его метод `isValid()`:

{line-numbers=on, lang=php}
~~~
<?php
// Создание и выполнение валидатора EmailAddress через "заместителя" StaticValidator.
$validatedValue = \Zend\Validator\StaticValidator::execute('name@example.com', 
                    'EmailAddress', 
                    [
                      'allow' => 
                         Hostname::ALLOW_DNS|
                         Hostname::ALLOW_IP|
                         Hostname::ALLOW_LOCAL,
                      'mxCheck' => true,
                      'deepMxCheck' => true
                    ]);
						
// Ожидаемый результат - булевое true.
~~~

Класс `StaticValidator` предоставляет статический метод `execute()`, который
принимает три аргумента: входное значение, имя валидатора, который нужно применить
и массив опций для выбранного валидатора.

В строке 3 мы вызываем метод `execute()`, чтобы автоматически создать валидатор `EmailAddress`,
вызвать его методы setAllowDns()`, `useMxCheck()` и `useDeepMxCheck()`, а также передать входное 
значение методу `isValid()`. Это крайне полезно, так как может быть выполнено одним вызовом.

I> `StaticValidator` не предоставляет возможности извлечь список ошибок
I> в удобном для человеческого восприятия виде. Однако, так как `StaticValidator` предназначен
I> для использования вне форм, а не отображения результатов человеку, это 
I> не кажется большим недостатком.

### Способ 3. Использование описания в виде массива

При использовании валидаторов для правил валидации формы, как правило, объект
валидатора не создают явно, как мы сделали это в предыдущем разделе; вместо этого
настройки передаются в виде массива классу фабрики, автоматически создающему
валидатор, который затем можно настроить. Мы уже сталкивались с подобным способом
при добавлении правил валидации для формы обратной связи в главе
[Получение введенных пользователем данных с помощью форм](#forms).

В качестве примера покажем, как создать все тот же валидатор `EmailAddress` с 
помощью фабрики:

{line-numbers=on, lang=php}
~~~
<?php
// Предполагается, что вы вызываете следующий код внутри метода
// addInputFilter() модели формы.

$inputFilter->add([
  // ...  
  'validators'  => [
    [
      'name' => 'EmailAddress',
      'options' => [
        'allow' => \Zend\Validator\Hostname::ALLOW_DNS,
        'useMxCheck' => false,
        'useDeepMxCheck' => false,
      ],
    ],
  ],                
  // ...
]);
~~~

В фрагменте кода выше мы вызываем метод `add()`, предоставляемый классом-контейнером `InputFilter` (строка 5).
Метод `add()` принимает массив, который имеет ключ `validators`. Как правило, валидаторы регистрируются
под этим ключом (строка 7). Валидаторы, зарегистрированные под этим ключом, вставляются в цепь валидаторов
в том же порядке, что и в списке.

Конфигурация валидатора обычно состоит из имени - `name` (строка 9) и опций - `options` (строка 10). Имя - 
это полностью определенное имя класса валидатора (например, `\Zend\Validator\EmailAddress`), либо его 
псевдоним (`EmailAddress`). `options` - это массив, состоящий из опций конкретного валидатора. Когда
класс фабрики инстанцирует валидатор, он передает список опций методу конструктора валидатора, а конструктор 
при необходимости инициализирует валидатор.

## О менеджере плагинов валидаторов

При создании валидатора с помощью фабрики можно использовать либо полностью определенное имя класса валидатора, 
либо его псевдоним. Псевдонимы для стандартных валидаторов определяются классом `ValidatorPluginManager`.

I> Класс `ValidatorPluginManager` определяет псевдонимы валидаторов.

Псевдоним стандартного валидатора, как правило, такой же, как и имя класса. Например, у
класса `Zend\Validator\EmailAddress` псевдоним `EmailAddress`.

Менеджер плагинов валидаторов внутренне используется классом-контейнером `InputFilter` для
инстанцирования стандартных валидаторов.

## Примеры использования валидаторов

Далее мы рассмотрим примеры использования самых важных стандартных валидаторов. Мы
опишем методы (и опции) валидатора и приведем фрагменты кода, показывающие, как
инстанцировать валидатор и применить его к входным данным.

### Валидаторы для проверки соответствия значения определенному формату

В этом разделе мы рассмотрим примеры использования валидаторов, связанных
с проверкой соответствия входного значения определенному формату

#### Ip Validator

Класс валидатора предназначен для проверки того, является ли входное значение действительным IP-адресом.
Если входное значение является IPv4-адресом [^ipv4_адрес], IPv6-адресом [^ipv6_адрес], IPvFuture-адресом
[^ipvfuture_адрес] или буквенным IPv6-адресом [буквенный_^ipv6_адрес], валидатор возвращает значение `true`;
иначе возвращается `false`. В случае неудачи, сообщения об ошибках можно извлечь с помощью метода `getMessages()`.

[^ipv4_адрес]: Четвертая версия интернет протокола (Internet Protocol version 4 - IPv4) использует адреса, как правило, состоящие 
                 из четырех октетов, разделенных точками. В виде десятичных чисел запись выглядит как "192.168.56.101".
				 
[^ipv6_адрес]: Шестая версия интернет протокола (Internet Protocol version 6 - IPv6) использует адреса, как правило, состоящие
                 из восьми групп четырех шестнадцатеричных цифр, разделенных двоеточиями, например, "2001:0db8:85a3:0000:0000:8a2e:0370:7334".				 

[^ipvfuture_адрес]: IPvFuture  весьма расплывчато определен в главе 3.2.2 RFC 3986.
				 
[^буквенный_ipv6_адрес]: Буквенный IPv6-address - это модификация обычного IPv6-адреса для использования внутри URL. 
                  (проблема с оригинальными IPv6-адресами в том, что символы ":" и "." в URL являются разделителями.)				 
				 
Public-методы, предоставляемые валидатором `Ip` перечислены в таблице 9.3:

{title="Таблица 9.3. Public-методы валидатора Ip"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода *                  | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор валидатора. Принимает список опций.               |
|--------------------------------|---------------------------------------------------------------|
| `isValid($value)`              | Возвращает `true` тогда и только тогда, когда значение является действительным IP-адресом. |
|--------------------------------|---------------------------------------------------------------|
| `getMessages()`                | При неудачной валидации этот метод вернет массив сообщений об ошибках. |
|--------------------------------|---------------------------------------------------------------|
| `setOptions($options)`         | Задает опции валидатора.                                      |
|--------------------------------|---------------------------------------------------------------|

Метод `setOptions()` предоставляет возможность определить разрешенные типа IP-адресов:
 
  * `allowipv4` для разрешения IPv4-адресов;
  * `allowipv6` для разрешения IPv6-адресов;
  * `allowipvfuture` для разрешения IPvFuture-адресов;
  * `allowliteral` для разрешения буквенных IPv6-адресов.
  
По умолчанию разрешены все вышеперечисленные адреса кроме буквенных IPv6.
  
Ниже показан пример кода, демонстрирующий использование валидатора `Ip`.

{line-numbers=off, lang=php}
~~~
<?php
use Zend\Validator\Ip;

// Создаем валидатор Ip.
$validator = new Ip();

// Настраиваем валидатор.
$validator->setOptions([
    'allowipv4'      => true,  // Разрешаем IPv4-адреса.
    'allowipv6'      => true,  // Разрешаем IPv6-адреса.
    'allowipvfuture' => false, // Разрешаем IPvFuture-адреса.
    'allowliteral'   => true,  // Разрешаем IP-адреса в буквенном формате.
  ]);

// Проверяем, является ли входное значение действительным IP-адресом (IPv4).
$isValid = $validator->isValid('192.168.56.101'); // Возвращает true

// Проверяем, является ли входное значение действительным IP-адресом (IPv6).
$isValid2 = $validator->isValid(
       '2001:0db8:85a3:0000:0000:8a2e:0370:7334'); // Возвращает true

// Передает недействительную строку (не содержащую IP-адрес).       
$isValid3 = $validator->isValid('abc'); // Возвращает false
~~~

#### Hostname Validator

Валидатор `Hostname` предназначен для проверки того, является ли заданное значение именем хоста,
принадлежащим к набору разрешенных типов. Такими типами являются:

  * DNS-имя (например, "example.com");
  * IP-адрес (например, "192.168.56.101");
  * имя локального хоста (например, "localhost"). 

Public-методы, предоставляемые этим валидатором, перечислены в таблице 9.4:
  
{title="Таблица 9.4. Public-методы валидатора Hostname"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор валидатора. Принимает список опций.               |
|--------------------------------|---------------------------------------------------------------|
| `isValid($value)`              | Вовращает `true`, если значение является действительным именем хоста; иначе возвращает `false`. |
|--------------------------------|---------------------------------------------------------------|
| `getMessages()`                | При неудачной валидации этот метод вернет массив сообщений об ошибках. |
|--------------------------------|---------------------------------------------------------------|
| `setIpValidator($ipValidator)` | Позволяет установить собственный валидатор IP-адреса.         |
|--------------------------------|---------------------------------------------------------------|
| `getIpValidator()`             | Извлекает установленный валидатор IP-адреса.                  |
|--------------------------------|---------------------------------------------------------------|
| `setAllow()`                   | Определяет тип(ы) разрешенных имен хостов.                    |
|--------------------------------|---------------------------------------------------------------|
| `getAllow()`                   | Возвращает разрешенные имена хостов.                          |
|--------------------------------|---------------------------------------------------------------|
| `useIdnCheck()`                | Определяет, включена ли проверка интернационализованных доменных имен (Internationalized Domain Names - IDN). По умолчанию эта опция установлена в значение `true`. |
|--------------------------------|---------------------------------------------------------------|
| `getIdnCheck()`                | Возвращает `true`, если включена проверка IDN.                |
|--------------------------------|---------------------------------------------------------------|
| `useTldCheck()`                | Определяет, включена ли проверка доменов верхнего уровня (Top Level Domain - TLD). По умолчанию эта опция установлена в значение `true`. |
|--------------------------------|---------------------------------------------------------------|
| `getTldCheck()`                | Возвращает `true`, если включена проверка TLD.                |
|--------------------------------|---------------------------------------------------------------|

Вы можете определить, какие типы имен хостов разрешены, с помощью метода `setAllow()`. Он
принимает комбинацию следующих констант:

  * `ALLOW_DNS` Разрешает доменные имена (например, *example.com*);
  * `ALLOW_IP`  Разрешает IP-адреса;
  * `ALLOW_LOCAL` Разрешает имена локальных сетей (например, *localhost*, *www.localdomain*);
  * `ALLOW_URI` Разрешает имена хостов URI.
  * `ALLOW_ALL` Разрешает все типы имен хостов.

По умолчанию разрешены только доменные имена.
  
Проверка имени хоста состоит из нескольких этапов, некоторые из которых могут быть пропущены
в зависимости от опций валидатора:
  
1. Если входное значение выглядит как IP-адрес, оно проверяется внутренним валидатором IP-адреса.
   Используемый для этого валидатор IP-адреса можно переопределить методом setIpValidator()`.
 
2. Имя хоста делится на части домена (разделенные точками ".").

3. Домен верхнего уровня (TLD) сверяется с белым списком доступных TLD. (это действие можно
   отключить методом `useTldCheck()`).

4. Каждая часть домена проверяется в соответствии с правилами для допустимых доменных имен.
   Если доменное имя - IDN [^idn], оно сверяется с правилами действительных IDN (проверку IDN
   можно отключить методом `useIdnCheck()`.

[^idn]: Интернационализованное доменное имя (internationalized domain name - IDN) - это доменное 
        имя, которое содержит хотя бы одну метку, полностью или частично составленную из букв
        национальных алфавитов, например, арабского, китайского или русского.		
  
Ниже показан пример кода, демонстрирующий использование валидатора `Hostname`.

{line-numbers=off, lang=php}
~~~
<?php
use Zend\Validator\Hostname;

// Создаем валидатор Hostname.
$validator = new Hostname();

// Настраиваем валидатор.
$validator->setAllow(Hostname::ALLOW_DNS|Hostname::ALLOW_IP);

// Проверяем имя хоста.
$isValid = $validator->isValid('site1.example.com'); 
// Возвращает true.
$isValid2 = $validator->isValid('abc'); 
// Возвращает false (недействительное имя хоста).
~~~

#### Валидатор Uri

Валидатор `Uri` предназначен для проверки того, является ли входное значение
единообразным идентификатором ресурса (Uniform Resource Identifier - URI) [^uri].
При неудачной валидации сообщения об ошибках могут быть извлечены с помощью метода
валидатора `getMessages()`.

I> Пусть вас не смущает термин URI. В большинстве случаев вы можете считать URI обычными URL. 

[^uri]: Единообразный идентификатор ресурса (URI) - это компактная последовательность символов,
        идентифицирующая абстрактный или физический ресурс. Единый указатель ресурса (URL) является
		типом URI. Однако, это не значит, что все URI это URL.

Public-методы, предоставляемые валидатором `Uri`, перечислены в таблице 9.5:

{title="Таблица 9.5. Public-методы валидатора Uri"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор валидатора. Принимает список опций.               |
|--------------------------------|---------------------------------------------------------------|
| `isValid($value)`              | Вовращает `true`, если значение является действительным URI; иначе возвращает `false`. |
|--------------------------------|---------------------------------------------------------------|
| `getMessages()`                | При неудачной валидации этот метод вернет массив сообщений об ошибках. |
|--------------------------------|---------------------------------------------------------------|
| `setUriHandler($uriHandler)`   | Задает объект обработчика URI для этого валидатора.           |
|--------------------------------|---------------------------------------------------------------|
| `getUriHandler()`              | Извлекает объект обработчика URI.                             |
|--------------------------------|---------------------------------------------------------------|
| `setAllowAbsolute($allowAbsolute)`| Сообщает валидатору, допускаются ли абсолютные URI.        |
|--------------------------------|---------------------------------------------------------------| 
| `getAllowAbsolute()`           | Возвращает `true` если допускаются абсолютные URI.            |
|--------------------------------|---------------------------------------------------------------| 
| `setAllowRelative($allowRelative)`| Сообщает валидатору, допускаются ли относительные URI.     |
|--------------------------------|---------------------------------------------------------------|
| `getAllowRelative()`           |  Возвращает `true` если допускаются относительные URI.        |
|--------------------------------|---------------------------------------------------------------|

Валидатор `Uri` внутренне использует так называемый *объект обработчика URI*, ответственный
за разбор строки URI. По умолчанию в качестве обработчика URI используется класс `Zend\Uri\Uri`
(если хотите, можете установить свой собственный обработчик URI с помощью метода `setUriHandler()`).

URI может быть абсолютным (например,"http://example.com/blog/2014/02/02/edit") или относительным
(например, "2014/02/02/edit"). Вы можете указать, должен ли валидатор считать абсолютные и/или
относительные URI допустимыми. Для этого используйте соответственно методы `setAllowAbsolute()` и 
`setAllowRelative()`. По умолчанию, оба типа URI считаются допустимыми.

Ниже показан пример кода, демонстрирующий использование валидатора `Uri`.

{line-numbers=off, lang=php}
~~~
<?php
use Zend\Validator\Uri;

// Создаем валидатор Uri.
$validator = new Uri();

// Настраиваем валидатор.
$validator->setAllowAbsolute(true);
$validator->setAllowRelative(true);

// Проверяем URI.
$isValid = $validator->isValid('http://site1.example.com/application/index/index'); 
// Возвращает true.
$isValid2 = $validator->isValid('index/index'); 
// Возвращает true.
~~~

#### Валидатор Date
 
Валидатор `Date` предназначен для проверки того, являются ли входные данные датой
в заданном формате.

При неудачной валидации сообщения об ошибках могут быть извлечены с помощью метода
валидатора `getMessages()`.
 
Public-методы, предоставляемые валидатором `Date`, перечислены в таблице 9.6:

{title="Таблица 9.6. Public-методы валидатора Date"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор валидатора. Принимает список опций.               |
|--------------------------------|---------------------------------------------------------------|
| `isValid($value)`              | Вовращает `true`, если значение является строкой, содержащей дату в ожидаемом формате; иначе возвращает `false`. |
|--------------------------------|---------------------------------------------------------------|
| `getMessages()`                | При неудачной валидации этот метод вернет массив сообщений об ошибках. |
|--------------------------------|---------------------------------------------------------------|
| `setFormat($format)`           | Задает ожидаемый формат даты.                                 |
|--------------------------------|---------------------------------------------------------------|
| `getFormat()`                  | Извлекает ожидаемый формат.                                   |
|--------------------------------|---------------------------------------------------------------|

Для установки ожидаемого формата даты используйте метод `setFormat()`.

I> Фильтр `DateTimeFormatter` внутренне использует класс `DateTime` из стандартной библиотеки PHP для
I> преобразования и форматирования дат. Доступные форматы данных вы можете посмотреть в документации PHP для класса `DateTime`.
 
Ниже показан пример кода, демонстрирующий использование валидатора `Date`.
 
{line-numbers=off, lang=php}
~~~
<?php
use Zend\Validator\Date;

// Создаем экземпляр валидатора.
$validator = new Date();

// Настраиваем валидатор.
$validator->setFormat('Y-m-d');

// Проверяем, является ли входное значение датой в ожидаемом формате.
$isValid = $validator->isValid('2014-04-04'); // Возвращает true.
$isValid2 = $validator->isValid('April 04, 2014'); // Возвращает false (непредвиденный формат).
~~~

#### Валидатор Regex

Этот валидатор позволяет проверить, соответствует ли заданная строка какому-либо регулярному
выражению. Он возвращает `true`, если строка совпадает с регулярным выражением, иначе возвращается
`false`. При неудачной валидации сообщения об ошибках могут быть извлечены с помощью метода
валидатора `getMessages()`.

Public-методы, предоставляемые валидатором `Regex`, перечислены в таблице 9.7:

{title="Таблица 9.7. Public-методы валидатора Regex"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор валидатора. Принимает список опций.               |
|--------------------------------|---------------------------------------------------------------|
| `isValid($value)`              | Возвращает true тогда и только тогда, когда `$value` совпадает с заданным шаблоном регулярного выражения. |
|--------------------------------|---------------------------------------------------------------|
| `getMessages()`                | При неудачной валидации этот метод вернет массив сообщений об ошибках. |
|--------------------------------|---------------------------------------------------------------|
| `setPattern($pattern)`         | Задает шаблон регулярного выражения.                          |
|--------------------------------|---------------------------------------------------------------|
| `getPattern()`                 | Извлекает шаблон регулярного выражения.                       |
|--------------------------------|---------------------------------------------------------------|

Метод `setPattern()` позволяет задать регулярное выражение для проверки соответствия.

T> Синтаксис и примеры регулярных выражений можно посмотреть в разделе *Шаблоны PCRE* 
T> документации PHP.

Ниже показан пример кода, демонстрирующий использование валидатора `Regex`. Здесь мы
используем регулярное выражение для проверки того, является ли входная строка действительным
IPv4-адресом (такой адрес, как правило, состоит из четырех групп цифр, разделенных точками).

{line-numbers=off, lang=php}
~~~
<?php
use Zend\Validator\Regex;

// Создаем валидатор Regex.
$validator = new Regex();

// Задаем регулярного выражения для проверки IP-адреса.
$validator->setPattern('\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b');

// Проверка на соответствие регулярному выражению.
$isValid = $validator->isValid("127.0.0.1"); // возвращает true.
$isValid2 = $validator->isValid("123"); // возвращает false.
~~~

### Валидаторы для проверки того, что числовое значение лежит в заданном диапазоне

В этом разделе мы рассмотрим примеры использования валидаторов, связанных
с проверкой того, находится ли числовое значение в определенном диапазоне.

#### Валидатор NotEmpty

Валидатор NotEmpty позволяет проверить, что входное значение не пустое. Это часто
бывает полезным при работе с элементами форм или другими введенными пользователями
данными, где вы можете использовать такой валидатор, чтобы гарантировать, что необходимые
элементы содержат связанные с ними значения.

Public-методы, предоставляемые валидатором `NotEmpty`, перечислены в таблице 9.8:

{title="Таблица 9.8. Public-методы валидатора NotEmpty"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор валидатора. Принимает список опций.               |
|--------------------------------|---------------------------------------------------------------|
| `isValid($value)`              | Возвращает true тогда и только тогда, когда `$value` - не пустое значение. |
|--------------------------------|---------------------------------------------------------------|
| `getMessages()`                | При неудачной валидации этот метод вернет массив сообщений об ошибках. |
|--------------------------------|---------------------------------------------------------------|
| `setType($type)`               | Задает типы значений, которые будут считаться пустыми.        |
|--------------------------------|---------------------------------------------------------------|
| `getType()`                    | Возвращает типы.                                              |
|--------------------------------|---------------------------------------------------------------|
| `getDefaultType()`             | Возвращает типы по умолчанию.                                 |
|--------------------------------|---------------------------------------------------------------|

Метод `setType()` указывает, какие типы переменных считать пустыми значениями. Этот метод принимает
один аргумент `$type`, который может быть либо комбинацией ИЛИ констант, перечисленных в таблице 9.9,
либо массивом, содержащим буквенные эквиваленты этих констант.


{title="Таблица 9.9. Константы типов"}
|----------------------|--------------------|----------------------|----------------------------------------|
| *Константа*          | *Числовое значение* | Буквенный эквивалент* | *Описание*                           |
|----------------------|--------------------|----------------------|----------------------------------------|
| `BOOLEAN`            | 1                  | "boolean"            | Считает булевое `false` пустым значением. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `INTEGER`            | 2                  | "integer"            | Считает integer-значение 0 пустым значением. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `FLOAT`              | 4                  | "float"              | Считает float-значение 0.0 пустым значением. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `STRING`             | 8                  | "string"             | Считает пустую строку '' пустым значением. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `ZERO`               | 16                 | "zero"               | Считает строку, содержащую один символ нуля ('0') пустым значением. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `EMPTY_ARRAY`        | 32                 | "array"              | Считает пустой массив пустым значением. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `NULL`               | 64                 | "null"               | Считает `null` пустым значением.       |
|----------------------|--------------------|----------------------|----------------------------------------|
| `PHP`                | 127                | "php"                | Считает значение пустым, если PHP-функция `empty()` вернет для него `true`. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `SPACE`              | 128                | "space"              | Считает строку, содержащую только пробелы, пустым значением. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `OBJECT`             | 256                | "object"             | Возвращает `true`. `false` возвращается, когда переданный объект не допустим. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `OBJECT_STRING`      | 512                | "objectstring"       | Возвращает `false`, когда метод `__toString()` переданного объекта возвращает пустую строку. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `OBJECT_COUNT`       | 1024               | "objectcount"        | Возвращает `false`, если переданный объект реализует интерфейс `Countable`, и его счетчик равен 0. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `ALL`                | 2047               | "all"                | Считает все вышеперечисленные типы пустыми значениями. |
|----------------------|--------------------|----------------------|----------------------------------------|

Ниже показан пример кода, демонстрирующий использование валидатора `NotEmpty`.

{line-numbers=off, lang=php}
~~~
<?php
use Zend\Validator\NotEmpty;

// Создаем экземпляр валидатора.
$validator = new NotEmpty();

// Настраиваем валидатор.
$validator->setType(NotEmpty::ALL);

// Проверяем, не является ли входное значение пустым.
$isValid1 = $validator->isValid('some string'); // возвращает true
$isValid2 = $validator->isValid(''); // возвращает false 
$isValid3 = $validator->isValid(0); // возвращает false
~~~

#### Валидатор Between

Валидатор `Between` проверяет, находится ли число в определенном диапазоне (min, max), либо
включительно (по умолчанию), либо исключительно.

Public-методы, предоставляемые валидатором `Between`, перечислены в таблице 9.10:

{title="Таблица 9.10. Public-методы валидатора Between"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор валидатора. Принимает список опций.               |
|--------------------------------|---------------------------------------------------------------|
| `isValid($value)`              | Возвращает true тогда и только тогда, когда значение лежит в заданном диапазоне. |
|--------------------------------|---------------------------------------------------------------|
| `getMessages()`                | При неудачной валидации этот метод вернет массив сообщений об ошибках. |
|--------------------------------|---------------------------------------------------------------|
| `setMin($min)`                 | Задает нижнюю границу.                                        |
|--------------------------------|---------------------------------------------------------------|
| `getMin()`                     | Извлекает нижнюю границу.                                     |
|--------------------------------|---------------------------------------------------------------|
| `setMax($max)`                 | Задает верхнюю границу.                                       |
|--------------------------------|---------------------------------------------------------------|
| `getMax()`                     | Извлекает верхнюю границу.                                    |
|--------------------------------|---------------------------------------------------------------|
| `setInclusive($inclusive)`     | Определяет, проверять ли нахождение значения в заданном диапазоне включительно. |
|--------------------------------|---------------------------------------------------------------|
| `getInclusive()`               | Возвращает опцию проверки включительно.                       |
|--------------------------------|---------------------------------------------------------------|

Диапазон может быть задан с помощью методов `setMin()` и `setMax()`. 

По умолчанию, валидатор осуществляет сравнения включительно (чтобы проверить, принадлежит ли значение заданному диапазону, он
сравнивает, значение больше или равно нижней границы или нет; и меньше или равно верхней границы или нет). Эту опцию можно изменить
с помощью метода `setInclusive()`. Он сообщает валидатору, какое выполнять сравнение: включительно (для этого нужно передать аргумент
`true`) или исключительно (аргумент `false`).

Ниже показан пример кода, демонстрирующий использование валидатора `Between`.

{line-numbers=off, lang=php}
~~~
<?php
use Zend\Validator\Between;

// Создаем экземпляр валидатора.
$validator = new Between();

// Настраиваем валидатор.
$validator->setMin(1);
$validator->setMax(10);
$validator->setInclusive(true);

$isValid1 = $validator->isValid(5); // возвращает true.
$isValid2 = $validator->isValid(10); // возвращает true.
$isValid3 = $validator->isValid(0); // возвращает false (значение слишком мало).
$isValid4 = $validator->isValid(15); // возвращает false (значение слишком велико).
~~~

#### Валидатор InArray

Валидатор `InArray` проверяет, принадлежит ли входное значение заданному массиву значений.
Public-методы, предоставляемые валидатором `InArray`, перечислены в таблице 9.11:

{title="Таблица 9.11. Public-методы валидатора InArray"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор валидатора. Принимает список опций.               |
|--------------------------------|---------------------------------------------------------------|
| `isValid($value)`              | Возвращает true тогда и только тогда, когда значение принадлежит заданному массиву. |
|--------------------------------|---------------------------------------------------------------|
| `getMessages()`                | При неудачной валидации этот метод вернет массив сообщений об ошибках. |
|--------------------------------|---------------------------------------------------------------|
| `setHaystack($haystack)`       | Задает массив, где будем искать значение.                     |
|--------------------------------|---------------------------------------------------------------|
| `getHaystack()`                | Возвращает массив допустимых значений.                        |
|--------------------------------|---------------------------------------------------------------|
| `setStrict($strict)`           | Устанавливает режим строгой проверки.                         |
|--------------------------------|---------------------------------------------------------------|
| `getStrict()`                  | Включен ли режим строгой проверки?                            |
|--------------------------------|---------------------------------------------------------------|
| `setRecursive($recursive)`     | Указывает валидатору осуществлять рекурсивный поиск.          |
|--------------------------------|---------------------------------------------------------------|
| `getRecursive()`               | Включен ли рекурсивный поиск?                                 |
|--------------------------------|---------------------------------------------------------------|

Метод `setHaystack()` позволяет задать массив допустимых значений. Метод isValid()` будет искать
в этом массиве входную переменную `$value`.

Если массив содержит вложенные значения, и вы хотите провести среди них рекурсивный поиск, используйте
метод `setRecursive()`. Этот метод принимает один единственный булевый флаг. Если флаг установлен в 
`true`, поиск будет осуществляться рекурсивно; иначе вложенные уровни будут проигнорированы.

Метод `setStrict()` предоставляет возможность указать валидатору, каким образом будут сравниваться
входное значение и значения в массиве. Он принимает комбинацию следующих констант:

  * `COMPARE_NOT_STRICT` Не осуществлять строгую проверку типа переменной.
  * `COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILITY` Не осуществлять строгую проверку 
     типа переменной, но не допускать ложноположительных сравнений строки с integer-значением (например, `"asdf" == 0`). 
	 Это опция по умолчанию. 
  * `COMPARE_STRICT` Проверять и тип переменной, и значение.

Ниже показан пример кода, демонстрирующий использование валидатора `InArray`.

{line-numbers=off, lang=php}
~~~
<?php
use Zend\Validator\InArray;

// Создаем экземпляр валидатора.
$validator = new InArray();

// Настраиваем валидатор.
$validator->setHaystack([1, 3, 5]);

// Perform validation.
$isValid1 = $validator->isValid(1); // возвращает true.
$isValid2 = $validator->isValid(2); // возвращает false.
~~~

#### Валидатор StringLength

Валидатор `StringLength`, принадлежит ли длина входной строки заданному диапазону (включительно).
Он возвращает `true` тогда и только тогда, когда длина строки значения как минимум равна опции `min`
и не больше опции `max` (если опция `max` не нулевая).

Public-методы, предоставляемые валидатором `StringLength`, перечислены в таблице 9.12:

{title="Таблица 9.12. Public-методы валидатора StringLength"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор валидатора. Принимает список опций.               |
|--------------------------------|---------------------------------------------------------------|
| `isValid($value)`              | Возвращает true тогда и только тогда, когда длина значения лежит в заданном диапазоне. |
|--------------------------------|---------------------------------------------------------------|
| `getMessages()`                | При неудачной валидации этот метод вернет массив сообщений об ошибках. |
|--------------------------------|---------------------------------------------------------------|
| `setMin($min)`                 | Задает нижнюю границу.                                        |
|--------------------------------|---------------------------------------------------------------|
| `getMin()`                     | Извлекает нижнюю границу.                                     |
|--------------------------------|---------------------------------------------------------------|
| `setMax($max)`                 | Задает верхнюю границу.                                       |
|--------------------------------|---------------------------------------------------------------|
| `getMax()`                     | Извлекает верхнюю границу.                                    |
|--------------------------------|---------------------------------------------------------------|
| `setEncoding($encoding)`       | Устанавливает для использования новую кодировку.              |
|--------------------------------|---------------------------------------------------------------|
| `getEncoding()`                | Извлекает кодировку.                                          |
|--------------------------------|---------------------------------------------------------------|

По умолчанию, валидатор `StringLength` считает действительной любую длину строки.
Используйте методы `setMin()` и/или `setMax()`, чтобы задать нижнюю и верхнюю границу для
допустимой длины. Существует три возможных способа это сделать:

  * Используя только метод `setMin()`, чтобы разрешить строки с заданной нижней границей и
    без верхней границы;
  * Используя только метод `setMax()`, чтобы разрешить строки с нижней границей равной 0 и
    заданной верхней границей;
  * Используя оба метода, чтобы разрешить строки с длиной, лежащей в заданном диапазоне.

По умолчанию, PHP-движок использует для строк кодировку UTF-8. Если входная строка 
использует другую кодировку, эту кодировку следует указать с помощью метода валидатора `setEncoding()`.

Ниже показан пример кода, демонстрирующий использование валидатора `StringLength`.

{line-numbers=off, lang=php}
~~~
<?php
use Zend\Validator\StringLength;

// Создаем экземпляр валидатора.
$validator = new StringLength();

// Настраиваем валидатор.
$validator->setMin(1);
$validator->setMax(10);

$isValid1 = $validator->isValid("string"); // возвращает true.
$isValid2 = $validator->isValid(""); // возвращает false (слишком короткое значение).
$isValid3 = $validator->isValid("a very long string"); // возвращает false (слишком длинное значение).
~~~

### Организация валидаторов в цепь

Валидаторы могут быть организованы в последовательность. Это делается с помощью класса `ValidatorChain`.
При запуске подобного составного валидатора,  входное значение по очереди передается всем валидатором.
Метод `isValid()` валидатора `ValidatorChain` возвращает `true`, если все валидаторы в цепочке возвращают
`true`; иначе он возвращает `false`.

I> Класс `ValidatorChain` внутренне используется классом-контейнером `InputFilter` для хранения
I> последовательности валидаторов, присоединенных к полю модели формы.

Public-методы, предоставляемые валидатором `ValidatorChain`, перечислены в таблице 9.12:

{title="Таблица 9.13. Public-методы валидатора ValidatorChain"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `isValid($value)`              | Возвращает `true`, если все валидаторы в цепи возвращают `true`. |
|--------------------------------|---------------------------------------------------------------|
| `getMessages()`                | Возвращает массив сообщений об ошибках валидации.             |
|--------------------------------|---------------------------------------------------------------|
| `getValidators()`              | Возвращает массив валидаторов в цепи.                         |
|--------------------------------|---------------------------------------------------------------|
| `count()`                      | Возвращает количество валидаторов в цепи.                       |
|--------------------------------|---------------------------------------------------------------|
| `attach($validator, $breakChainOnFailure)` | Добавляет валидатор в конец цепи.                 |
|--------------------------------|---------------------------------------------------------------|
| `prependValidator($validator, $breakChainOnFailure)` | Добавляет валидатор в начало цепи.      |
|--------------------------------|---------------------------------------------------------------|
| `attachByName($name, $options, $breakChainOnFailure)` | Использует менеджер плагинов, чтобы добавить валидатор в конец по имени. |
|--------------------------------|---------------------------------------------------------------|
| `prependByName($name, $options, $breakChainOnFailure)` | Использует менеджер плагинов, чтобы добавить валидатор в начало по имени. |
|--------------------------------|---------------------------------------------------------------|
| `merge($validatorChain)`       | Объединяет цепь валидаторов с цепью, переданной в качестве параметра. |
|--------------------------------|---------------------------------------------------------------|

Пример цепочки валидаторов показан на рисунке 9.2. Эта цепь состоит из валидатора `NotEmpty`, за которым
следует валидатор `StringLength`, за которым в свою очередь следует валидатор `Date`. При выполнении этой
цепи первым делом запускается валидатор `NotEmpty`, проверяющий, что значение не является пустым, затем
`StringLength, проверяющий, что длина входной строки принадлежит диапазону (1,16) включительно, и наконец
валидатор `Date`, проверяющий, что входное значение является датой в формате "ГГГГ-ММ-ДД".

![Рисунок 9.2. Цепь валидаторов](../en/images/validators/validator_chain.png)

Для создания цепочки валидаторов, как на рисунке 9.2, используем следующий код:

{line-numbers=off, lang=php}
~~~
<?php
// Инстанцируем цепь валидаторов.
$validator = new \Zend\Validator\ValidatorChain();

// Добавляем валидаторы в цепочку.
$validator->attachByName('NotEmpty');
$validator->attachByName('StringLength', ['min'=>1, 'max'=>16]);
$validator->attachByName('Date', ['format'=>'Y-m-d']);

// Выполняем все валидаторы в цепи.
$isValid = $validator->isValid('2014-04-04'); // Возвращает true.
~~~

### Пользовательская валидация с помощью валидатора Callback

Валидатор `Callback` может быть оберткой для вашего собственного алгоритма валидации. Это может
быть полезно, например, когда стандартные валидаторы не подходят, и вам нужно применить к данным
свой алгоритм проверки. Public-методы, предоставляемые валидатором `Callback` перечислены в таблице 9.14.

{title="Таблица 9.14. Public-методы валидатора Callback"}
|--------------------------------|---------------------------------------------------------------|
| *Class name*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `isValid($value, $context)`    | Выполняет функцию обратного вызова в качестве валидатора.     |
|--------------------------------|---------------------------------------------------------------|
| `getMessages()`                | При неудачной валидации этот метод вернет массив сообщений об ошибках. |
|--------------------------------|---------------------------------------------------------------|
| `setCallback($callback)`       | Устанавливает новый механизм обратного вызова.                |
|--------------------------------|---------------------------------------------------------------|
| `getCallback()`                | Возвращает установленный механизм обратного вызова.           |
|--------------------------------|---------------------------------------------------------------|
| `setCallbackOptions($options)` | Задает параметры для механизма обратного вызова.              |
|--------------------------------|---------------------------------------------------------------|
| `getCallbackOptions()`         | Получает параметры механизма обратного вызова.                |
|--------------------------------|---------------------------------------------------------------|

Как видите из таблицы, валидатор `Callback` предоставляет методы `setCallback()` и `setCallbackOptions()`,
используемые для задания функции (или метода класса) обратного вызова и (опционально) передачи ей одного
или нескольких параметров.

#### Пример

Чтобы продемонстрировать использование метода `Callback`, добавим валидатор телефонного номера к нашему
классу модели формы `ContactForm`. Этот валидатор будет проверять номер телефона, вводимый посетителем
сайта.

Валидатор должен делать проверку на два общепринятых формата телефонных номеров:

  * международный формат вида "1 (234) 567-8901";
  * и локальный формат вида "567-8901".

Так как ZF3 не предоставляет стандартного валидатора для осуществления подобной операции фильтрации номера,
мы будем использовать валидатор-обертку `Callback`. Для этого внесем следующие изменения в код нашего
класса `ContactForm`:

{line-numbers=on, lang=php}
~~~
<?php
// ...
class ContactForm extends Form
{    
  // ..
  protected function addElements() {
    // ...
	
    // Добавляем поле "phone"
    $this->add([
        'type'  => 'text',
        'name' => 'phone',
        'attributes' => [                
          'id' => 'phone'
        ],
        'options' => [
          'label' => 'Your Phone',
        ],
      ]);
  }
    
  private function addInputFilter() 
  {
    // ...
        
    $inputFilter->add([
            'name'     => 'phone',
            'required' => true,                
            'validators' => [
                [
                  'name' => 'Callback',
                  'options' => [
                     'callback' => [$this, 'validatePhone'],
                     'callbackOptions' => [
                     'format' => 'intl'
                  ]
                ]                        
              ]                    
            ]
        );
  }
        
  // Пользовательский валидатор для телефонного номера.
  public function validatePhone($value, $context, $format) 
  {
    // Определяем корректную длину и шаблон телефонного номера 
    // в зависимости от формата.
    if($format == 'intl') {
      $correctLength = 16;
      $pattern = '/^\d\ (\d{3}\) \d{3}-\d{4}$/';
    } else { // 'local'
      $correctLength = 8;
      $pattern = '/^\d{3}-\d{4}$/';
    }
                
    // Проверяем длину номера.
    if(strlen($value)!=$correctLength)
      return false;

    // Проверяем, соответствует ли значение шаблону.
    $matchCount = preg_match($pattern, $value);
        
    return ($matchCount!=0)?true:false;
  }
}
~~~

Во фрагменте выше мы создаем поле `phone` в нашей форме обратной связи `ContactForm`
(пропустите, если у вас уже есть такое поле).

В строках 26-40 мы добавляем в цепь валидаторов фильтра входных данных 
валидатор `Callback` для поля "phone".

В строках 44-64 находится метод обратного вызова `validatePhone()`. Этот метод принимает
три аргумента: параметр `$value` - телефонный номер, который нужно валидировать, параметр `$context`,
принимающий значения каждого поля формы (некоторым валидаторам нужно также обращаться к значениям других полей формы);
и параметр `$format` - ожидаемый формат телефонного номера ("intl" или "local").

Внутри метода обратного вызова мы делаем следующее:

 1. Вычисляем корректную длину телефонного номера, проверяем, корректна ли длина для
    выбранного формата номера.
 2. Сопоставляем номер телефона с шаблоном регулярного выражения для выбранного формата номера.

## Написание своего валидатора

Альтернативой использованию валидатора `Callback` является написание своего собственного
класса валидатора, реализующего интерфейс `ValidatorInterface`. Этот валидатор затем может
быть использован в формах вашего веб-приложения.

Чтобы продемонстрировать создание своего валидатора, мы напишем класс `PhoneValidator`,
инкапсулирующий алгоритм валидации номера, который мы использовали в предыдущем примере.

I> Как вы возможно помните, базовым классом для всех стандартных валидаторов является класс `AbstractValidator`.
I> По аналогии мы также будем наследовать наш валидатор `PhoneValidator` от этого базового класса.

Мы планируем иметь следующие методы в классе валидатора `PhoneValidator` (см. таблицу 9.15):

{title="Таблица 9.15. Public-методы валидатора Callback"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор - принимает опциональный аргумент `$options`, который нужен для того, чтобы сразу задать опции валидатора. |
|--------------------------------|---------------------------------------------------------------|
| `setFormat($format)`           | Задает опцию формата номера.                                |
|--------------------------------|---------------------------------------------------------------|
| `getFormat()`                  | Возвращает опцию формата номера.                               |
|--------------------------------|---------------------------------------------------------------|
| `isValid($value)`              | Возвращает `true`, если значение - действительный телефонный номер; иначе возвращает `false`. |
|--------------------------------|---------------------------------------------------------------|
| `getMessages()`                | При неудачной валидации этот метод вернет массив сообщений об ошибках. |
|--------------------------------|---------------------------------------------------------------|

Для `PhoneValidator` у нас будет три возможных сообщения об ошибках:

  * Если валидатору передается нескалярное значение, он сгенерирует сообщение
    "Номер телефона должен быть скалярным значением";  
  * Если выбран международный формат, и введенный номер не соответствует этому формату, валидатор
    сгенерирует сообщение "Номер телефона должен быть в международном формате"
  * Если выбран локальный формат, и введенный номер не соответствует этому формату, валидатор
    сгенерирует сообщение "Номер телефона должен быть в локальном формате".

Сперва создайте файл *PhoneValidator.php* в каталоге *Validator* под 
корневым каталогом модуля [^сервис_валидатора_номера]. Поместите в этот файл
следующий код:

[^сервис_валидатора_номера]: Класс `PhoneValidator` можно считать моделью сервиса, так как его задачей является
       обработка данных, а не их хранение. Все пользовательские валидаторы принято хранить под каталогом `Validator`.

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Validator;

use Zend\Validator\AbstractValidator;

// Этот класс валидатора предназначен для проверки телефонного номера на
// соответствие локальному или международному формату.
class PhoneValidator extends AbstractValidator 
{
  // Константы формата номера.
  const PHONE_FORMAT_LOCAL = 'local'; // Локальный формат номера.
  const PHONE_FORMAT_INTL  = 'intl';  // Международный формат номера.
    
  // Доступные опции валидатора.
  protected $options = [
    'format' => self::PHONE_FORMAT_INTL
  ];
    
  // ID сообщений об ошибках валидации.
  const NOT_SCALAR  = 'notScalar';
  const INVALID_FORMAT_INTL  = 'invalidFormatIntl';
  const INVALID_FORMAT_LOCAL = 'invalidFormatLocal';
    
  // Сообщения об ошибках валидации.
  protected $messageTemplates = [
    self::NOT_SCALAR  => "Номер телефона должен быть скалярным значением",
    self::INVALID_FORMAT_INTL => "Номер телефона должен быть в международном формате",
    self::INVALID_FORMAT_LOCAL => "Номер телефона должен быть в локальном формате",
  ];
    
  // Конструктор.
  public function __construct($options = null) 
  {
    // Задаем опции валидатора (если они предоставлены).
    if(is_array($options)) {
            
      if(isset($options['format']))
        $this->setFormat($options['format']);
      }
        
      // Вызываем конструктор родительского класса.
      parent::__construct($options);
  }
    
  // Задаем формат номера.
  public function setFormat($format) 
  {
    // Проверяем входной аргумент.
    if($format!=self::PHONE_FORMAT_LOCAL && 
       $format!=self::PHONE_FORMAT_INTL) {            
      throw new \Exception('Invalid format argument passed.');
    }
        
    $this->options['format'] = $format;
  }
    
  // Валидируем номер телефона.
  public function isValid($value) 
  {
    if(!is_scalar($value)) {
      $this->error(self::NOT_SCALAR);
      return $false; // Номер должен быть скалярной величиной.
    }
            
    // Преобразуем значение в строку.
    $value = (string)$value;
        
    $format = $this->options['format'];
    
    // Определяем корректную длину и шаблон телефонного номера
    // в зависимости от формата.            
    if($format == self::PHONE_FORMAT_INTL) {
      $correctLength = 16;
      $pattern = '/^\d \(\d{3}\) \d{3}-\d{4}$/';
    } else { // self::PHONE_FORMAT_LOCAL
      $correctLength = 8;
      $pattern = '/^\d{3}-\d{4}$/';
    }
        
    // Сперва проверяем длину телефонного номера
    $isValid = false;
    if(strlen($value)==$correctLength) {            
      // Проверяем, соответствует ли значение шаблону
      if(preg_match($pattern, $value))                    
        $isValid = true;
    }
       
    // Если была ошибка, задаем сообщение об ошибке
    if(!$isValid) {            
      if($format==self::PHONE_FORMAT_INTL)
        $this->error(self::INVALID_FORMAT_INTL);
      else
        $this->error(self::INVALID_FORMAT_LOCAL);
    }
        
    // Возвращаем результат валидации.
    return $isValid;
  }
}
~~~

Как видите из строки 2, класс валидатора содержится в пространстве имен `Application\Validator`.

В строке 8 мы определяем класс `PhoneValidator`. Мы наследуем наш валидатор от базового класса
`AbstractValidator` для повторного использования предоставляемой им функциональности. Строка 4
содержит псевдоним для класса `AbstractValidator`.

В строках 11-12 мы для удобства определяем константы форматов номера (`PHONE_FORMAT_INTL` для 
международного формата и `PHONE_FORMAT_LOCAL` для локального). Эти константы - эквиваленты
строк "intl" и "local" соответственно.

В строках 15-17 мы определяем private-переменную `$options`, которая является массивом, имеющим
один единственный ключ под названием "format". Этот ключ будет содержать опцию формата номера для
нашего валидатора.

В строках 20-22 мы определяем идентификаторы сообщений об ошибках. В нашем случае идентификаторов три
(`NOT_SCALAR`, `INVALID_FORMAT_INTL` и `INVALID_FORMAT_LOCAL`), так как наш валидатор может генерировать
три разных сообщения об ошибках. Эти идентификаторы предназначены для распознавания различных сообщений
машиной, а не человеком.

В строках 25-29 находится переменная массива, которая содержит соответствия между идентификаторами
сообщений об ошибках и их текстовыми представлениями. Текстовые сообщения предназначены для показа
человеку.

В строках 32-43 находится метод конструктора, который принимает один аргумент `$options`.
При создании валидатора вручную, этот параметр можно пропустить. Однако, когда валидатор создается
классом фабрики, фабрика будет передавать опции валидатора его конструктору через этот аргумент.

В строках 46-55 находится метод  `setFormat()`, позволяющий задать текущий формат номера.

Строки 58-98 содержат метод `isValid()`. Этот метод инкапсулирует алгоритм проверки телефонного 
номера. Он принимает параметр `$value`, осуществляет сопоставление с регулярным выражением и
возвращает `true` при удачном исходе.

В случае неудачной валидации метод `isValid()` возвращает булевое `false`, а список ошибок можно
извлечь методом `getMessages()`.

I> Вы могли заметить, что мы не определили метод `getMessages()` в нашем классе `PhoneValidator`.
I> Это потому, что мы наследовали этот метод от базового класса `AbstractValidator`. Внутри метода 
I> `isValid()`, для генерации сообщений об ошибках, мы также использовали предоставляемый базовым
I> классом protected-метод `error()` (строки 61, 91, 93).

### Использование класса PhoneValidator

Как только класс валидатора `PhoneValidator` будет готов, вы легко можете начать его использовать в
форме обратной связи (или других формам) как показано ниже. Предполагается, что вы вызываете
следующий код внутри метода `ContactForm::addInputFilter()`:

{line-numbers=off, lang=php}
~~~
$inputFilter->add([
      'name'     => 'phone',
      'required' => true,                
      'validators' => [
        [
          [
            'name' => PhoneValidator::class,
            'options' => [
              'format' => PhoneValidator::PHONE_FORMAT_INTL
            ]                        
          ],
        ],
        // ...
      ],                
      // ...
    ]);
~~~

Вы можете посмотреть, как работает валидатор `PhoneValidator` в примере *Form Demo* - приложении, которое идет
вместе с этой книгой. Откройте страницу "http://localhost/contactus" в своем браузере. Если вы введете
какой-либо телефонный номер в некорректном формате, валидатор отобразит ошибку (см. рисунок 9.3).

![Рисунок 9.3. Ошибка валидации телефонного номера](../en/images/validators/phone_number_validation_error.png)

Если хотите, можете использовать `PhoneValidator` вне форм, как показано во фрагменте кода ниже:

{line-numbers=off, lang=php}
~~~
<?php 
use Application\Validator\PhoneValidator;

// Создаем валидатор PhoneValidator
$validator = new PhoneValidator();

// Настраиваем валидатор.
$validator->setFormat(PhoneValidator::PHONE_FORMAT_INTL);

// Валидируем номер телефона
$isValid = $validator->isValid('1 (234) 567-8901'); // Возвращает true.
$isValid2 = $validator->isValid('12345678901'); // Возвращает false.

if(!$isValid2) {
  // Получаем ошибки валидации.
  $errors = $validator->getMessages();
}
~~~

## Использование фильтров и валидаторов вне форм

В этом разделе мы приведем пример того, как можно использовать фильтры и/или валидаторы
в контроллере для преобразования и проверки данных, извлеченных из переменных GET и/или POST.

Предположим, мы реализуем систему платежного шлюза, и нам нужно создать веб-страницу,
отображающую историю платежей с заданной кредитной карты для заданной даты. Эта страница
может обрабатываться действием `paymentHistoryAction()` класса контроллера, а номер 
кредитной карты и дата будут извлечены из GET-переменных. Для метода `paymentHistoryAction()`
нам нужно реализовать несколько проверок безопасности:

 * мы хотим гарантировать, что номер карты выглядит как типичный номер кредитки: "4532-7103-4122-1359"
  (соответствует стандарту ISO/IEC 7812);
 * и что дата в формате 'ГГГГ-ММ-ДД'.

Ниже приведен код метода действия:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;
use Zend\Filter\StaticFilter;
use Zend\Validator\StaticValidator;

class IndexController extends AbstractActionController 
{
  // Действие, показывающие историю операций по кредитной
  // карте на определенную дату.
  public function paymentHistoryAction() 
  {
    // Получаем параметры от GET.
    $cardNumber = (string)$this->params()->fromQuery('card', '');
    $date = (string)$this->params()->fromQuery('date', date("Y-m-d"));

    // Валидируем номер кредитной карты.
    $isCardNumberValid = StaticValidator::execute($cardNumber, 'CreditCard');
    if(!$isCardNumberValid) {
      throw new \Exception('Not a credit card number.');
    }
  
    // Конвертируем дату в правильный формат.
    $date = StaticFilter::execute($date, 'DateTimeFormatter', 
	                              ['format'=>'Y-m-d']);  
  
    // Остальной код действия...  
	
	return new ViewModel();
  }
}
~~~

Внутри метода действия мы используем плагин контроллера `params()` (строки 16-17), чтобы
извлечь две переменные из суперглобального массива `$_GET`: переменную `card` (номер кредитной
карты) и переменную `date` (дату).

В строке 20 мы валидируем номер кредитной карты с помощью валидатора `CreditCard`.
Если номер карты недопустим, мы выбрасываем исключение, указывающее на ошибку (строка 22).

В строке 26 мы используем фильтр DateTimeFormatter` для конвертации даты в правильный формат.

## Выводы

Валидаторы предназначены для приема входных данных, проверки их на корректность и возврата булевого
результата, сообщающего, корректны ли данные (и сообщений об ошибках, если таковые имеются).

В Zend Framework 3 существует несколько групп стандартных валидаторов:

 * валидаторы для проверки соответствия значения определенному формату;
 * валидаторы для проверки того, что числовое значение лежит в заданном диапазоне;
 * валидаторы, выступающие "заместителями" (proxies) для других валидаторов.

Для некоторых задач стандартные валидаторы не подходят, и вам нужно применить свой
алгоритм проверки к входным данным. В этом случае вы можете использовать
либо валидатор `Callback`, либо написать собственный класс валидатора.
