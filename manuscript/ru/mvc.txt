# Модель-представление-контроллер {#mvc}

В этой главе вы узнаете о моделях, представлениях и контроллерах (шаблон проектирования Model-View-Controller, MVC).
Веб-приложения используют шаблон MVC, чтобы отделить бизнес-логику от представления.
Целью этого является возможность многократного использования кода и разделение ответственности.

Компоненты ZF3, рассматриваемые в этой главе:

|--------------------------------|---------------------------------------------------------------|
| *Компонент*                    | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Mvc`                     | Поддержка шаблона MVC. Реализует базовые классы контроллера, плагины контроллера и т.д. |
|--------------------------------|---------------------------------------------------------------|
| `Zend\View`                    | Реализует функциональность контейнеров для переменных, рендеринга веб-страниц и помощников видов. |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Http`                    | Реализует обертку HTTP-запроса и ответа.                      |
|--------------------------------|---------------------------------------------------------------|

## Пример Hello World на GitHub

В этой и следующих главах мы приведем несколько примеров кода, которые вы, возможно, 
захотите попробовать написать сами. Вероятно, у новичка могут возникнуть сложности с написанием кода без ошибок.
Если вы застряли или не можете понять, почему ваша программа не работает, вы можете скачать готовое веб-приложение 
'Hello World' с хостинга GitHub. Примеры кода, данные в этой главе по большей части
взяты из этого приложения.

Чтобы скачать приложение *Hello World* посетите [эту страницу](https://github.com/olegkrivtsov/using-zf3-book-samples)
и нажмите кнопку *Clone or Download*, чтобы скачать код ZIP-архивом (см. рисунок 4.1). 
По завершении загрузки, распакуйте архив в какую-либо директорию.

![Рисунок 4.1. Пример 'Hello World' можно скачать с GitHub](../en/images/preface/samples_on_github.png)

Затем зайдите в директорию 'helloworld', которая содержит 
полный исходный ход этого примера:

{line-numbers=off,lang=text}
~~~
/using-zf3-book-samples
    /helloworld
    ...
~~~

Hello World - это целый сайт, который вы можете установить на свой компьютер.
Чтобы установить пример, вы можете либо изменить ваш файл виртуального 
хоста Apache, либо создать новый. После редактирования файла перезапустите
HTTP-сервер Apache и откройте сайт в вашем браузере.

## Разделение бизнес-логики и представления

У типичного вебсайта есть три типа функциональности: код реализации бизнес-логики,
код реализации взаимодействия с пользователем и код рендеринга HTML-страниц (представления).
До PHP-фреймворков программисты обычно соединяли эти три типа кода в один большой PHP-скрипт,
что делало тестирование и поддержку такого кода крайне тяжелыми, особенно, если вы пишете
сайт больших размеров.

Сейчас, когда PHP стал объектно-ориентированным, вы можете разбить свой код на классы.
Шаблон *модель-представление-контроллер* (MVC) - это всего лишь набор советов о том, как
организовать ваши классы так, чтобы с ними легко было работать.

В MVC классы, содержащие бизнес-логику называются *моделями*, фрагменты кода 
рендеринга HTML-страниц - *представлениями*, а классы, ответственные за общение
с пользователем - *контроллерами*.

I> Представления реализованы как *фрагменты кода*, а не как классы. Это объясняется тем, что 
I> представления, как правило, очень просты и содержат только смесь из HTML и PHP кода.

Главная задача MVC  - отделить бизнес-логику (модели) от ее визуализации (представлений).
Это также называется разделением ответственности - каждое звено занимается лишь
своими задачами.

Отделяя модели от представлений, вы снижаете количество зависимостей между ними. 
Поэтому изменения, сделанные в одном звене, будут иметь наименьшее воздействие на другие. 
Такое разделение также улучшает *возможность многократного использования кода*. Например,
вы можете создать несколько визуальных представлений для одних и тех же моделей.
 
Чтобы лучше понять, как это работает, давайте вспомним, что любой 
сайт - это просто PHP-программа, получающая HTTP-запрос от веб-сервера и отправляющая 
HTTP-ответ. Рисунок 4.2 показывает, как HTTP-запрос обрабатывается MVC-приложением
и как генерируется ответ:

![Рисунок 4.2. Обработка MVC-запроса в MVC-приложении](../en/images/mvc/model-view-controller.png)

* Первым делом посетитель вебсайта вводит URL в свой браузер, например *http://localhost*, и браузер
  отправляет запрос веб-серверу через Интернет.
  
* PHP-движок веб-сервера запускает входной скрипт *index.php*. Все, что делает этот скрипт, - 
  это создает экземпляр класса `Zend\Mvc\Application`.

* Приложение использует машрутизатор (router) для парсинга URL и определения того,
  какому контроллеру передать запрос. Если маршрут найден, контроллер инстанцируется и 
  вызывается его подходящий *метод действия (action method)*.  
  
* В методе действия контроллера, параметры извлекаются из переменных GET и POST.
  Чтобы обработать входящие данные, контроллер инстанцирует подходящие 
  классы моделей и вызывает их методы.
  
* Классы моделей используют алгоритмы бизнес-логики, чтобы обработать входящие данные
  и вернуть выходные данные. Алгоритмы бизнес-логики различаются для каждого приложения -
  обычно они включают в себя извлечение данных из базы, управление файлами, взаимодействие
  со внешними системами и так далее.
  
* Результаты обращения к моделям передаются соответствующему
  скрипту представления для рендеринга HTML-страницы.
  
* Скрипт представления использует данные, полученные от модели для рендеринга.

* Контроллер передает полученный HTTP-ответ приложению.
    
* Веб-сервер возвращает полученную HTML-страницу браузеру пользователя.

* Пользователь видит страницу в окне браузера. 

Теперь вы имеете некое представление, о том, как модели, представления и контроллеры 
взаимодействуют для создание HTML-ответа. В следующих разделах мы опишем их более детально.

## Контроллеры

Контроллер обеспечивает связь между приложением, моделями и представлениями: он получает
HTTP-запрос и использует модель(и) и соответствующее представление, чтобы создать
необходимый HTTP-ответ.

Контроллеры, принадлежащие модулю, обычно находятся в директории 'Controller' в 
директории модуля с исходным кодом (показано на рисунке 4.3)

![Рисунок 4.3. Директория контроллеров](../en/images/mvc/controller_dir.png)

Скелетное приложение снабдит вас стандартной реализацией класса контроллера `IndexController`.
`IndexController` - это, как правило, главный класс контроллера вебсайта. Его код
представлен ниже (некоторые куски кода пропущены для упрощения)

{line-numbers=on,lang=php}
~~~
<?php
namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;

class IndexController extends AbstractActionController
{
    public function indexAction()
    {
        return new ViewModel();
    }
}
~~~

Из примера выше вы видите, что контроллеры обычно определяют свое собственное пространство имен (строка 2).
`IndexController`, как все другие контроллеры модуля *Application*, существует в пространстве имен `Application\Controller`.

Контроллер - это обычный PHP-класс, наследуемый от базового класса `AbstractActionController` (строка 7).

По умолчанию класс контроллера содержит один *метод действия*, называемый `indexAction()` (см. строки 9-12).
Обычно вы будете создавать другие методы действия в ваших классах контроллеров.

T> ZF3 автоматически распознает методы действия по суффиксу 'Action'. 
T> Если название метода у контроллера не имеет этого суффикса, он считается обычным методом, не методом действия.

Как следует из его имени, метод действия делает некоторые действия с сайтом, 
которые, как правило, заканчиваются созданием одной веб-страницы. Контроллер `IndexController`
обычно содержит методы действий, которые можно отести ко всему сайту (таблица 4.1). Например, у вас будет
действие "index" для *Главной (Home)* страницы, действие "about" для страницы *About*,
действие "contactUs" для страницы *Свяжитесь с нами (Contact Us)* и, возможно, другие.

{title="Таблица 4.1. Типичные действия Index-контроллера"}
|------------------------------------|--------------------------------------------------|
| *Метод действия*                   | *Описание*                                       |
|------------------------------------|--------------------------------------------------|
| `IndexController::indexAction()`   | Действие "index" отображает домашнюю страницу вашего сайта. |
|------------------------------------|--------------------------------------------------|
| `IndexController::aboutAction()`   | Действие "about" отображает страницу "About".    |
|                                    | Она содержит контактную информацию и информацию  |
|									 | о авторских правах.                              |
|------------------------------------|--------------------------------------------------|
| `IndexController::contactUsAction()`|  Действие "contactUs" отображает страницу       |
|                                    | "Contact Us". На этой странице находятся         | 
|									 | способы связи с авторами сайта.                  |
|------------------------------------|--------------------------------------------------|

### Класс базового контроллера

Каждый контроллер на вашем сайте наследуется от базового класса `AbstractActionController`.
На рисунке 4.4 представлена диаграмма наследования класса.

![Рисунок 4.4. Диаграмма наследования класса](../en/images/mvc/controller_inheritance.png)

Класс `AbstractActionController` содержит несколько полезных методов, которые вы
можете использовать в своих классах контроллеров. Таблица 4.2 вкратце рассказывает о них:

{title="Таблица 4.2. Полезные методы AbstractActionController"}
|----------------------------------|--------------------------------------------------------|
| *Имя метода*                     | *Описание*                                             |
|----------------------------------|--------------------------------------------------------|
| `getRequest()`                   | Возвращает объект `Zend\Http\Request`, который   |
|                                  | является представлением данных HTTP-запроса.           |
|----------------------------------|--------------------------------------------------------|
| `getResponse()`                  | Возвращает объект `Zend\Http\PhpEnvironment\Response`,  |
|                                  | что позволяет установить данные HTTP-ответа.          |
|----------------------------------|--------------------------------------------------------|
| `getEventManager()`              | Возвращает объект `Zend\EventManager\EventManager`,    |
|                                  | что позволяет вызвать и обработать событие.           |
|----------------------------------|--------------------------------------------------------|
| `getEvent()`                     | Возвращает объект `Zend\Mvc\MvcEvent` object, который  |
|                                  | представляет событие, на которое отвечает контроллер.  |
|----------------------------------|--------------------------------------------------------|
| `getPluginManager()`             | Возвращает объект `Zend\Mvc\Controller\PluginManager`, |
|                                  | который можно использовать для плагинов контроллера.   |
|----------------------------------|--------------------------------------------------------|
| `plugin($name, $options)`        | Этот метод позволяет обращаться к определенному        |
|                                  | плагину контроллера, по заданному имени.               |
|----------------------------------|--------------------------------------------------------|
| `__call($method, $params)`       | Позволяет вызвать плагин контроллера, используя        |  
|                                  | магический PHP-метод `__call`.                         |
|----------------------------------|--------------------------------------------------------|

Как вы видите из таблицы приведенной выше, базовый класс контроллера позволяет вам получить доступ к 
HTTP-запросу и ответу, а также доступ к менеджеру событий.
Он также дает вам возможность вызывать плагины контроллера (о плагинах контроллера
мы узнаем позже в этой главе).

## Извлечение данных из HTTP-запроса

В методе действия контроллера вам, возможно, придется извлекать данные из HTTP-запроса
(такие данные как переменные GET и POST, куки (cookies), HTTP-заголовки и так далее). Для этих целей, Zend Framework 3 
предоставляет вам класс `Zend\Http\Request`, являющийся частью компонента `Zend\Http`.

Чтобы получить объект HTTP-запроса, внутри вашего метода действия вы можете использовать следующий код:

{line-numbers=off,lang=php}
~~~
// Получить объект HTTP запроса
$request = $this->getRequest();
~~~

Этот код возвращает экземпляр класса `Zend\Http\Request`, содержащий все данные HTTP-запроса.
В таблице 4.3 вы найдете самые распространенные методы класса 'Request`, а также их
краткое описание.

{title="Таблица 4.3. Методы класса `Zend\Http\Request`."}
|----------------------------------------|------------------------------------------------------|
| Имя метода                             | Описание                                             |
|----------------------------------------|------------------------------------------------------|
| `isGet()`                              | Проверяет, является ли запрос GET-запросом.          |
|----------------------------------------|------------------------------------------------------|
| `isPost()`                             | Проверяет, является ли запрос POST-запросом.         |
|----------------------------------------|------------------------------------------------------|
| `isXmlHttpRequest()`                   | Проверяет, является ли запрос AJAX-запросом.         |
|----------------------------------------|------------------------------------------------------|
| `isFlashRequest()`                     | Проверяет, является ли запрос Flash-запросом.        |
|----------------------------------------|------------------------------------------------------|
| `getMethod()`                          | Возвращает метод для этого запроса.                  |
|----------------------------------------|------------------------------------------------------|
| `getUriString()`                       | Возвращает URI этого запроса в формате строки.       |
|----------------------------------------|------------------------------------------------------|
| `getQuery($name, $default)`            | Возвращает параметр запроса по имени или все параметры запроса.|
|                                        | Если параметр не найден, возвращает значение `$default`.|    
|----------------------------------------|------------------------------------------------------|
| `getPost($name, $default)`             | Возвращает контейнер параметров, ответственный за    |
|                                        | параметр(ы) POST.                                    |
|----------------------------------------|------------------------------------------------------|
| `getCookie()`                          | Возвращает заголовок Куки.                           |
|----------------------------------------|------------------------------------------------------|
| `getFiles($name, $default)`            | Возвращает контейнер параметров, ответственный за    |
|                                        | параметры файлов или файла.                          |
|----------------------------------------|------------------------------------------------------|
| `getHeaders($name, $default)`          | Возвращает контейнер заголовка, ответственный за     |
|                                        | заголовки или все заголовки определенного имени/типа.|
|----------------------------------------|------------------------------------------------------|
| `getHeader($name, $default)`           | Возвращает заголовок по имени. Если заголовок не     |
|                                        | найден, возвращает значение `$default`.               |
|----------------------------------------|------------------------------------------------------|
| `renderRequestLine()`                  | Возвращает отформатированную начальную строку |
|                                        | для этого HTTP-запроса.                              |
|----------------------------------------|------------------------------------------------------|
| `fromString($string)`                  | Статический метод, который создает объект `Request` из |
|                                        | строковой переменной.                                 |
|----------------------------------------|------------------------------------------------------|
| `toString()`                           | Возвращает необработанный HTTP-запрос в виде строки. |
|----------------------------------------|------------------------------------------------------|

## Извлечение переменных GET и POST

Чтобы получить переменную GET или POST из HTTP-запроса, используйте следующий код:

{line-numbers=on,lang=php}
~~~
// Получить переменную GET
$getVar = $this->params()->fromQuery('var_name', 'default_val');

// Получить переменную POST
$postVar = $this->params()->fromPost('var_name', 'default_val');
~~~

В примере выше мы используем плагин контроллера `Params`, который предоставляет
удобный способ доступа к GET и POST переменным, выгружаемым файлам (uploaded files) и т.д.

В строке 2 мы используем метод `fromQuery()` для извлечения переменной под названием "var_name" из GET.
Если такой переменной нет, возвращается значение по умолчанию "default_val".
Значение по умолчанию очень удобно, потому что вам не нужно использовать PHP-функцию `isset()`,
чтобы проверить существует ли переменная.

В строке 5 мы используем метод `fromPost()` для извлечения переменной из POST. Назначение параметров
этого метода такое же, как и у `fromQuery()`.

T> В ZF3 вы не должны обращаться к параметрам через стандартные суперглобальные массивы `$_GET` и `$_POST`
T> Вместо этого вы используете предоставляемое ZF3 API для извлечения данных запроса.

## Ввод данных в HTTP-ответ

Хотя вы редко взаимодействуете с данными HTTP-ответа (response) напрямую, вы можете сделать это с помощью
метода `getResponse()` из базового класса `AbstractActionController`.
Метод `getResponse()` возвращает экземпляр класса `Zend\Http\PhpEnvironment\Response`.
Таблица 4.4 содержит самые важные методы этого класса:

{title="Таблица 4.4. Методы класса Zend\Http\PhpEnvironment\Response."}
|----------------------------------------|--------------------------------------------------------|
| Имя метода                             | Описание                                               |
|----------------------------------------|--------------------------------------------------------|
| `fromString($string)`                  | Заполняет объект ответа из строки.                   |
|----------------------------------------|------------------------------------------------------|
| `toString()`                           | Конвертирует объект запроса в строку. |
|----------------------------------------|------------------------------------------------------|
| `setStatusCode($code)`                 | Устанавливает код состояния HTTP и (опционально) сообщение (status message). |
|----------------------------------------|------------------------------------------------------|   
| `getStatusCode()`                      | Извлекает код состояния HTTP                         |
|----------------------------------------|------------------------------------------------------|    
| `setReasonPhrase($reasonPhrase)`       | Устанавливает HTTP сообщение (status message).       |
|----------------------------------------|------------------------------------------------------|    
| `getReasonPhrase()`                    | Возвращает HTTP сообщение (status message).                             |
|----------------------------------------|------------------------------------------------------|
| `isForbidden()`                        | Проверяет код ответа на 403 Forbidden.               |
|----------------------------------------|------------------------------------------------------|
| `isNotFound()`                         | Проверяет, указывает ли код состояния на то, что ресурс не найден (код состояния 404). |
|----------------------------------------|------------------------------------------------------|
| `isOk()`                               | Проверяет успешность ответа.                         |
|----------------------------------------|------------------------------------------------------|
| `isServerError()`                      | Проверяет ответ на код состояния 5xx.                |
|----------------------------------------|------------------------------------------------------|     
| `isRedirect()`                         | Проверяет, является ли ответ 303 Redirect.           |
|----------------------------------------|------------------------------------------------------|    
| `isSuccess()`                          | Проверяет, является ли ответ 200 Successful.         |
|----------------------------------------|------------------------------------------------------|
| `setHeaders(Headers $headers)`         | Позволяет устанавливать заголовки ответа.            |
|----------------------------------------|------------------------------------------------------|
| `getHeaders()`                         | Возвращает список заголовков ответа.                 |
|----------------------------------------|------------------------------------------------------|
| `getCookie()`                          | Извлекает заголовок Куки.                            |
|----------------------------------------|------------------------------------------------------|
| `setContent($value)`                   | Устанавливает необработанное содержимое ответа.      |
|----------------------------------------|------------------------------------------------------|
| `getContent()`                         | Возвращает необработанное содержимое ответа.         |
|----------------------------------------|------------------------------------------------------|
| `getBody()`                            | Получает и декодирует содержимое ответа.             |
|----------------------------------------|------------------------------------------------------|

Например, используйте следующий код, чтобы установить код состояния 404 для ответа:

{line-numbers=off,lang=php}
~~~
$this->getResponse()->setStatusCode(404);
~~~

Используйте следующий код, чтобы добавить заголовок (header) в HTTP-ответ:

{line-numbers=off,lang=php}
~~~
$headers = $this->getResponse()->getHeaders();
$headers->addHeaderLine(
             "Content-type: application/octet-stream");
~~~

Используйте следующий код, чтобы установить содержимое (content) HTTP-ответа:

{line-numbers=off,lang=php}
~~~
$this->getResponse()->setContent('Some content');
~~~

## Контейнеры для переменных

После того, как вы извлекли данные из HTTP-запроса, вы что-либо делаете с этими данными (как правило, вы будете
обрабатывать данные с помощью моделей) и вернете выходные данные из метода действия.

Как вы можете видеть, метод `indexAction()` Index-контроллера возвращает экземпляр класса `ViewModel`.
Класс `ViewModel` - это своего рода *переменная-контейнер*. Все переменные, переданные в ее конструктор, 
затем будут автоматически доступны скрипту представления.

Давайте рассмотрим пример из реальной жизни. Мы создадим еще один метод действия в нашем классе `IndexController`, 
который мы назовем `aboutAction()`. Действие "about" будет отображать страницу *About Us* нашего сайта.
В методе действия мы создадим две переменные, содержащие информацию о нашем сайте, и вернем 
переменные для передачи в представление с помощью объекта `ViewModel`:

{line-numbers=on,lang=php}
~~~
// Действие "about" 
public function aboutAction() 
{              
    $appName = 'HelloWorld';
    $appDescription = 'A sample application for the Using Zend Framework 3 book';
    
    // Возвращает переменные скрипту представления с помощью 
    // переменной-контейнера ViewModel
    return new ViewModel([
        'appName' => $appName,
        'appDescription' => $appDescription
    ]);
}
~~~ 

В строках 4-5 мы создаем переменные `$appName` и `$appDescription`. Они хранят соответственно
имя и описание нашего приложения.

В строках 9-12 мы передаем переменные, которые мы создали, в конструктор объекта `ViewModel`
как ассоциативный массив. Ключи массива определяют имена переменных, которые после возврата
будут доступны скрипту представления.

Класс `ViewModel` предоставляет несколько методов, которые вы можете дополнительно использовать, 
чтобы установить переменные в `ViewModel` и извлечь переменные из него. Таблица 4.5 
расскажет о этих методах:

{title="Таблица 4.5. Методы класса ViewModel"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `getVariable($name, $default)` | Возвращает переменную по имени (или значение по умолчанию,    |
|                                | если переменной не существует).                               |
|--------------------------------|---------------------------------------------------------------|
| `setVariable($name, $value)`   | Устанавливает переменную.                                     |
|--------------------------------|---------------------------------------------------------------|
| `setVariables($variables, $overwrite)`|  Устанавливает набор переменных; есть возможность      |
|                                | перезаписи уже существующих.                                  |
|--------------------------------|---------------------------------------------------------------|
| `getVariables()`               | Возвращает все переменные как массив.                         |
|--------------------------------|---------------------------------------------------------------|    
| `clearVariables()`             | Удаляет все переменные.                                       |
|--------------------------------|---------------------------------------------------------------|

## Выражаем ошибочное состояние 

Иногда что-то идет не так, и происходит состояние ошибки. Например, вы ожидаете получить GET-переменную 
из HTTP-запроса, но она отсутствует либо имеет недопустимое значение. Чтобы выразить это состояние ошибки,
вы обычно устанавливаете [код ошибки](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) *4xx* в HTTP-ответе 
и возвращаетесь из действия контроллера.

Для примера, в приложении Blog, предположим, что пользователь вводит следующий URL в адресную строку браузера: *http://localhost/posts/view?id=10000*. Намерение
такого запроса - отобразить пост блога с ID=10000. Если такой пост с таким ID не существует, мы устанавливаем код ошибки 
404 (Page Not Found) в ответе:

{line-numbers=off,lang=php}
~~~
// Действие "view" отображает пост блога с заданным ID
public function viewAction()
{
    // Получить аргумент ID из GET
    $id = (int)$this->params()->fromQuery('id', -1);
    
    // Проверяем аргумент
    if ($id<1) {
        // Состояние ошибки - мы не можем отобразить пост 
        $this->getResponse()->setStatusCode(404);
        return;
    }
    
    // Пытаемся найти пост в базе данных (SQL-запрос опущен для простоты).
    $post = ...
    if (!$post) {
        // Состояние ошибки - пост не найден
        $this->getResponse()->setStatusCode(404);
        return;
    }
    
    // Нормальное выполнение
    // ...
}
~~~

Когда ZF3 обнаруживает код ошибки *4xx* в ответе, он перенаправляет пользователя на специальную *страницу ошибки*. Мы поговорим
о страницах ошибок позже в данной главе.

Еще один способ выразить (критическую) ошибку - это выбросить исключение `Exception`, например, так:

{line-numbers=off,lang=php}
~~~
throw new \Exception("Post with ID=$id could not be found");
~~~

Когда ZF3 обнаруживает необработанное исключение, он показывает другую страницу ошибки с информацией об исключении.

## Регистрация контроллера

Все классы контроллера, принадлежащие модулю, должны быть зарегистрированы в файле конфигурации *module.config.php*.
Если вашему контроллеру не нужно вызывать какие либо сервисы (если у него нет зависимостей), то вы можете зарегистрировать
его следующим образом:

{line-numbers=on,lang=php}
~~~
<?php
use Zend\ServiceManager\Factory\InvokableFactory;

return [
    // ...
    
    'controllers' => [
        'factories' => [
            Controller\IndexController::class => InvokableFactory::class
            // Вставьте сюда регистрацию других контроллеров
        ],
    ],
    
    // ...
];
~~~

В строке 7 у нас есть ключ *controllers*, который содержит подключ *factories*.
Чтобы зарегистрировать класс контроллера, нужно добавить строку
в виде пары *key=>value*. Ключом должно быть полностью квалифицированное имя класса контроллера,
например, `\Application\Controller\IndexController` (мы можем использовать ключевое слово PHP
`::class` для разрешения имен) и значение должно быть именем фабричного класса. В нашем случае,
мы используем стандартную фабрику `InvokableFactory`, но, если хотите, можете создать свою фабрику.

I> Используя `InvokableFactory`, вы говорите Zend Framework'у, что
I> он может вызвать контроллер, инстанцировав его с помощью оператора `new`. Это самый
I> простой способ инстанциации контроллера. В качестве альтернативы, вы можете создать свою
I> фабрику для создания экземпляров контроллера и внедрить зависимости (inject dependencies) в контроллер.

### Регистрация фабрики контроллера

Если в вашем контроллере вам нужно будет вызвать какой либо сервис (а это случается очень часто), вам нужно будет извлечь этот сервис из *менеджера сервисов* (мы обсуждали
менеджер сервисов в главе [Как работает вебсайт](#operation)) и передать этот сервис в конструктор класса контроллера, и затем контроллер должен сохранить
переданный сервис в виде приватного свойства для своего внутреннего использования (dependency injection).

Эта процедура обычно реализуется внутри фабрики. Например, предположим, что в нашем контроллере мы хотим иметь возможность 
вызова некого сервиса `CurrencyConverter`, который умеет конвертировать валюту USD в EUR. Класс фабрики для нашего контроллера будет выглядеть
следующим образом:

{line-numbers=off,lang=php}
~~~
<?php 
namespace Application\Controller\Factory;

use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\CurrencyConverter;
use Application\Controller\IndexController;

// Класс фабрики
class IndexControllerFactory implements FactoryInterface
{
    public function __invoke(ContainerInterface $container, 
                     $requestedName, array $options = null) 
    {
        // Извлечь экземпляр сервиса CurrencyConverter из менеджера сервисов.
        $currencyConverter = $container->get(CurrencyConverter::class);
        
        // Создать экземпляр контроллера и передать сервис в его конструктор.
        return new IndexController($currencyConverter);	
    }
}
~~~

Далее вы регистрируете контроллер обычным путем, но указываете фабрику, которую мы только что написали:

{line-numbers=off,lang=php}
~~~
<?php
return [
    // ...
    
    'controllers' => [
        'factories' => [
            Controller\IndexController::class => Controller\Factory\IndexControllerFactory::class
        ],
    ],
    
    // ...
];
~~~

I> Если у вас есть опыт работы с Zend Framework 2, вы можете заметить, что в ZF3 все стало немного по-другому. 
I> В ZF2 у класса `AbstractActionController` был метод `getServiceLocator()`, который позволял извлекать зависимости даже и без фабрики контроллера. 
I> В ZF3 вы должны передавать зависимости принудительно. Это немного более утомительно, но зато удаляет 
I> "скрытые" зависимости и делает код легче для понимания.

### LazyControllerAbstractFactory

Написание фабрики для почти каждого контроллера может показаться утомительным на первый взгляд. Если вы настолько
ленивы, что не хотите этого делать, вы можете использовать стандартную фабрику `LazyControllerAbstractFactory`. 

T> Фабрика `LazyControllerAbstractFactory` использует *reflection* для определения того, какие сервисы ваш контроллер хочет
T> использовать. Вам просто нужно *указать тип* (*typehint*) аргументов конструктора контроллера, и фабрика сама
T> извлечет нужные сервисы и передаст их конструктору.

Например, чтобы внедрить сервис `CurrencyConverter` в ваш контроллер, убедитесь, что конструктор контроллера выглядит следующим образом:

{line-numbers=off,lang=php}
~~~
namespace Application\Controller;

use Application\Service\CurrencyConverter;

class IndexController extends AbstractActionController
{
    // Здесь мы сохраним сервис для внутреннего использования.
    private $currencyConverter;
    
    // Укажите тип аргументов конструктора, чтобы получить сервисы этого типа.
    public function __construct(CurrencyConverter $currencyConverter)
    {
        $this->currencyConverter = $currencyConverter;
    }
}
~~~

Затем вы регистрируете контроллер точно также, но указываете фабрику `LazyControllerAbstractFactory`:

{line-numbers=off,lang=php}
~~~
<?php
use Zend\Mvc\Controller\LazyControllerAbstractFactory;

return [
    // ...
    
    'controllers' => [
        'factories' => [
            Controller\IndexController::class => LazyControllerAbstractFactory::class
        ],
    ],
    
    // ...
];
~~~

## Когда создавать новый контроллер?

Когда ваш сайт вырастет в размерах, вам нужно будет создавать новые классы контроллеров вместо того, чтобы размещать
все действия в `IndexController`. Index-контроллер используется для определения действий, которые работают
на весь ваш сайт.

T> Не желательно создавать гигантские контроллеры с сотнями действий, потому что это делает их сложными для понимания и поддержки.

Рекомендуется создавать новый класс контроллера для каждой модели (или для самых важных) вашей области бизнес-логики.

Например, вы можете создать `UserController` для управления пользователями вашего сайта.
Этот контроллер будет иметь стандартное действие "index" для отображения страницы
со всеми пользователями, действие "add" для добавления нового юзера, действие "edit" для
изменения профиля пользователя и действие "delete" для удаление пользователя.

Аналогично, вы можете создать `PurchaseController` и его действия для управления покупками ваших продуктов
и подключения корзины, `DownloadController` и его действия для управления загрузками файлов с сайта и т.д.

## Плагины контроллера

*Плагин контроллера*  - это класс, который некоторым образом расширяет функциональность *всех контроллеров*.

I> Без плагинов, чтобы расширить функциональность всех контроллеров, вам нужно бы было
I> создать базовый класс, скажем, `BaseController`, и
I> наследовать другие контроллеры от этого базового класса. Так тоже можно делать, но с точки зрения создателей ZF3 плагины -
I> решение лучше, так как они используют *композицию классов* [^foo], которая обеспечивает большую гибкость по сравнению
I> с наследованием классов. Вы создаете ваш плагин контроллера, и он автоматически становится доступным изо всех
I> контроллеров вашего приложения (базовый класс `AbstactActionController` использует магический PHP-метод `__call()` 
I> для передачи вызовов созданным плагинам контроллеров.).

[^foo]: *Композиция* - это взаимосвязь между двумя классами, называемая "has-a" и лучше всего описываемая как
отношение "часть - целое". Класс-владелец содержит ссылку на другой класс (плагин).
Владелец ответственен за существование объекта, который он содержит.

Существует несколько стандартных плагинов контроллера (см. таблицу 4.6), и мы уже использовали один из них (`Params`)
в одном из предыдущих примеров.

{title="Таблица 4.6. Стандартные плагины контроллера."}
|------------------------------------------|------------------------------------------------------|
| *Стандартный класс плагина*              | *Описание*                                           |
|------------------------------------------|------------------------------------------------------|
| `Params`                                 | Позволяет извлечь переменные из HTTP-запроса,        |
|                                          | включая переменные GET и POST                        |
|------------------------------------------|------------------------------------------------------|
| `Url`                                    | Позволяет генерировать абсолютные или относительные  |
|                                          | URL изнутри контроллеров.                            |
|------------------------------------------|------------------------------------------------------|
| `Layout`                                 | Дает модели представления лэйаута доступ для         |
|                                          | передачи данных шаблону лэйаута.                     |
|------------------------------------------|------------------------------------------------------|
| `Identity`                               | Возвращает личность (identity) пользователя, который зашел на   |
|                                          | вебсайт.                                             |
|------------------------------------------|------------------------------------------------------|
| `FlashMessenger`                         | Позволяет определить "flash"-сообщения, который хранятся|
|                                          | сессией, и могут быть отображены на другой странице.|
|------------------------------------------|------------------------------------------------------|
| `Redirect`                               | Позволяет перенаправить запрос методу действия       |
|                                          | другого контроллера.                                 |
|------------------------------------------|------------------------------------------------------|
| `PostRedirectGet`                        | Перенаправляет POST-запрос, конвертирует все         |
|                                          | POST-переменные в GET-переменные.                    |
|------------------------------------------|------------------------------------------------------|
| `FilePostRedirectGet`                    | Перенаправляет POST-запрос, сохраняя выгруженные файлы (uploaded files).|
|------------------------------------------|------------------------------------------------------|

Внутри метода действия контроллера, вы получаете доступ к плагину следующим образом:

{line-numbers=off,lang=php}
~~~
// Доступ к плагину Url
$urlPlguin = $this->url();

// Доступ к плагину лэйаутов
$layoutPlugin = $this->layout();

// Доступ к плагину перенаправления
$redirectPlugin = $this->redirect();
~~~

В качестве альтернативы вы можете вызвать плагин по его полностью квалифицированному имени с помощью метода `plugin()`,
предоставлемого базовым классом контроллера, следующим образом:

{line-numbers=off,lang=php}
~~~
use Zend\Mvc\Controller\Plugin\Url; 
 
// Inside your controller's action use the plugin() method.
$urlPlugin = $this->plugin(Url::class);
~~~

### Пишем свой собственный плагин контроллера

На вашем вебсайте вам, вероятно, понадобится создать свои собственные плагины контроллеров.
Например, представьте, что вам нужно, чтобы все ваши классы контроллеров могли проверять, доступно
ли пользователю сайта то или иное действие контроллера. Это можно сделать, используя класс `AccessPlugin`.

Плагин контроллера должен наследоваться от класса `AbstractPlugin`.
Плагины, как правило, существуют в своем собственном пространстве имен `Plugin`,
которое находится в пространстве имен `Controller`:

{line-numbers=off,lang=php}
~~~
<?php
namespace Application\Controller\Plugin; 

use Zend\Mvc\Controller\Plugin\AbstractPlugin;

// Класс плагина
class AccessPlugin extends AbstractPlugin 
{
    // Этот метод проверяет, разрешено ли пользователю
    // посетить страницу
    public function checkAccess($actionName)
    {
        // ...
    }
}
~~~

Чтобы дать Zend Framework 3 знать о вашем плагине,вам нужно зарегистрировать его в файле
*module.config.php* под ключом `controller_plugins`.
Пример смотрите ниже:

{line-numbers=off,lang=php}
~~~
<?php
return [
    // ... 
 
    'controller_plugins' => [
        'factories' => [
            Controller\Plugin\AccessPlugin::class => InvokableFactory::class,
        ],
	    'aliases' => [
		    'access' => Controller\Plugin\AccessPlugin::class,
	    ]
    ],
 
    // ...
];
~~~

I> Обратите внимание, мы также создаем псевдоним для плагина, чтобы иметь 
I> возможность обратиться к нему по его краткому имени.

После этого вы будете иметь доступ к созданному вами плагину изо всех
действий ваших контроллеров следующим образом:

{line-numbers=off,lang=php}
~~~
// Проверяем, разрешено ли пользователю посещать страницу регистрации
$isAllowed = $this->access()->checkAccess('index');
~~~

## Представления

Представления (views) принадлежат звену презентации вашего веб-приложения, потому что
их целью является создание HTML-разметки, которую веб-сервер возвращает посетителям сайта.

В Zend Framework 3, представление является *файлом шаблона*, то есть, файлом с разрешением
`.phtml` ("phtml" расшифровывается как "PHP+HTML"). Шаблоны представления имеют такое имя, потому что они обычно
содержат HTML-код, смешанный с фрагментами PHP-кода, используемыми для рендеринга веб-страниц.

Представления, как правило, существуют внутри поддиректории *view*
модуля (см. рисунок 4.5):

![Рисунок 4.5. директория View](../en/images/mvc/views_dir.png)

Q> **Почему файлы шаблона представления не хранятся в исходной (*src*) директории модуля?**
Q>
Q> Шаблоны представления (`.phtml` files) не хранятся в исходной (*src*) директории модуля,
Q> потому что они не являются обычными PHP-классами и не нуждаются в автозагрузке
Q> классов PHP. Шаблоны представлений загружаются специальным классом ZF3, называемым
Q> *view resolver*, и поэтому шаблоны представлений хранятся в директории `view`.

Шаблоны представления могут вести себя по-разному в зависимости от переменных, которые вы им передаете из метода
действия контроллера. Данные передаются шаблонам с помощью контейнера переменных `ViewModel`.

Например, давайте создадим шаблон представления для действия `aboutAction()` нашего Index-контроллера.
Страница *About us* отобразит название и некоторую информацию о нашем Hello World приложении.

Чтобы создать файл шаблона представления, в окне NetBeans зайдите в директорию *view/application/index* (см. рисунок 4.6),
нажмите правой кнопкой на директорию "index". В появившемся контекстном меню выберите *New->PHP File...*.

![Рисунок 4.6. Контекстное меню](../en/images/mvc/new_php_file.png)

В появившемся диалоговом окне "New PHP File" (рисунок 4.7), введите *about.phtml* и нажмите кнопку *Finish*.

![Рисунок 4.7. Контекстное меню](../en/images/mvc/new_php_file_dialog.png)

Файл шаблона представления *about.phtml* будет создан и отобразится в NetBeans в правой области.
В этом файле введите следующее: 

{line-numbers=on,lang=php}
~~~
<h1>About</h1>

<p>
    The Hello World application.
</p>

<p>
    Application name: <?= $this->escapeHtml($appName); ?>
</p>

<p>
    Application description: <?= $this->escapeHtml($appDescription); ?>.
</p>
~~~

Как вы видите, шаблон представления - это обычная HTML-страница с несколькими фрагментами PHP-кода.
Скрипт представления просто обрабатывает данные, которые вы ему передаете с помощью контейнера `ViewModel`.
Например, в строке 8 мы получаем значение переменной `$appName` и печатаем его в стандартный поток вывода.

T> Внутри шаблона представления вы легко можете обратиться к переменным, которые были получены от действий контроллера. 
T> Например, чтобы получить значение переменной имени приложения, используйте либо
T> `$appName` или `$this->appName`. Эти два способа обращения к переменной эквивалентны, но первый
T> просто-напросто короче, так что будем использовать его.

Заметьте, что мы используем помощник представления (view helper) `EscapeHtml`, чтобы *экранировать* (escape) напечатанную строку при выводе на веб-страницу,
с целью сделать сайт менее уязвимым к хакерским атакам.

W> Вы всегда должны "экранировать" (escape) переменные, которые вы печатаете на вашу веб-страницу. Это позволяет быть уверенным, что никакой
W> недоброжелательный код не будет внедрен на страницу.

I> В вашем скрипте представления вы также можете использовать операции управления потоком выполнения (такие как `if`, `foreach` или `switch`),
чтобы сделать отображение страницы различным в зависимости от значения переменной.

Теперь давайте посмотрим, как наша страница выглядит в браузере. Наберите "http://localhost/application/about"
в адресной строке вашего браузера. Страница "About us" должна появиться. (см. рисунок 4.8):

![Рисунок 4.8. Страница "About us"](../en/images/mvc/about_page.png)

T> В общем случае, PHP-код внутри представлений должен быть максимально простым. 
T> Представления, как правило, не изменяют данные, передаваемые из контроллера. 
T> Например, представление может использовать модель, которую вы передали, чтобы пройтись по строкам таблицы
T> базы данных и вывести данные на HTML-страницу, но оно никогда не должно создавать таблицы БД или самостоятельно изменять их.

## Помощники представления

*Помощник представления* - это обычно простой (относительно) PHP-класс, целью которого является обработка некоторой
части представления. Вы можете вызвать помощники представления из любого шаблона представления. С этими помощниками, вы можете
создавать виджеты (такие как меню, панели навигации и др.) для ваших веб-страниц.


I> Помощники представлений аналогичны плагинам контроллеров: плагины позволяют "расширять"
I> функциональность контроллеров, а помощники представления позволяют "расширять" функциональность 
I> шаблонов представлений.

ZF3 содержит множество стандартных помощников представления. В таблице 4.7 представлены некоторые
из них с кратким описанием:

{title="Таблица 4.7. Стандартные помощники представления"}
|------------------------------------------|------------------------------------------------------|
| *Standard Plugin Class*                  | *Description*                                        |
|------------------------------------------|------------------------------------------------------|
| `BasePath`                               | Позволяет извлечь базовый путь к веб-приложению,     |
|                                          | который является абсолютным путем к `APP_DIR`.       |
|------------------------------------------|------------------------------------------------------|
| `Url`                                    | Позволяет сгенерировать абсолютный или относительный |
|                                          | URL-адрес изнутри шаблонов представления.            |
|------------------------------------------|------------------------------------------------------|
| `ServerUrl`                              | Извлекает URL текущего запроса.                      |
|------------------------------------------|------------------------------------------------------|
| `Doctype`                                | Помощник для установки и извлечения тэга DOCTYPE         |
|                                          | веб-страницы.                                        |
|------------------------------------------|------------------------------------------------------|
| `HeadTitle`                              | Помощник для установки названия веб-страницы.        |
|------------------------------------------|------------------------------------------------------|
| `HtmlList`                               | Помощник для генерации нумерованных и нененумерованных HTML-списков.|
|------------------------------------------|------------------------------------------------------|
| `ViewModel`                              | Помощник для хранения и извлечения модели представления.|
|------------------------------------------|------------------------------------------------------|
| `Layout`                                 | Извлекает шаблон представления лэйаута.              |
|------------------------------------------|------------------------------------------------------|
| `Partial`                                | Позволяет обработать "частичный" шаблон представления.|
|------------------------------------------|------------------------------------------------------|
| `InlineScript`                           | Помощник для установки и извлечения элементов скрипта|
|                                          | для включения в тело HTML.                           |
|------------------------------------------|------------------------------------------------------|
| `Identity`                               | Помощник для извлечения личности авторизированного пользователя.|
|------------------------------------------|------------------------------------------------------|
| `FlashMessenger`                         | Позволяет извлечь "flash"-сообщения, хранящиеся в сессии.|                                           
|------------------------------------------|------------------------------------------------------|
| `EscapeHtml`                             | Позволяет вынести переменную, выведенную на веб-страницу.|
|------------------------------------------|------------------------------------------------------|

Чтобы продемонстрировать использование помощника представления, ниже мы покажем, как установить название веб-страницы.
Обычно, каждой веб-странице необходимо давать свое название. Вы можете сделать это с помощью помощника
представления `HeadTitle`. Например, вы можете установить название для страницы *About*, добавив
следующий PHP-код в начало шаблона представления *about.phtml*:

{line-numbers=off,lang=php}
~~~
<?php
$this->headTitle('About');
?>
~~~

В данном куске кода мы вызываем помощник представления `HeadTitle` и передаем ему строку с названием страницы ("About")
как аргумент. Помощник представления `HeadTitle` устанавливает элемент `<title>` вашей веб-страницы. 
Затем, если вы откроете страницу *About* в вашем браузере, название страницы будет выглядеть
как "About - ZF Skeleton Application" (см. рисунок 4.9. ниже):

![Рисунок 4.9. Установка названия для страницы About](../en/images/mvc/about_title.png)

I> Мы обсудим помощники представления более детально и дадим больше
I> полезных примеров в разделе [Внешний вид страницы и лэйаут](#appearance).

## Имена шаблонов представления

Когда вы возвращаете данные с контейнером переменных `ViewModel` из метода действия
вашего контроллера, Zend Framework знает имя соответствующего файла шаблона представления.
Например, для метода `aboutAction()` вашего `IndexController`'а, ZF3 автоматически использует
шаблон представления *about.phtml*.

I> ZF3 определяет корректное имя шаблона представления по имени модуля, имени контроллера и имени действия.
I> Например, действие `IndexController::aboutAction()`, принадлежащее модулю `Application` 
I> будет иметь шаблон представления `application/index/about.phtml` по умолчанию.

T> Если название вашего контроллера или действия состоит из нескольких слов в верблюжьем регистре (например, `UserRegistrationController` и `registrationStep1Action`), 
T> ему будет соответствовать шаблон представления *application/user-registration/registration-step-1.phtml* (имена в верблюжьем регистре
T> преобразуются в нижний регистр, и слова разделяются дефисами).

### Переопределение стандартных имен шаблонов представления

`ViewModel` также может использоваться, чтобы переопределить стандартные имена шаблонов представления.
Вообще, класс `ViewModel` - это больше, чем просто контейнер для переменных. Он также позволяет переопределить,
какой именно шаблон представления нужно использовать для рендеринга страницы. Описание методов, используемых
для этого представлено в таблице 4.8.

{title="Таблица 4.8. Методы класса ViewModel для установки и извлечения имени шаблона представления"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                  | *Описание*                                                     |
|--------------------------------|---------------------------------------------------------------|
| `setTemplate()`                | Устанавливает имя шаблона представления.                      |
|--------------------------------|---------------------------------------------------------------|
| `getTemplate()`                | Возвращает имя шаблона представления.                         |
|--------------------------------|---------------------------------------------------------------|

Для установки имени шаблона представления используется метод `setTemplate()`. Метод
`getTemplate()` возвращает имя шаблона представления, которое в данный момент установлено для модели представления.

Следующий образец кода показывает, как можно вызывать метод `setTemplate()` из
метода `indexAction()` вашего класса `IndexController`, чтобы заставить
ZF3 использовать файл шаблона представления *about.phtml* для визуализации главной страницы
вместо файла *index.phtml*.

{line-numbers=on,lang=php}  
~~~
// Метод для отображения главной страницы вашего сайта.
public function indexAction() 
{    
	// Использовать другой шаблон представления для рендеринга страницы.
	$viewModel = new ViewModel();
	$viewModel->setTemplate('application/index/about');
	return $viewModel;
}
~~~

В приведенном отрезке кода мы как обычно создали новый экземпляр класса `ViewModel` (строка 5).
Затем мы вызвали метод `setTemplate()` для объекта модели представления (строка 6) и
передали имя шаблона представления как его аргумент. Имя шаблона представления - это,
по сути, относительный путь к файлу `about.phtml`, но без расширения файла.

Наконец, мы вернули объект модели представления из метода действия (строка 7).

I> Однако, вызывать метод `setTemplate()` в каждом методе действия необязательно.
Если вы не сделаете этого, ZF3 определит имя шаблона представления автоматически,
по текущему имени модуля, имени контроллера и имени метода действия.

## View Resolver

Когда у Zend Framework есть имя шаблона, ему остается только определить абсолютный путь
к соответствующему файлу *.phtml*. Это также называется *разрешением представлений (view resolving)*.
Шаблоны разрешаются специальным классом Zend Framework, который называется *view resolver* (разрешатель представлений)

В ZF3 существуют два разрешателя представлений: `TemplatePathStack` и `TemplateMapResolver`.
Оба принимают в качестве входящий данных имя шаблона представления и возвращают путь к файлу шаблона.
Имя шаблона обычно состоит из имени модуля, затем имени контроллера и затем имени шаблона, например,
"application/index/about", "application/index/index". Исключением является "layout/layout" - здесь нет имени модуля.

* `TemplateMapResolver` использует PHP-массив, чтобы определить путь к файлу шаблона
  представления по его имени. Этот способ быстр, но вам придется хранить в каком-либо
  массиве все пути к шаблонам и обновлять его каждый раз, когда вы добавляете новый шаблон.
  
* `TemplatePathStack` предполагает, что имя шаблона представления однозначно соответствует 
  структуре каталогов. Например, "application/index/about" соответствует 
  *APP_DIR/module/Application/view/application/index/about.phtml*.
  
Настройки разрешателя хранятся внутри файла *module.config.php* под ключом *view_manager*:

{line-numbers=on,lang=php}
~~~
<?php
return [
  //...
    
  'view_manager' => [
    //...
        
    'template_map' => [
        'layout/layout'           => __DIR__ . '/../view/layout/layout.phtml',
        'application/index/index' => __DIR__ . '/../view/application/index/index.phtml',
        'error/404'               => __DIR__ . '/../view/error/404.phtml',
        'error/index'             => __DIR__ . '/../view/error/index.phtml',
    ],
    'template_path_stack' => [
      __DIR__ . '/../view',
    ],
  ],
];
~~~

Как вы видите, настройки разрешателя `TemplateMapResolver` хранятся под ключом *template_map*. По умолчанию,
существует несколько "стандартных" шаблонов представления, которое разрешаются таким
образом: шаблон главной страницы, шаблон лэйаута (мы поговорим о нем в главе [Внешний вид страницы и лэйаут](#appearance))
и шаблоны ошибок (о них поговорим чуть позже). Эти стандартные страницы используют этот тип
разрешателя из-за его быстроты.

Настройки `TemplatePathStack` хранятся под ключом *template_path_stack*.
Как вы можете заметить, этот разрешатель ищет ваши скрипты представления в директории "view" вашего модуля.
Поэтому мы можем просто положить файл *about.phtml* в эту директорию, и ZF3 автоматически 
найдет шаблон.

`TemplateMapResolver` и `TemplatePathStack` работают в паре. Сначала первый пытается найти
шаблон представления в его массиве, и если страница не может быть найдена, начинает 
работу второй.

## Отключение рендеринга представления

Иногда вам придется отключать рендеринг представления, работающий по умолчанию.
Чтобы это сделать, нужно просто вернуть объект `Response` из действия контроллера.

Например, давайте создадим класс `DownloadController` и добавим действие "file",
которое позволит пользователям сайта скачивать файлы с вашего вебсайта. Это действие
не нуждается в соответствующем шаблоне представления *file.phtml*, потому что оно
выбрасывает содержимое файла в стандартный поток вывода PHP.

Добавьте файл *DownloadController.php* в директорию *Controller* модуля *Application*, затем
вставьте в файл следующий код:

{line-numbers=on,lang=php}
~~~
<?php
namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;

/**
 * Это класс контроллера для управления загрузками файлов.
 */
class DownloadController extends AbstractActionController 
{
    /**
     * Это действие 'file', которое вызывается,
     * когда пользователь хочет скачать данный файл.     
     */
    public function fileAction() 
    {
        // Получить имя файла из GET-переменной
        $fileName = $this->params()->fromQuery('name', '');
	
        // Меры предосторожности, чтобы защитить имя файла
        $fileName = str_replace("/", "", $fileName);  // Убрать слеши
        $fileName = str_replace("\\", "", $fileName); // Убрать обратные слеши
	
        // Попытка открыть файл
        $path = './data/download/' . $fileName;
        if (!is_readable($path)) {
            // Поставить код состояния 404 Not Found
            $this->getResponse()->setStatusCode(404);            
            return;
        }
		
        // Получить размер файла в байтах
        $fileSize = filesize($path);

        // HTTP-заголовки
        $response = $this->getResponse();
        $headers = $response->getHeaders();
        $headers->addHeaderLine(
                 "Content-type: application/octet-stream");
        $headers->addHeaderLine(
                 "Content-Disposition: attachment; filename=\"" . 
			     $fileName . "\"");
        $headers->addHeaderLine("Content-length: $fileSize");
        $headers->addHeaderLine("Cache-control: private"); 
		
        // Содержимое файла
        $fileContent = file_get_contents($path);
        if($fileContent!=false) {                
            $response->setContent($fileContent);
        } else {        
            // Устанавливаем код состояния 500 Server Error
            $this->getResponse()->setStatusCode(500);
            return;
        }
	
        // Возвращаем Response, чтобы избежать рендеринга шаблона представления
        return $this->getResponse();
    }
}
~~~

Метод действия берет *имя* параметра из запроса URL (строка 19),
убирает слеши из имени файла (строки 22-23), добавляет HTTP-заголовки
объекту `Response` (строки 39-45) и содержимое файла (строки 48-55). Наконец,
он возвращает объект `Response`, чтобы отключить рендеринг представления.

Зарегистрируйте класс `DownloadController`, добавив следующую строку в 
ваш файл *module.config.php*:

{line-numbers=off,lang=php}
~~~
<?php
return [
    // ...    
    'controllers' => [
        'factories' => [
            // ...
            Controller\DownloadController::class => InvokableFactory::class
        ],
    ],    
     // ...
];
~~~

Вам также понадобится добавить *маршрут* к вашему файлу *module.config.php*.
Измените ключ `routes` файла конфигурации следующим образом:

{line-numbers=off,lang=php}
~~~
<?php
return [
    // ...    
    'router' => [
        'routes' => [
            // Add this route for the DownloadController
            'download' => [
                'type'    => Segment::class,
                'options' => [
                    'route'    => '/download[/:action]',
                    'defaults' => [
                        'controller'    => Controller\DownloadController::class,
                        'action'        => 'index',
                    ],
                ],
            ],
        ],
    ], 
    // ...
];
~~~

Чтобы посмотреть, как работает загрузка файлов, создайте директорию *APP_DIR/data/download* 
и положите туда текстовый файл с именем *sample.txt*. Затем откройте ваш браузер, введите адрес
"http://localhost/download/file?name=sample.txt" и нажмите Enter. Браузер начнет загрузку файла
*sample.txt* и предложит вам его куда-нибудь сохранить.

## Стратегии рендеринга представления

*Стратегия рендеринга представления* (*rendering strategy*) определяет то, как будет визуализирована страница. 
По умолчанию, чтобы получить HTML страницу, производится рендеринг шаблона представления *.phtml* с помощью класса `PhpRenderer`,
живущего в простанстве имен `Zend\View\Renderer`. Эта стратегия работает хорошо в 99% случаев. Но иногда вам может 
понадобиться отобразить что-то кроме HTML страницы, например, ответ в формате JSON или новостную ленту (RSS feed). 

I> Ответ в формате JSON обычно возвращается, когда вы реализуете какой либо API (Application Programming Interface).
I> API используется для того, чтобы извлечь данные с веб-сайта в машинно-читаемом виде.
I> Ответ в виде новостной ленты (RSS feed) обычно используется для публикации часто меняющейся информации, такой как посты блога или новости.  

Итак, ZF3 из коробки предлагает три стратегии рендеринга представления:

  * стратегия, используемая по умолчанию (также известная как `PhpRenderingStrategy`).
  * стратегия `JsonStrategy`, выдающая ответ в формате JSON.
  * и стратегия `FeedStrategy`, выдающая RSS feed.
  
Например, давайте покажем как использовать стратегию `JsonStrategy`, чтобы вернуть ответ JSON из действия контроллера.

Сначала вам нужно *зарегистрировать* стратегию в файле конфигурации *module.config.php*:

{line-numbers=off,lang=php}
~~~
<?php
return [
    //...
    
    'view_manager' => [
        //...
        
        'strategies' => [
            'ViewJsonStrategy',
        ],
    ],
];
~~~

Затем верните объект `JsonModel` (вместо обычного `ViewModel`) из метода действия контроллера:

{line-numbers=off,lang=php}
~~~
namespace Application\Controller;
 
use Zend\Mvc\Controller\ActionController;
use Zend\View\Model\JsonModel;
 
class IndexController extends ActionController
{
    public function getJsonAction()
    {
        return new JsonModel([
            'status' => 'SUCCESS',
            'message'=>'Here is your data',
            'data' => [
                'full_name' => 'John Doe',
                'address' => '51 Middle st.'
            ]
        ]);
    }
}
~~~

Если вы откроете эту страницу в браузере, вы должны увидеть ответ в формате JSON:

~~~
{'status':'SUCCESS', 'message':'Here is your data', 'data':{'full_name:'John Doe', 'address':'51 Middle st.'}}
~~~

## Страницы ошибок

Когда страница не может быть найдена или в вашем веб-приложении происходит какая-то другая ошибка,
отображается стандартная страница ошибки. Появление страницы ошибки контролируется шаблонами ошибок.
Существует два шаблона ошибок: *error/404*, который используется для ошибки "404 Page Not Found" (см. рисунок 4.10),
и *error/index*, который отображается, когда происходит общая ошибка (например, необработанное исключение
выбрасывается внутрь приложения).

![Рисунок 4.10. 404 Error Page](../en/images/mvc/error_404.png)

Файл *module.config.php* содержит несколько параметров под ключом *view_manager* , которые вы можете использовать
для конфигурации отображения ваших шаблонов ошибок:

{line-numbers=on,lang=php}
~~~
<?php
return [
    //...
    
    'view_manager' => [    
        'display_not_found_reason' => true,
        'display_exceptions'       => true,
        //...
        'not_found_template'       => 'error/404',
        'exception_template'       => 'error/index',    
        'template_map' => [
            //...
            'error/404' => __DIR__ . '/../view/error/404.phtml',
            'error/index'=> __DIR__ . '/../view/error/index.phtml',
        ],
        //...
    ],
];
~~~

* Параметр *display_not_found_reason* контролирует, отображать ли детальную информацию
  о ошибке "Page not Found".
* Параметр *display_exceptions* определяет, отображать ли информацию о необработанных исключениях
  и его трассировки стека.
* *not_found_template* определяет имя шаблона для 404 ошибки.
* *exception_template* указывает имя шаблона для ошибки необработанного исключения.

T> Как правило, на production-сервере вы устанавливаете параметры *display_not_found_reason* и *display_exceptions* 
T> в `false`, потому что вы не хотите, чтобы ваши посетители видели детали ошибок
T> на вашем сайте. Однако, вы все равно сможете извлекать детальную информацию
T> из файла Apache `error.log.`.
   
## Модели

*Модель* - это PHP-класс, который содержит бизнес-логику вашего приложения.
Бизнес-логика является "ядром" вашего вебсайта. Она реализует саму цель работы сайта.
Например, если вы создаете сайт онлайн-магазина, у вас будут модели,
реализующие каталог товаров и корзину.

В целом, термин "модель" означает упрощенное представление реального объекта
или явления. "Упрощенное" - потому что у реального объекта бесконечное число
свойств. Например, реальный человек, который посещает ваш сайт, состоит из миллиардов атомов,
и вы не можете описать их все. Вместо этого, вы берете несколько свойств объекта, которые
наиболее важны для вашего объекта, и игнорируете все остальные.
Например, самые важные свойства посетителя сайта (с точки зрения разработчика этого сайта) это
имя, фамилия, страна, город, почтовый индекс и адрес.

Модели могут иметь поведения. Например, почтовая модель
может отправлять e-mail'ы, конвертер валюты может конвертировать
деньги и так далее.

I> С ZF3 вы представляете модели как обычные PHP-классы.
Свойства представлены как поля класса, а поведения - как методы.

## Типы моделей

В Zend Framework 3, нет одной единственной директории 'Model' для хранения классов моделей, как вы
могли бы предположить. Вместо этого модели условно делятся на следующие основные типы, и каждый 
хранится в своей собственной поддиректории.

{title="Таблица 4.9. Типы моделей и их местоположение"}
|--------------------------------|----------------------------------------------------------|
| *Имя модели*                   | *Директория*                                             |
|--------------------------------|----------------------------------------------------------|
| Сущности                     | `APP_DIR/module/Application/src/Entity`                  |
|--------------------------------|----------------------------------------------------------|
| Репозитории                    | `APP_DIR/module/Application/src/Repository`              |
|--------------------------------|----------------------------------------------------------|
| Объекты-значения               | `APP_DIR/module/Application/src/ValueObject`             |
|--------------------------------|----------------------------------------------------------|
| Сервисы                        | `APP_DIR/module/Application/src/Service`                 |
|--------------------------------|----------------------------------------------------------|
| Фабрики                        | В поддиректории `Factory` для каждой директории типа модели.       |
|                                | Например, фабрики контроллеров будут храниться в `APP_DIR/module/Application/src/Controller/Factory`|
|--------------------------------|----------------------------------------------------------|

I> Разделение моделей на разные типы упрощает создание бизнес-логики.
I> Это также называется "проблемно-ориентированное проектирование" (Domain Driven Design или DDD). Впервые DDD 
I> предложил использовать Эрик Эванс в его книге *Domain-Driven Design — Tackling Complexity in the Heart of Software*.

Ниже мы опишем основные типы моделей более детально.

### Сущности (Entities)

*Сущности* предназначены для хранения данных и всегда имеют свойство *идентификатор*, чтобы вы могли точно идентифицировать объект.
Например, сущность `User` всегда будет иметь уникальное свойство `login`,
и вы можете идентифицировать пользователя по этому свойству. Вы можете менять некоторые другие
свойства сущности, как например `firstName` или `address`, но ее идентификатор не будет изменяться.
Сущности обычно хранятся в базе данных, в файловой системе или в любом другом хранилище.

Ниже вы найдете образец сущности `User`, которая представляет посетителя сайта:

{line-numbers=on, lang=php}
~~~
// Сущность User представляет посетителя сайта
class User 
{
    // Свойства
    private $login;     // например, "admin"
    private $title;     // например, "Mr."
    private $firstName; // например, "Ivan"
    private $lastName;  // например, "Ivanov"
    private $country;   // например, "Russia"
    private $city;      // например, "Moscow"
    private $postCode;  // например, "174354"
    private $address;   // например, "Stroiteley st."
    
    // Поведения   
    public getLogin() 
    {
        return $this->login;
    }
        
    public setLogin($login) 
    {
        $this->login = $login;
    }
    
    //...
}
~~~

В строках 5-12 мы определяем свойства модели `User`. Лучше всего определять свойства,
используя приватный тип доступа и делать их доступными для вызова через публичные методы -
*геттеры* и *сеттеры* (такие как `getLogin()` и `setLogin()` и т.д.)

I> Методы поведения модели не ограничены геттерами и сеттерами.
I> Вы можете создавать другие методы, которые будут управлять данными модели.
I> Например, для удобства вы можете определить метод `getFullName()`, 
I> который будет возвращать полное имя пользователя, например, "Mr. Ivan Ivanov".

### Репозитории (Repositories)

*Репозитории* - это специальные модели, ответственные за хранение и извлечение сущностей.
Например, `UserRepository` может представлять таблицу базы данных и предоставлять методы для
извлещения сущностей `User`. Обычно вы используете репозитории для хранения сущностей в базе данных.
С помощью репозиториев вы можете инкапсулировать SQL-запросы в одно место и с легкостью
поддерживать их и тестировать.

I> Мы узнаем о репозиториях более детально в [Управление БД с Doctrine](#doctrine), когда
I> будем говорить о библиотеке Doctrine.

### Объекты-значения (Value Objects)

*Объекты-значения* - это тип модели,  для которого идентификация не так важна, как для сущностей.
Объект-значение - это обычно маленький класс, идентифицируемый всеми его свойствами.
У него нет свойства идентификатора. Объекты-значения, как правило, имеют геттеры, но не имеют
сеттеров (объекты-значения неизменны).

Например, модель, обрабатывающая сумму денег может быть объектом-значением:

{line-numbers=on, lang=php}
~~~
class MoneyAmount 
{
    // Свойства
    private $currency;
    private $amount;
  
    // Конструктор
    public function __construct($amount, $currency='USD') 
    {
        $this->amount = $amount;
        $this->currency = $currency;
    }
  
    // Получаем код валюты
    public function getCurrency() 
    {
        return $this->currency;  
    }
  
    // Получаем сумму денег
    public function getAmount() 
    {
        return $this->amount;
    }  
}
~~~

В строках 4-5 мы определяем два свойства: `currency` и `amount`. У модели нет
свойства идентификатора, вместо этого она идентифицируется всеми свойствами, как одним целым:
если вы поменяете либо `currency` либо `amount`, у вас будет другой объект суммы денег.

В строках 8-12 мы определяем метод конструктора, который инициализирует свойства.

В строках 15-24 мы определяем геттеры для свойств модели. Заметьте, что мы не 
определяем сеттеры (так как модель неизменна).

### Сервисы (Services)

*Модели-сервисы* обычно инкапсулируют некоторую функциональность бизнес-логики. 
Сервисы, как правило, имеют легко узнаваемые имена, заканчивающиеся на суффикс "er", например `FileUploader` или `UserManager`.

Ниже представлен образец сервиса `Mailer`. У него есть метод `sendMail()`, который
берет объект-значение `EmailMessage` и отправляет электронное письмо, используя
стандартную PHP-функцию `mail()`.

{line-numbers=off,lang=php}
~~~
<?php

// Объект-значение и-мейла
class EmailMessage 
{  
    private $recipient;
    private $subject;
    private $text;  
  
    // Конструктор
    public function __construct($recipient, $subject, $text) 
    {
        $this->recipient = $recipient;
        $this->subject = $subject;
        $this->text = $text;
    } 
  
    // Геттеры
    public function getRecipient() 
    {
        return $this->recipient;
    }
  
    public function getSubject() 
    {
        return $this->subject;
    }
  
    public function getText() 
    {
        return $this->text;
    }
}

// Сервис Mailer, который может отправлять сообщения по эл. почте
class Mailer 
{
    public function sendMail($message) 
    {
        // Используем PHP-функцию mail() для отправки письма
        if(!mail($message->getRecipient(), $message->getSubject(), 
                 $message()->getText())) 
        {
            // Ошибка отправки письма
            return false;
        }
    
        return true;
    }
}
~~~

T> В Zend Framework вы, как правило, регистрируете ваши сервисы в менеджере сервисов (Service Manager).

### Фабрики (Factories)

*Фабрики* обычно создаются для инстанцирования других моделей (а именно, моделей сервисов). В простейших случаях вы
можете создать экземпляр класса модели без фабрики, просто используя оператор `new`, но иногда
алгоритм создания класса может быть довольно запутанным, и вы инкапсулируете его внутри класса фабрики.
Например, сервисы часто зависят друг от друга, так что вам может понадобиться *внедрить зависимости* в сервис. Также, иногда
сразу после инстанциации сервиса вам может понадобиться инициализировать его путем вызова определенного(ых) метода(ов).

Классы фабрик обычно имеют имена заканчивающиеся на 'Factory', такие как
`СurrencyConverterFactory`, `MailerFactory`, и т.д.

В качестве реального примера давайте представим себе сервис `PurchaseManager`, который отвечает за логику покупки каких либо товаров, 
и что сервис `PurchaseManager` использует в своей работе другой сервис `CurrencyConverter`, который может соединяться с внешней 
системой, которая предоставляет курсы обмена валют. Давайте напишем фабрику для сервиса `PurchaseManager`, которая бы инстанцировала сервис
и передавала бы ему зависимости:

{line-numbers=off,lang=php}
~~~
<?php
namespace Application\Service\Factory;

use Interop\Container\ContainerInterface;
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\CurrencyConverter;
use Application\Service\PurchaseManager;

/**
 * This is the factory for PurchaseManager service. Its purpose is to instantiate the 
 * service and inject its dependencies.
 */
class PurchaseManagerFactory implements FactoryInterface
{
    public function __invoke(ContainerInterface $container, 
                $requestedName, array $options = null)
    {
        // Get CurrencyConverter service from the service manager.
        $currencyConverter = $container->get(CurrencyConverter::class);
        
        // Instantiate the service and inject dependencies.
        return new PurchaseManager($currencyConverter);
    }
}
~~~

В коде, приведенном выше, у нас есть класс `PurchaseManagerFactory`, который реализует интерфейс 
`Zend\ServiceManager\Factory\FactoryInterface`. У класса фабрики есть метод `__invoke()`,
целью которого является инстанцирование объекта. У этого метода есть аргумент `$container`,
который является менеджером сервисов. Вы можете использовать `$container`, чтобы извлекать сервисы
из менеджера сервисов и передавать их создаваемому объекту. 

## Определение корректного типа модели

Q> **Разве не слишком легко запутаться в таком количестве типов моделей?**
Q>
Q> Ну, и да, и нет. Сначала, может быть нелегко определять
Q> подходящий тип модели, но как только вы наберетесь опыта
Q> вы начнете делать это интуитивно. Просто помните о том, что
Q> типы моделей улучшает структуру ваших моделей предметной области.

Когда вы пишете ваше собственное приложение, вас может сбить с толку необходимость
выбрать, к какому типу модели принадлежит ваш класс (является ли он сущностью, объектом-значением,
репозиторием, сервисом или фабрикой). Ниже представлен простой алгоритм, чтобы упростить выбор
корректного типа модели при написании своего приложения:

* Ваш класс модели - *Сервис*
    * если он инкапсулирует бизнес-логику
    * если вы вызываете его из класса контроллера
    * если вы думаете, что подходящее ему имя заканчивается на суффикс "er": `FileUploader` или `VersionChecker`
* Ваш класс модели - *Сущность*:
    * если ваша модель хранится в базе данных
    * если у него есть свойство идентификатора
    * если у него есть и геттеры, и сеттеры
* Ваш класс модели - *Объект-значение*:
    * если замена любого свойства сделает модель абcолютно другой
    * если у вашей модели есть геттеры, но нет сеттеров (она неизменна)
* Ваша модель - *Репозиторий*:
    * если она работает с базой данных для извлечения сущностей    
* Ваша модель - *Фабрика*:
    * если она может создавать другие объекты и ничего кроме этого

Q> **Хмм... А что если я просто буду хранить все мои модели в одной единственной директории Model?**
Q>
Q> Конечно, вы можете, если очень этого хотите. Но в таком случае, когда вы
Q> будете использовать библиотеку Doctrine ORM, вы заметите, что она также пользуется
Q> принципами DDD, так что использование DDD делает ваше приложение упорядоченным.

## Другие типы моделей

На своем сайте вы, как правило, будете делить ваши основные типы моделей (описанные выше) на подтипы.
Например, у вас будут:

  * *Формы*. Формы - это модели, целью которых является сбор данных, введеных пользователем.
    Формы - это подтип *сущностей*. Обычно они хранятся в директории `APP_DIR/module/Application/src/Form`.

  * *Фильтры*. Фильтры предназначены для изменения входящих данных. 
    Фильтры - это подтип *сервисов*. Обычно они хранятся в директории `APP_DIR/module/Application/src/Filter`.
	
  * *Валидаторы*. Валидаторы используются для проверки входящих данных.
     Они также являются подтипом *сервисов*. Обычно они хранятся в директории `APP_DIR/module/Application/src/Validator`.
	
  * *Помощники видов*. Они инкапсулируют функциональность рендеринга некоторой страницы.
     Помощники видов схожи с *сервисами*. Обычно они хранятся в директории `APP_DIR/module/Application/src/View/Helper`.
	
  * *Маршруты*. Маршруты - это особенный *сервис*, используемый для создания правил
     отображения между URL и вашими контроллерами. Обычно они хранятся в директории `APP_DIR/module/Application/src/Route`.
	
Так, в конце концов у вас получится следующая структура каталогов модуля вебсайта:

~~~
/Application/src
	/Controller
        /Factory
		/Plugin
            /Factory		
	/Entity
	/Filter
	/Form
    /Repository
	/Route
	/Service
		/Factory
	/Validator
    /ValueObject
	/View
		/Helper
            /Factory
~~~
	
I> Вы можете иметь произвольное количество подтипов моделей. Чем сложнее ваше приложение, тем больше подтипов
I> моделей у вас может быть. 

## Тонкие контроллеры, толстые модели, простые представления

При разработке сайта с использованием паттерна «модель-представление-контроллер», существует
риск непонимания роли контроллеров, представлений и моделей. Это приводит к созданию огромных
контроллеров и маленьких моделей, что в свою очередь делает крайне сложным тестировать и поддерживать
ваше приложение. Целью этой главы является ознакомить вас с тем, какой код можно размещать в классе контроллера,
какой - в шаблоне представления, а какой - в классе модели.

### Тонкие контроллеры

Смысл термина "тонкий контроллер" в том, что, как правило, в ваших классах контроллера
вы размещаете только код, который:

* обращается к данным запроса пользователя (`$_GET`, `$_POST`, `$_FILES` и другие PHP-переменные);
* проверяет правильность входных данных;
* (опционально) делает базовую подготовку данных;
* передает данные модели(ям) и извлекает результат, возвращаемый моделью(ями);
* и наконец, возвращает выходные данные как часть контейнера `ViewModel`.

Классу контроллера не следует:

* содержать сложную бизнес-логику, которую лучше хранить в классах моделей;
* содержать какую-либо HTML-разметку, которую лучше хранить в шаблонах представления.

Ниже, в качестве примера "тонкого" контроллера представлен класс `CurrencyConverterController`.
Контроллер имеет метод действия "convert", который конвертирует определенное количество денег
из евро (EUR) в доллары (USD). Пользователь передает количество денег через GET-переменную "amount".

{line-numbers=on,lang=php}  
~~~
class CurrencyConverterController extends AbstractActionController 
{  
    // Модель конвертера валюты
    private $currencyConverter;

    // Конструктор. Его цель - "внедрение" зависимостей.
    public function __construct($currencyConverter)
    {
        $this->currencyConverter = $currencyConverter;
    }

    // Действие "convert" отображает количество конвертированных денег
    public function convertAction() 
    {  
        // Получаем кол-во денег от GET
        $amount = (float)$this->params()->fromQuery('amount', -1);
    
        // Проверяем входящие данные
        if($amount<0) {
            // Money amount is missing
            $this->getResponse()->setStatusCode(404);
            return;
        }
 
        // Передаем данные модели CurrencyConverter
        $convertedAmount = $this->currencyConverter->convertEURtoUSD($amount);	
		
        return new ViewModel([
           'amount'=>$amount,
           'convertedAmount'=>$convertedAmount
        ]);
    }
}
~~~

Метод действия контроллера, представленный выше, делает следующее:

* Принимает данные, переданные посетителем сайта (строка 16). Данные обычно являются частью 
  объекта `Request` и могут быть извлечены с использованием метода контроллера `getRequest()` 
  или плагина контроллера `Params`.

* Проводит базовую проверку данных, переданных пользователем (строка 19), и, если данные отсутствуют (или недействительны),
  устанавливает код HTTP-ошибки (строка 21).
    
* Передает количество денег модели `CurrencyConverter` (строка 26), вызывая ее метод `convertEURtoUSD()`. Этот
  метод затем возвращает конвертированное количество денег.

* Создает переменную-контейнер `ViewModel` и передает ей полученные данные (строка 28).
  Эта переменная-контейнер позже может использоваться в соответствующем шаблоне представления.
  
### Толстые модели

Так как вам нужно оставлять ваши контроллерами настолько тонкими, насколько это возможно,
большинство бизнес-логики вашего приложения следует размещать в классах моделей. В грамотно
написанном приложении «модель-представление-контроллер», модели получаются огромными.
Класс модели может содержать код, который:

* Осуществляет сложную фильтрацию и проверку данных. Так как данные, которые вы извлекаете,
  в контроллере, передается в ваше приложение из "внешнего мира", вам необходимо приложить
  немало усилий, чтобы проверить данные и убедиться, что они не сломают вашу систему. Результатом
  будет безопасный вебсайт, защищенный от хакерских атак.
   
* Осуществляет управление данными. Ваши модели должны управлять данными: например, загружать данные
  из базы данных, сохранять в базу данных и изменять данные. Модели являются подходящим местом для хранения
  запросов БД, чтения файлов и их записи.

В классе модели не рекомендуется:

* Обращаться к данным через HTTP-запрос, `$_GET`, `$_POST` и другие PHP-переменные. Распаковка этих
  данных и передача их модели - это работа контроллера.

* Создавать HTML или другой код для конкретного представления. Такой код может отличаться в зависимости
  от запроса пользователя, и лучше расположить его в шаблоне представления.
  
Если вы будете следовать этим принципам, вы заметите, что ваши модели легко тестируются, 
потому что у них есть четко идентифицируемые ввод и вывод данных. Вы можете написать
юнит-тест, передающий некие данные на вход модели, извлекающий выходные данные и подтверждающий,
что данные корректны.

Если вы не уверены в том, располагать определенный код в контроллере или модели, 
спросите себя: является ли это важной бизнес-логикой, которую нужно тщательно протестировать?
Если ответ "да", вам следует расположить код в модели.

### Простые шаблоны представления

По причине того, что большинство алгоритмов хранятся в ваших моделях, ваши шаблоны представлений
должны быть максимально просты, чтобы создать представление данных, полученных через
переменную-контейнер. В шаблоне представления вы можете:

* Хранить статическую HTML-разметку.

* Извлекать данные из переменной-контейнера и выводить их в поток вывода PHP.

* Если контроллер передал определенную модель через контейнер переменных, запросить данные
  у модели (например, вы можете извлечь строки таблицы из таблицы базы данных и вывести их).
  
* Содержать простые PHP-операции управления потоком выполнения, такие как `if`, `foreach`, `switch` и так далее.
  Это позволяет изменять представление в зависимости от переменных, переданных контроллером.
  
Шаблону представления не рекомендуется:

* Обращаться к данным HTTP-запроса и суперглобальным PHP-переменным.

* Создавать модели, управлять ими и изменять форму приложения.

Если вы будете следовать этим принципам, вы заметите, что ваши представления легко могут
быть заменены без необходимости изменять бизнес-логику вашего приложения. Например,
вы легко сможете изменять дизайн ваших веб-страниц и даже использовать меняющуюся тему (theme).

## Выводы

Вебсайт на Zend Framework 3 - это всего лишь PHP-программа, получающая HTTP-запрос
от веб-сервера и создающая HTTP-ответ.
Веб-приложение использует шаблон «модель-представление-контроллер», чтобы отделить
бизнес-логику от представления. Целью этого является добиться возможности многократного использования кода
и разделения ответственностей.

Контроллер является своеобразным посредником между приложением, моделями и представлениями:
он получает входные данные от HTTP-запроса и использует модель(и) и соответствующее
представление, чтобы создать необходимый HTTP-ответ. Контроллер - это обычный PHP-класс, содержащий
методы действия.

Представления - это простые фрагменты HTML+PHP-кода, создающие выходную HTML разметку, возвращаемую
веб-сервером посетителям сайта. Вы передаете данные скриптам представления через 
контейнер переменных `ViewModel`.

Модель - это PHP-класс, который содержит бизнес-логику вашего приложения. 
Бизнес-логика - это "ядро" вашего сайта, которое осуществляет саму цель работы сайта.
Модели могут обращаться к базе данных, управлять файлами на диске, подключаться к
внешним системам, управлять другими моделями и так далее.

