# Как работает веб-сайт {#operation}

В этой главе мы рассмотрим работу типичного веб-приложения на базе Zend Framework 3.
Вы узнаете немного об основах PHP, таких как классы, как используются пространства имен PHP во избежание конфликтов имен. Вы также
ознакомитесь с такими важными компонентами ZF3 как `Zend\EventManager`, `Zend\ModuleManager` и `Zend\ServiceManager`.
Если вместо изучения теории вы хотите заняться практикой, пропустите эту главу и перейдите к главе [Модель-представление-контроллер](#mvc).

Компоненты ZF3, рассматриваемые в этой главе:

|--------------------------------|---------------------------------------------------------------|
| *Компонент*                    | *Описание*                                                   |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Mvc`                     | Поддержка шаблона "модель-представление-контроллер". Отделяет  |
|                                | бизнес-логику от представления.                                      |
|--------------------------------|---------------------------------------------------------------|
| `Zend\ModuleManager`           | Компонент, ответственный за загрузку и инициализацию модулей веб-приложения. |
|--------------------------------|---------------------------------------------------------------|
| `Zend\EventManager`            | Компонент, обеспечивающий функциональность для инициации событий и обработки событий. |
|--------------------------------|---------------------------------------------------------------|
| `Zend\ServiceManager`          | Реестр всех сервисов, доступных в веб-приложении.             |
|--------------------------------|---------------------------------------------------------------|

## Классы PHP

PHP поддерживает объектно-ориентированное программирование (ООП). В ООП основным элементом кода является *класс (class)*.
Класс может иметь *свойства (properties)* и *методы (methods)*. Например, давайте создадим скрипт *Person.php* и 
объявим в нем класс `Person`:

{line-numbers=off,lang="php"}
~~~
<?php 

class Person
{
    private $fullName;
    
    public function __construct()
    {
        // Код инициализации.
        $this->fullName = 'Unknown person';
    }
    
    public function getFullName()
    {
        return $this->fullName;
    }
    
    public function setFullName($fullName)
    {
        $this->fullName = $fullName;
    }
}
~~~   

I> Как вы можете заметить, в примере выше есть открывающий тег `<?php`, который
I> сообщает PHP-движку, что текст после тега - это PHP-код. В этом примере, где файл содержит
I> только PHP-код (без смешения тегов PHP и HTML), вам не нужно вставлять закрывающий 
I> тег `?>` в конце кода. Более того, это не рекомендуется, и может вызвать нежелательные
I> последствия, если вы случайно добавите какие-либо символы после тега `?>`.

Класс `Person` имеет приватное свойство `$fullName` и три метода:

  * метод `__construct()` - это специальный метод, называемый *конструктором* (constructor). Он используется, если вам нужно как-то инициализировать свойства класса.
  
  * публичные методы `getFullName()` и `setFullName()` позволяют выполнять действия с классом.  

Как только вы объявили класс, вы можете создать *объекты* (objects) этого класса с помощью оператора `new`:

{line-numbers=off,lang="php"}
~~~
<?php 

// Создать объект Person.
$person = new Person();

// Установить имя.
$person->setFullName('John Doe');

// Напечатать имя на экран.
echo "Person's full name is: " . $person->getFullName() . "\n";
~~~

I> Классы позволяют разбить ваш код на меньшие блоки, что делает его лучше организованным. 
I> ZF3 состоит из сотен классов. Вы также будете писать свои собственные классы в ваших веб приложениях.
  
## Пространства имен PHP

Когда вы используете классы из разных библиотек (и даже классы из разных компонентов одной библиотеки)
в вашей программе, имена классов могут конфликтовать между собой.
Это значит, что, имея два класса с одинаковыми именами, вы столкнетесь с ошибкой интерпретатора PHP.
Если вы когда-нибудь разрабатывали сайты с Zend Framework 1, вы, возможно, помните *супердлинные*
имена классов вроде `Zend_Controller_Abstract`. Длинные имена использовались для того, чтобы
избежать конфликтов имен между различными компонентами. У каждого компонента был собственный префикс,
например, `Zend_` или `My_`.

Zend Framework 3 для этих целей используют такую особенность языка PHP, как *пространства имен* (namespaces). 
Они позволяют разрешить конфликты имен между компонентами кода и предоставляют вам возможность
существенно сократить эти имена.

Пространство имен - это такой контейнер для группы имен. Вы можете вложить одно пространство имен в другое.
Если класс не определяют пространство имен, они существуют в *глобальном* пространстве имен
(например, глобальному пространству имен принадлежат классы `Exception` и `DateTime`).

Ниже представлен пример определения пространства имен, взятый из компонента *Zend\Mvc*:

{line-numbers=on,lang="php"}
~~~
<?php
namespace Zend\Mvc;

/**
 * Главный класс приложения.
 */
class Application 
{
    // ... элементы класса опущены для простоты ...
}
~~~

В Zend Framework 3, все классы принадлежат пространству имен верхнего уровня *Zend*.
Строка 2 определяет пространство имен *Mvc*, которое вложено в *Zend*,
и все классы этого компонента (включая класс `Application`, представленный в этом
примере в строках 7-10) принадлежат этому пространству имен. Вложенные пространства имен
разделяются обратным слешем. ('\\').

В других частях кода, вы ссылаетесь на класс `Application`, используя
его полностью определенное имя:

{line-numbers=off,lang="php"}
~~~
<?php
$application = new \Zend\Mvc\Application();
~~~

I> Обратите внимание на первый обратный слеш в имени `\Zend\Mvc\Application`
Если имя класса начинается с обратного слеша, значит, это имя - полностью определенное.
Если имя класса возможно специфицировать относительно текущего пространства имен, этот
обратный слеш не используется.

Также можно использовать *псевдонимы (aliases)* (короткие имена классов) с помощью
оператора `use`:

{line-numbers=off,lang="php"}
~~~
<?php
// Определяем псевдоним в начале сайта.
use Zend\Mvc\Application;

// Затем используем короткое имя класса.
$application = new Application();
~~~

T> Хотя псевдонимы позволяют использовать короткие имена классов,
T> использовать их необязательно - вы точно также можете обращаться к классу
T> по его полностью определенному имени.

Каждый PHP-файл приложения, как правило, определяет пространство имен
(кроме входного файла *index.php* и файлов конфигурации, они обычно этого не делают).
Например, главный модуль вашего сайта, *Application*, определяет свое собственное
пространство имен с одноименным названием:

{line-numbers=off,lang="php"}
~~~
<?php
namespace Application;

class Module 
{
    // ... элементы класса опущены для простоты ...
}
~~~

## Интерфейсы PHP

*Интерфейсы* в PHP позволяют определять, как будет вести себя класс без необходимости
описания этого поведения. Это также называется *контрактом*:  при создании интерфейса
класс соглашается с условиями контракта.

Интерфейсы широко распространены в Zend Framework 3. Например, класс `Application` реализует интерфейс
`ApplicationInterface`, определяющий методы, которые должен иметь каждый класс приложения:

{line-numbers=off,lang="php"}
~~~
<?php 
namespace Zend\Mvc;

interface ApplicationInterface
{
    // Возвращает менеджер сервисов.
    public function getServiceManager();

    // Возвращает объект HTTP-запроса.
    public function getRequest();

    // Возвращает объект HTTP-ответа.
    public function getResponse();

    // Запускает приложение.
    public function run();
}
~~~

Как видно из примера выше, интерфейс определяется с использованием ключевого слова `interface`, почти
так же, как определяется стандартный PHP-класс. Интерфейс, как и обычный класс, определяет методы.
Однако, интерфейс не предоставляет реализацию методов. Как видно из определения интерфейса `ApplicationInterface`
выше, каждое приложение с этим интерфейсом будет иметь метод `getServiceManager()` для возвращения
менеджера сервисов (о менеджере сервисов мы поговорим позже в этой главе), методы `getRequest()` и `getResponse()`
для возвращения соответственно HTTP-запроса и HTTP-ответа и метода `run()` для запуска приложения.


I> В Zend Framework 3 к именам интерфейсов принято добавлять суффикс `Interface`, например,
`ApplicationInterface`. 

Класс, реализующий интерфейс, называется *конкретным* классом. Конкретный класс `Application`
реализует `ApplicationInterface`, что означает, что он содержит реализацию методов, определенных
интерфейсом:

{line-numbers=off,lang="php"}
~~~
<?php 
namespace Zend\Mvc;

class Application implements ApplicationInterface
{
    // Реализация методов интерфейса
   
    public function getServiceManager() 
    {
        // Некая реализация...
    }

    public function getRequest() 
    {
       // Некая реализация...
    }

    public function getResponse() 
    {
       // Некая реализация...
    }

    public function run() 
    {
       // Некая реализация...
    }
}
~~~ 

Конкретный класс `Application` использует ключевое слово `implements`, чтобы показать, 
что он содержит реализацию всех методов интерфейса `ApplicationInterface`.
Класс `Application` также может иметь и другие методы, которые не являются
частью интерфейса.

Графически отношения классов изображаются с помощью диаграмм наследования. 
На рисунке 3.1 представлена такая диаграмма для класса `Application`. Стрелки
ведут от производного класса к родительскому.

![Рисунок 3.1. Диаграмма наследования класса Application](../en/images/operation/Application.png)
	
## Автозагрузка классов в PHP

Веб-приложение состоит из множества PHP-классов,  и каждый класс, как правило, располагается
в отдельном файле. Это приводит к необходимости *включения (including)* файлов.

Предположим, например, что у нас есть файл с именем *Application.php*, который
содержит определение класса `\Zend\Mvc\Application` из предыдущего раздела.
Перед тем как создать экземпляр этого класса где-либо в своем коде, вы должны
включить содержимое файла *Application.php* (это можно сделать с помощью оператора
`require_once`, передав ему полный путь к файлу):

{line-numbers=off,lang="php"}
~~~
<?php
require_once "/path/to/zendframework/zend-mvc/src/Application.php";

use Zend\Mvc\Application;

$application = new Application();
~~~

С увеличением размера вашего приложения включение каждого необходимого файла
может вызывать трудности. Сам Zend Framework 3 состоит из сотен файлов, и 
загружать целую библиотеку и все ее зависимости таким образом довольно сложно.
Более того, при запуске кода интерпретатору PHP потребуется процессорное время для
обработки каждого включенного файла, даже если вы не создавали экземпляр его класса.

Для решения этой проблемы в PHP была введена опция автозагрузки классов.
Функция `spl_autoload_register()` позволяет вам зарегистрировать функцию
*автозагрузки*. Для сложных сайтов можно даже создать несколько функций
автозагрузки, объединенные в стек.

Если интерпретатор PHP во время выполнения скрипта сталкивается с именем класса,
которое еще не было определено, он вызывает все зарегистрированные функции 
автозагрузки по порядку до тех пор, пока какая либо функция автозагрузки не включит класс. 
Если же ни одна из функций автозагрузки не сделает этого, будет выброшена ошибка "not found". 
Это делает возможным "ленивую" загрузку, при которой
интерпретатор обрабатывает определение класса только в момент его вызова - когда он
на самом деле нужен.

### Автозагрузчик карты классов

Чтобы дать вам представление о том, как выглядит функция автозагрузки, ниже мы
привели ее упрощенную реализацию:

{line-numbers=off,lang="php"}
~~~
<?php
// Функция автозагрузки.
function autoloadFunc($className) 
{
    // Статический массив карты классов.
    static $classMap = [
        '\\Zend\\Mvc\\Application' => '/path/to/zendframework/zend-mvc/src/Zend/Mvc/Application.php',
        '\\Application\\Module' => '/path/to/app/dir/module/Application/Module.php',
        //...
    ];

    // Проверяем, находится ли такое имя класса в карте классов.
    if(isset(static::$classMap[$className])) {
        $fileName = static::$classMap[$className];
  
        // Проверяем, существует ли файл и возможно ли его прочитать.
        if (is_readable($fileName)) {
            // Подлючаем файл.
            require $fileName;
        }
    }
}

// Регистрируем нашу функцию автозагрузки.
spl_autoload_register("autoloadFunc");
~~~

В примере выше мы определяем функцию автозагрузки `autoloadFunc()`, которую
в дальнейшем будем именовать автозагрузчиком *карты классов* (class map autoloader).

Автозагрузчик карты классов использует карту для определения соответствия между именем
класса и абсолютным путем к PHP-файлу, содержащему этот класс. Карта классов - это всего лишь
обычный PHP-массив, содержащий ключи и значения. Чтобы определить путь к файлу по имени класса,
автозагрузчику просто нужно взять значение из массива карты классов. Очевидно, что автозагрузчик
работает очень быстро. Однако, его минус в том, что вам необходимо поддерживать карту классов и
обновлять ее каждый раз при добавлении в программу нового класса.

### Стандарт PSR-4

Так как каждый поставщик библиотек использует свои собственные правила наименования и организацию файлов,
вам придется регистрировать свою функцию автозагрузки для каждой зависимой библиотеки, что, конечно,
может надоедать (и вообще, это ненужный труд). Чтобы решить эту проблему, был введен стандарт PSR-4.

I> PSR расшифровывается PHP Standards Recommendation (рекомендации стандартов PHP).

[Стандарт PSR-4](http://www.php-fig.org/psr/psr-4/) 
определяет рекомендованную структуру кода, которую приложение или библиотека должны соблюдать,
чтобы обеспечить совместимость механизмов автозагрузки.

* Пространства имен класса должны быть организованы следующим образом: 

  `\<Имя поставщика>\(<Пространство имен>)*\<Имя класса>`
  
* Пространства имен могут иметь любое желаемое количество уровней вложенности,
  но *имя поставщика* должно быть пространством имен верхнего уровня.

* Пространства имен должны иметь соответствие один к одному со структурой каталогов. Каждый разделитель пространств имен (`\`)
  конвертируется в константу `DIRECTORY_SEPARATOR`, отличную для разных ОС.

* К имени класса добавляется суффикс расширения *.php* при загрузке файла из файловой системы.

Например, для класса `Zend\Mvc\Application`, у вас будет следующая структура каталогов:

{line-numbers=off,lang="text"}
~~~
/path/to/zendframework/zend-mvc/src
  /Zend
    /Mvc
      Application.php
~~~

Недостатком данной структуры является то, что вам придется размещать свои классы внутри ряда вложенных пустых 
директорий (*Zend* и *Mvc*).

Чтобы исправить это, PSR-4 позволяет сопоставить последовательности одного или нескольких пространств и подпространств имен "базовый каталог". 
Например, если у вас есть полностью определенное имя класса `\Zend\Mvc\Application` и вы определяете соответствие
между `\Zend\Mvc` и каталогом "/path/to/zendframework/zend-mvc/src/", вы можете организовать файлы следующим образом:

```
/path/to/zendframework/zend-mvc/src
  Application.php
```
 
Для соответствующего стандарту PSR-4 кода, мы можем написать и зарегистрировать автозагрузчик,
который будем именовать "стандартным" автозагрузчиком:

{line-numbers=off,lang="php"}
~~~
<?php

// "Стандартный" автозагрузчик.
function standardAutoloadFunc($className) 
{
    // Заменить префикс пространства имен на базовую директорию.
    $prefix = '\\Zend\\Mvc';
    $baseDir = '/path/to/zendframework/zend-mvc/src/';
    if (substr($className, 0, strlen($prefix)) == $prefix) {
        $className = substr($className, strlen($prefix));
        $className = $baseDir . $className;
    }

    // Заменить разделители пространства имен на разделители директорий.
    $className = str_replace('\\', DIRECTORY_SEPARATOR, $className);
  
    // Добавить расширение .php.
    $fileName = $className . ".php";
  
    // Проверить, что файл существует и его можно прочесть.
    if (is_readable($fileName)) {
        // Включить файл.
        require $fileName;
    } 
}

// Register the autoloader function.
spl_autoload_register("standardAutoloadFunc");
~~~

Стандартный автозагрузчик работает следующим образом:
Предполагая, что пространство имен класса имеет соответствие один к одному со структурой каталогов,
функция вычисляет путь к PHP-файлу, преобразовывая обратные слеши (разделители пространств имен) в
прямые (разделители пути) и соединяя полученный путь с абсолютным путем к каталогу, где расположена
библиотека. Затем функция проверяет, существует ли уже такой PHP-файл, и, если он существует, включает
его с помощью оператора `require`.

Очевидно, что стандартный автозагрузчик работает медленнее, чем автозагрузчик карты классов.
Однако, его преимущество в том, что вам не нужно поддерживать карту классов, что очень удобно
при написании нового кода и добавлении новых классов к вашему приложению.

I> Zend Framework 3 работает в соответствии со стандартом PSR-4, что делает возможным 
I> автозагрузку всех его компонентов. Он также совместим с другими библиотеками, следующими
I> PSR-4, такими как Doctrine и Symfony.

### Автозагрузчик, предоставляемый Composer'ом

Composer может генерировать автозагрузчики (как автозагрузчик карты классов, так и стандартный PSR-4 автозагрузчик) для кода пакетов, которые он устанавливает.
Zend Framework 3 использует реализацию механизмов автозагрузки, предоставляемую Composer'ом. При установке пакетов
Composer автоматически создает файл *APP_DIR/vendor/autoload.php*,
использующий функцию `spl_autoload_register()`, чтобы зарегистрировать автозагрузчик. Таким образом, все PHP-классы,
находящиеся в каталоге `APP_DIR/vendor` , корректно загружаются автоматически.

Для автозагрузки PHP-классов, расположенных в ваших собственных модулях (например, в модуле `Application`), вам нужно будет
указать ключ `autoload` в файле `composer.json`:

{line-numbers=off,lang="json",title="Autoload key of composer.json file"}
~~~
"autoload": {
    "psr-4": {
        "Application\\": "module/Application/src/"
    }
},
~~~

Затем все, что нужно будет сделать, это включить этот файл во входном скрипте `index.php` вашего веб-сайта:

{line-numbers=off,lang="php"}
```
// Автозагрузка Composer'a
include __DIR__ . '/../vendor/autoload.php';
```

T> Файл *autoload.php* генерируется каждый раз как вы устанавливаете пакет с помощью Composer. Помимо этого, чтобы 
T> заставить Composer сгенерировать файл *autoload.php*, вы можете выполнить команду `dump-autoload`:
T> 
T> `php composer.phar dump-autoload`


### PSR-4 и структура исходных каталогов

В Zend Skeleton Application вы можете наблюдать стандарт PSR-4 на практике. 
Для стандартного модуля вашего сайта, модуля `Application`, PHP-классы, 
зарегистрированные стандартным автозагрузчиком, хранятся в каталоге `APP_DIR/module/Application/src` 
("src" - сокращение от "source" - "источник"). 

I> Мы будем называть каталог `src` исходным каталогом модуля.

Для примера рассмотрим файл `IndexController.php` модуля `Application` (рисунок 3.2). 

![Рисунок 3.2. Структура каталогов скелетного приложения соответствует стандарту PSR-4](../en/images/operation/psr0_and_dir_structure.png)

Как видите, он содержит класс `IndexController` [^контроллер], принадлежащий пространству имен `Application\Controller`. 
Чтобы соблюдать стандарт PSR-4 и использовать стандартный автозагрузчик с этим классом, 
нужно поместить его в директорию `Controller` в исходном каталоге модуля. 

[^контроллер]: Класс `IndexController` - это стандартный контроллер для скелетного сайта. 
               Мы будем говорить о контроллерах в главе [Модель-представление-контроллер](#mvc).

## HTTP-запрос и ответ

Когда пользователь сайта открывает веб-страницу в окне браузера, браузер генерирует запрос
и отсылает его через протокол HTTP веб-серверу. Сервер в свою очередь перенаправляет этот запрос
вашему приложению.

I> [HTTP](https://ru.wikipedia.org/wiki/HTTP) (расшифровывается как Hyper Text 
I> Transfer Protocol - "протокол передачи гипертекста") -- это протокол для передачи данных
I> в виде гипертекстовых документов (веб-страниц). HTTP основан на технологии "клиент-сервер":
I> клиент инициирует соединение и отсылает запрос веб-серверу, сервер ждет 
I> установки соединения, выполняет необходимые действия и посылает обратно ответ. 

Таким образом, главной целью, лежащей в основе любого веб-приложения, является обработка
HTTP-запроса и создание HTTP-ответа, обычно содержащего HTML-код запрашиваемый веб-страницы.
Ответ посылается сервером браузеру клиента, и браузер отображает веб-страницу на экране монитора.

Ниже представлен типичный HTTP-запрос:

{line-numbers=on,lang="text",title="An HTTP request example"}
~~~
GET http://www.w3schools.com/ HTTP/1.1
Host: www.w3schools.com
Connection: keep-alive
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) 
Accept-Encoding: gzip,deflate,sdch
Accept-Language: en-US;q=0.8,en;q=0.6
Cookie: __gads=ID=42213729da4df8df:T=1368250765:S=ALNI_MaOAFe3U1T9Syh; 
(empty line)
(message body goes here)
~~~

Этот HTTP-запрос состоит из трех частей:

* Начальная (первая) строка указывает метод запроса (т.е., GET или POST), строку URL 
  и версию протокола HTTP.
* Необязательные заголовки (строки 2-8) характеризуют сообщение, параметры передачи и предоставляют другую мета-информацию. 
  В этом примере каждая строка представляет из себя заголовок в виде *имя:значение*.
* Необязательное тело сообщения, содержащее его данные. Отделено от заголовков пустой строкой.
  
В запросе могут отсутствовать заголовки и тело сообщения, но он всегда содержит
начальную строку, потому что она указывает на его тип и URL.

Ответ сервера на этот запрос представлен ниже:

{line-numbers=on,lang="text",title="An HTTP response example"}
~~~
HTTP/1.1 200 OK
Cache-Control: private
Content-Type: text/html
Content-Encoding: gzip
Vary: Accept-Encoding
Server: Microsoft-IIS/7.5
Set-Cookie: ASPSESSIONIDQQRBACTR=FOCCINICEFAMEKODNKIBFOJP; path=/
X-Powered-By: ASP.NET
Date: Sun, 04 Aug 2013 13:33:59 GMT
Content-Length: 8434
(empty line)
(page content follows)
~~~

Как видите, HTTP-ответ имеет почти такой же вид, как и запрос:

* Начальная (первая строка) представляет собой версию протокола HTTP 
  и код статуса ответа (200 OK).

* Необязательные заголовки (строки 2-10) предоставляют различную мета-информацию об ответе.

* Необязательное тело сообщения, следующее за заголовками, должно быть отделено от них пустой строкой.
  оно, как правило, содержит HTML-код запрашиваемой веб-страницы

## Входной скрипт сайта

Когда веб-сервер Apache получает HTTP-запрос от браузера, он запускает
файл *APP_DIR/public/index.php*, также называемый *входной скрипт*.

I> Входной скрипт - это единственный PHP-файл, доступный для внешнего мира. Сервер
I> отравляет ему все HTTP-запросы (помните файл *.htaccess*?). Наличие такого
I> скрипта делает сайт более безопасным (по сравнению с ситуацией, когда 
I> вы позволяете всем иметь доступ к файлам вашего приложения). 

Хотя файл *index.php* является очень важным, он на удивление невелик (см. ниже):

{line-numbers=on,lang=php}
~~~
<?php

use Zend\Mvc\Application;
use Zend\Stdlib\ArrayUtils;

/**
 * Это облегчает нам работу с путями. 
 * Все пути теперь - относительно корня приложения.
 */
chdir(dirname(__DIR__));

// Отклонить запросы статического файла
if (php_sapi_name() === 'cli-server') {
    $path = realpath(__DIR__ . parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH));
    if (__FILE__ !== $path && is_file($path)) {
        return false;
    }
    unset($path);
}

// Автозагрузка Composer
include __DIR__ . '/../vendor/autoload.php';

if (! class_exists(Application::class)) {
    throw new RuntimeException(
        "Unable to load application.\n"
        . "- Type `composer install` if you are developing locally.\n"
        . "- Type `vagrant ssh -c 'composer install'` if you are using Vagrant.\n"
        . "- Type `docker-compose run zf composer install` if you are using Docker.\n"
    );
}

// Извлечение конфигурации
$appConfig = require __DIR__ . '/../config/application.config.php';
if (file_exists(__DIR__ . '/../config/development.config.php')) {
    $appConfig = ArrayUtils::merge($appConfig, require __DIR__ . '/../config/development.config.php');
}

// Запуск приложения!
Application::init($appConfig)->run();
~~~

В нем, главным образом, делаются три вещи.

Во-первых, в строке 10, действующий в данный момент каталог меняется на `APP_DIR`.
Это упрощает определение относительных путей файлов вашего приложения.
   
Во-вторых, в строке 22 инициируется класс автозагрузки. Это позволяет легко загружать любой класс,
находящийся либо в библиотеке Zend Framework, либо в вашем приложении, без необходимости использования
оператора `require_once`.

И в-третьих, в строке 40 создается экземпляр класса `Zend\Mvc\Application`.
Приложение инициализируется с настройками из файла конфигурации *application.config.php*
и запускается.

## События и жизненный цикл приложения

Как вы поняли из предыдущего раздела, с каждым HTTP-запросом создается объект `Zend\Mvc\Application`.
Обычно веб-приложение живет меньше секунды (этого времени достаточно, чтобы сгенерировать HTTP-ответ).
"Жизненный цикл" приложения состоит из нескольких этапов.

I> Zend Framework 3 использует понятие *событие*. Класс может *вызвать* событие,
I> и другие классы могут его *обработать*. Технически вызов события - это просто вызов 
I> функции обратного вызова ("callback") другого класса. Управление событиями реализовано
I> внутри компонента `Zend\EventManager`.

Каждый этап жизненного цикла приложения инициируется приложением путем вызова события (это событие
представлено классом `MvcEvent`, который "живет" в пространстве имен `Zend\Mvc`). Другие классы
(принадлежащие либо Zend Framework, либо вашему приложению) могут обработать события и отреагировать
соответствующим образом.
 
Ниже представлены пять основных этапов жизненного цикла приложения:

**Начальная загрузка (Bootstrap)**. При вызове этого события, модуль может зарегистрировать себя
как обработчика будущих событий приложения в своей функции обратного вызова `onBootstrap().` 

**Маршрутизация (Route)**. При вызове этого события, запрашиваемый URL анализируется с помощью класса *маршрутизации* (как правило, 
класса `Zend\Router\Http\TreeRouteStack`). Если удается найти полное совпадение между URL и маршрутом,
запрос передается классу *контроллера* этого маршрута.

**Отправка (Dispatch)**. Класс контроллера "отправляет" запрос, используя соответствующий метод действия и создает данные, 
которые могут быть отображены на веб-странице. 

**Рендеринг (Render)**. В этом событии данные, созданные методом действия контроллера, передаются для визуализации классу 
`Zend\View\Renderer\PhpRenderer`. Визуализатор использует файл
*шаблона представления* для создания HTML-страницы.

**Финиш (Finish)**. В этом событии HTTP ответ отправляется обратно клиенту.

Последовательность событий представлена на рисунке 3.3:

![Рисунок 3.3. Последовательность событий в течение жизненного цикла приложения](../en/images/operation/app_life_cycle.png)

T> Хотя это используется сравнительно редко, вы можете найти практические примеры обработки и реакции на событие в главе [Создание нового модуля](#modules)


## Конфигурация приложения

Большинство компонентов Zend Framework, используемых на вашем сайте, требуют 
конфигурации (тонкой настройки). Например, в файле конфигурации 
вы можете установить настройки подключения для базы данных, определить, какие
модули присутствуют в вашем приложении и добавить некоторые
пользовательские параметры.

Вы можете определить параметры конфигурации на двух уровнях: либо на уровне приложения,
либо на уровне модуля. На уровне приложения обычно определяются параметры, которые контролируют
всю программу и являются общими для всех модулей приложения. На уровне модуля определяются параметры,
которые затрагивают только этот модуль.

I> Некоторые PHP-фреймворки предпочитают принцип *соглашения превыше конфигурации* (Сonvention over Сonfiguration), при
I> котором большинство параметров жестко закодированы и не требуют конфигурации.
I> Это ускоряет разработку приложения, но делает его менее настраиваемым.
I> В Zend Framework 3 используется принцип *конфигурация превыше соглашений*,
I> то есть, вы можете настроить каждый аспект вашего приложения, но вам придется
I> потратить немного времени прежде, чем вы научитесь это делать.

### Файлы настройки на уровне приложения

Подкаталог *APP_DIR/config* содержит файлы конфигурации, действующие для всего приложения. Рассмотрим
этот подкаталог более детально (рисунок 3.4).

![Рисунок 3.4. Конфигурационные файлы](../en/images/operation/config.png)

Файл *APP_DIR/config/application.config.php* - это основной файл конфигурации.
Он используется приложением при запуске для определения, какие модули приложения должны быть
загружены и какие сервисы созданы по умолчанию.
        
Ниже представлено содержимое файла *application.config.file*. 
Как видите, файл конфигурации является обычным вложенным ассоциативным 
массивом, и каждый компонент этого массива может иметь особый ключ.
Вы можете оставить комментарии к этим ключам, чтобы другим было проще понять, что
означает каждый из них. 

T> Принято давать ключам имена в нижнем регистре, и, если имя ключа состоит из 
T> нескольких слов, их следует разделять нижним подчеркиванием ('_').

{line-numbers=on,lang=php, title="Content of application.config.php file"}
~~~
return [
    // Извлекаем список модулей, используемых в этом приложении.
    'modules' => require __DIR__ . '/modules.config.php',

    // Существует несколько вариантов для обработчиков, прикрепленных к ModuleManager
    'module_listener_options' => [
        // Это должен быть массив путей, в которых находятся модули.
        // Если есть строка с ключом, обработчик посчитает ее пространством имен модуля,
        // значение этого ключа - путем к классу 
        // Module этого модуля.
        'module_paths' => [
            './module',
            './vendor',
        ],

        // Массив путей, для которых используется функция glob (поиск пути к файлам) после
        // загрузки модуля. Таким образом, настройки, предоставляемые модулем, переопределяются.
        // Пути могут иметь флаг GLOB_BRACE.
        'config_glob_paths' => [
            realpath(__DIR__) . '/autoload/{{,*.}global,{,*.}local}.php',
        ],

        // Включать или нет кэш конфигурации.
        // Если он включен, файлы конфигурации после слияния будут кэшированы
        // и использованы при последующих запросах.
        'config_cache_enabled' => true,

        // Ключ, используемый для создания имени файла кэша конфигурации.
        'config_cache_key' => 'application.config.cache',

        // Включать или нет кэш карты классов модуля.
        // Если он включен, создается кэш карты классов модуля, который будет использоваться
        // при последующих запросах для сокращения времени автозагрузки.
        'module_map_cache_enabled' => true,

        // Ключ, используемый для создания имени файла кэша карты классов.
        'module_map_cache_key' => 'application.module.cache',

        // Путь, в который кэшируется конфигурация после слияния.
        'cache_dir' => 'data/cache/',

        // Включать или нет проверку зависимостей модулей (включена по умолчанию).
        // Это предотвращает использование модулей, который зависит от других, не
        // загруженных модулей.
        // 'check_dependencies' => true,
    ],

    // Используется для создания собственного менеджера сервисов. Может содержать один или несколько дочерних массивов.
    //'service_listener_options' => [
    //     [
    //         'service_manager' => $stringServiceManagerName,
    //         'config_key'      => $stringConfigKey,
    //         'interface'       => $stringOptionalInterface,
    //         'method'          => $stringRequiredMethodName,
    //     ],
    // ],

   // Начальная конфигурация, которая подается ServiceManager'у.
   // Должна быть совместима с Zend\ServiceManager\Config.
   // 'service_manager' => [],
];
~~~ 

В строке 3 у нас есть ключ *modules*, определяющий, какие модули будут загружены при запуске. Как вы видите,
имена модулей хранятся внутри другого файла конфигурации `modules.config.php`, который содержит список
всех модулей вашего сайта. 

В строке 11 находится ключ `module_paths`, который сообщает ZF3 о
каталогах, в которых нужно искать файлы источников, принадлежащие модулям. Модули приложения,
разрабатываемые вами, находятся в каталоге *APP_DIR/module*, а сторонние модули -
в каталоге *APP_DIR/vendor*.

Наконец, строка 19 содержит ключ `config_glob_paths`, который сообщает ZF3, где искать
дополнительные файлы конфигурации. Как видите, файлы из каталога *APP_DIR/config/autoload*
с суффиксами *global.php* или *local.php* загружаются автоматически.

Итак, как правило, вы используете главный файл настроек *application.config.php* для хранения информации 
о том, какие модули должны быть загружены, а также их местоположение и способ загрузки (здесь, например, вы
можете управлять настройками кэширования). В этом файле вы помимо этого можете настроить менеджер сервисов.
Не рекомендуется добавлять дополнительные ключи в этот файл. Для этой цели лучше использовать файл `autoload/global.php`.

Давайте также заглянем внутрь файла `modules.config.php`. На данный момент у вас
установлены следующие модули:

{line-numbers=off,lang=php, title="Content of modules.config.php file"}
~~~
return [
    'Zend\Session',
    'Zend\Mvc\Plugin\Prg',
    'Zend\Mvc\Plugin\Identity',
    'Zend\Mvc\Plugin\FlashMessenger',
    'Zend\Mvc\Plugin\FilePrg',
    'Zend\Form',
    'Zend\Router',
    'Zend\Validator',
    'Application',
];
~~~

Модуль `Application` - это модуль, содержащий файлы вашего приложения. Все остальные перечисленные модули - это
компоненты Zend Framework 3.

I> В ZF3 был представлен специальный плагин Composer'a, называемый *установщиком компонентов*. Если помните, в
главе [Zend Skeleton Application](#skeleton), мы отвечали на несколько вопросов об установщике, определяя,
какие компоненты устанавливать. И установщик вставил имена этих модулей здесь, в файле `modules.config.php`

### Дополнительные файлы конфигурации на уровне приложения

"Дополнительные" файлы конфигурации, *APP_DIR/config/autoload/global.php* и *APP_DIR/config/autoload/local.php*
определяют соответственно не зависимые и зависимые от окружения настройки, применимые для всего приложения.
Эти файлы конфигурации загружаются автоматически и рекурсивно сливаются с файлами конфигурации, предоставляемыми
модулями, поэтому их каталог называется *autoload*.

Имея несколько файлов конфигурации в каталоге *APP_DIR/config/autoload*, вы, возможно, запутаетесь
с тем, какие параметры в какой файл поместить. Вот несколько советов:

* Используйте файл *autoload/global.php* для хранения параметров, которые не зависят от
  окружения конкретной машины: например, тех, что переопределяют параметры по умолчанию некоторого модуля.
  Не храните здесь чувствительную информацию (такую как учетные данные базы данных), для этой цели
  лучше использовать *autoload/local.php*.

* Используйте файл *autoload/local.php* для хранения параметров, специфичных для
  конкретного окружения: например, учетные данные базы данных.
  У каждого разработчика обычно есть локальная база данных для разработки и тестирования веб-сайта.
  Таким образом, разработчик будет изменять файл учетные данные базы данных и вводить туда учетные данные
  своей БД. При установке сайта на "боевой" сервер (production server) файл `local.php` вновь изменяется,
  и в него записываются учетные данные "реальной" базы.

I> Так как файл *autoload/local.php* содержит зависимые от окружения параметры, 
I> в системе контроля версий вы храните его "шаблон распределения" *local.php.dist*.
I> Каждый разработчик вашей команды затем переименовывает файл *local.php.dist* в *local.php* и
I> вводит свои собственные параметры. Файл *local.php* не следует хранить под системой
I> контроля версий, потому что он может хранить чувствительную информацию вроде учетных данных 
I> БД (логины и пароли), и вы, скорее всего, не захотите, чтобы их увидели другие.     

### Файл конфигурации разработки на уровне приложения

С файлом конфигурации разработки (`APP_DIR/config/development.config.php`) вы столкнетесь при включении
*режима разработки*. Если помните, мы включали этот режим ранее в главе [Zend Skeleton Application](#skeleton).

I> Режим разработки включается следующей командой:
I>
I> `php composer.phar development-enable`

Файл `development.config.php` сливается с главным файлом `application.config.php`. Это позволяет вам
переопределить некоторые параметры. Например, вы можете:

  * отключить кэширование конфигурации. При разработке сайта вы часто изменяете ваши файлы настроек, поэтому
    кэширование конфигурации может иметь нежелательные последствия, например, неспособность сразу увидеть результат ваших изменений.
  * загрузить дополнительные модули. Например, вы можете загрузить модуль [ZendDeveloperTools](https://github.com/zendframework/ZendDeveloperTools) только в режиме разработки.   

Если вы выключите режим разработки, файл `development.config.php` будет удален. Поэтому хранить этот
файл под системой контроля версий не стоит. Вместо этого храните таким образом его вариант *распределения*, `development.config.php.dist`.

### Дополнительные файлы разработки на уровне приложения

Дополнительный файл конфигурации приложения в режиме разработки (`APP_DIR/config/autoload/development.local.php`) присутствует только тогда,
когда вы включаете *режим разработки*. 

Файл `development.local.php` сливается с другими файлами конфигурации уровня модуля. Это позволяет вам
переопределить некоторые параметры конфигурации в режиме разработки.

Если вы выключите режим разработки, файл `development.local.php` будет удален. Поэтому хранить этот
файл под системой контроля версий не стоит. Вместо этого храните таким образом его вариант *распределения*, `development.local.php.dist`.
 
### Файлы конфигурации на уровне модуля

Как видно из рисунка 3.4, у модуля *Application* есть файл *module.config.php*, в котором
хранятся параметры, специфичные для этого модуля. Взглянем на 
файл `module.config.php` модуля `Application`:

{line-numbers=off,lang=php, title="module.config.php file"}
~~~
<?php
namespace Application;

use Zend\Router\Http\Literal;
use Zend\Router\Http\Segment;
use Zend\ServiceManager\Factory\InvokableFactory;

return [
    'router' => [
        'routes' => [
            'home' => [
                'type' => Literal::class,
                'options' => [
                    'route'    => '/',
                    'defaults' => [
                        'controller' => Controller\IndexController::class,
                        'action'     => 'index',
                    ],
                ],
            ],
            'application' => [
                'type'    => Segment::class,
                'options' => [
                    'route'    => '/application[/:action]',
                    'defaults' => [
                        'controller'    => Controller\IndexController::class,
                        'action'        => 'index',
                    ],
                ],
            ],
        ],
    ],
    'controllers' => [
        'factories' => [
            Controller\IndexController::class => InvokableFactory::class,
        ],
    ],
    'view_manager' => [
        'display_not_found_reason' => true,
        'display_exceptions'       => true,
        'doctype'                  => 'HTML5',
        'not_found_template'       => 'error/404',
        'exception_template'       => 'error/index',
        'template_map' => [
            'layout/layout'           => __DIR__ . '/../view/layout/layout.phtml',
            'application/index/index' => __DIR__ . '/../view/application/index/index.phtml',
            'error/404'               => __DIR__ . '/../view/error/404.phtml',
            'error/index'             => __DIR__ . '/../view/error/index.phtml',
        ],
        'template_path_stack' => [
            __DIR__ . '/../view',
        ],
    ],
];
~~~

В этом файле вы регистрируете контроллеры модуля, помещаете в него информацию о правилах маршрутизации
для определения соответствия между URL и вашими контроллерами, регистрируете плагины контроллеров, а также 
регистрируете шаблоны представления и помощники представления (мы узнаем больше об этих терминах в этой и следующих главах).

### Объединение файлов конфигурации

При создании приложения, файлы конфигурации, предоставляемые модулем, и дополнительные файлы конфигурации из каталога
*APP_DIR/config/autoload* соединяются в один большой вложенный массив, так что каждый
параметр конфигурации становится доступным для каждой детали вашего сайта. 
Таким образом, у вас есть возможность переопределить любые параметры, заданные модулями.        

I> Возможно, вы видели "объединенный" файл конфигурации при установке PHP, где есть главный
I> файл *php.ini* и несколько дополнительных файлов конфигурации, включенных в него.
I> Такое разделение делает настройку вашего приложения многогранной и гибкой, 
I> потому что вам не нужно помещать все ваши параметры в один файл и изменять его
I> каждый раз, когда необходимо внести какие-то изменения.

Файлы конфигурации загружаются в следующем порядке:

* Главный файл *application.config.php* загружается первым. Он используется для инициализации
  менеджера сервисов и загрузки модулей приложения. Данные, загруженные из этого файла, хранятся
  отдельно и не сливаются с другими файлами конфигурации.

* Затем загружаются и объединяются файлы конфигурации для каждого модуля приложения.
  Модули загружаются в том же порядке, в котором они перечислены в файле *application.config.php*.
  Если два модуля хранят параметры в ключах с одинаковыми названиями (либо намеренно, либо по ошибке),
  эти параметры могут быть перезаписаны.
  
* Затем загружаются и объединяются в один массив дополнительный файлы конфигурации из каталога *APP_DIR/config/autoload*.
  Этот массив затем сливается с массивом конфигурации модуля, созданным на предыдущем этапе.
  Конфигурация на уровне приложения имеет более высокий приоритет, чем конфигурация модуля, поэтому здесь
  вы при желании можете переопределить ключи модулей.
  
## Точка входа модуля

В ZF3 ваше приложение состоит из модулей. По умолчанию у вас есть один единственный модуль `Application`, но вы можете создать
дополнительные модули, если нужно. Обычно ваши собственные модули хранятся в директории *APP_DIR/module*, в то время как
сторонние модули "живут" в директории *APP_DIR/vendor*. 

При старте создается объект `Zend\Mvc\Application`, и он использует компонент `Zend\ModuleManager`, чтобы найти и загрузить
все модули, зарегистрированные в конфигурации приложения.   

Каждый модуль веб-приложения имеет файл *Module.php*, который является своеобразной 
*точкой входа* для этого модуля. Этот файл содержит класс `Module`. Ниже
представлено содержимое класса `Module` скелетного приложения:

{line-numbers=off, lang=php, title="Contents of Module.php file"}
~~~
<?php 
namespace Application;

class Module
{
    public function getConfig()
    {
        return include __DIR__ . '/../config/module.config.php';
    }
}
~~~

Класс `Module` принадлежит пространству имен модуля (в случае с главным модулем, он
принадлежит пространству имен `Application`).

Метод `getConfig()` обычно используется, чтобы предоставить Zend Framework'у конфигурацию модуля (файл *module.config.php*).

I> Вы также можете зарегистрировать здесь *обработчики событий*, мы рассмотрим, как это
I> сделать в главе [Создание нового модуля](#modules)
  
## Менеджер сервисов

Веб-приложение можно представить как набор *сервисов*. Например,
у вас может быть сервис аутентификации, ответственный за вход пользователей на сайт,
менеджер сущностей, ответственный за доступ к базе данных, менеджер событий, ответственный
за вызов событий и их обработку, и т.д.

В Zend Framework класс `ServiceManager` - это централизованный *контейнер* для всех 
сервисов приложения. Менеджер сервисов  реализован в компоненте
`Zend\ServiceManager` в качестве класса `ServiceManager`. Диаграмма наследования классов приведена
на рис. 3.5 ниже:

![Рисунок 3.5. Диаграмма наследования классов менеджера сервисов](../en/images/operation/service_manager_inheritance.png) 

Менеджер сервисов создается при запуске приложения (внутри статического метода `init()`
класса `Zend\Mvc\Application`).
Стандартные сервисы, доступные через менеджер сервисов, представлены в таблице 3.1.
Эта таблица неполная, так как реальное число сервисов, зарегистрированных в менеджере
может быть намного больше.

{title="Table 3.1. Standard services"}
|----------------------|-----------------------------------------------------------------------|
| Имя сервиса          | Описание                                                              |
|----------------------|-----------------------------------------------------------------------|
| `Application`          | Позволяет извлечь единственный экземпляр класса `Zend\Mvc\Application`.|
|----------------------|-----------------------------------------------------------------------|
| `ApplicationConfig`    | Массив конфигурации из файла *application.config.php* file.           |
|----------------------|-----------------------------------------------------------------------|
| `Config`               | Объединенный массив конфигурации из файлов *module.config.php*,       |
|                      | *autoload/global.php* и *autoload/local.php*.                         |
|----------------------|-----------------------------------------------------------------------|
| `EventManager`       | Позволяет извлечь *новый* экземпляр класса `Zend\EventManager\EventManager`. |
|                      | Менеджер событий позволяет вызывать события и прикреплять обработчики. |
|----------------------|-----------------------------------------------------------------------|
| `SharedEventManager` | Позволяет извлечь единственный экземпляр класса `Zend\EventManager\SharedEventManager`. Общий (shared)  |
|                      | менеджер событий позволяет слушать события, определенные в других классах и компонентах. |
|----------------------|-----------------------------------------------------------------------|
| `ModuleManager`        | Позволяет извлечь единственный экземпляр класса `Zend\ModuleManager\ModuleManager`. |
|                      | Менеджер модулей отвечает за загрузку модулей приложения.             |
|----------------------|-----------------------------------------------------------------------|
| `Request`              | Единственный экземпляр класса `Zend\Http\Request`. Представляет собой HTTP-запрос, |
|                      | полученный от клиента.                                                |
|----------------------|-----------------------------------------------------------------------|
| `Response`             | Единственный экземпляр класса `Zend\Http\Response`. Представляет собой HTTP-ответ,  |
|                      | который будет отправлен клиенту.                                      |            
|----------------------|-----------------------------------------------------------------------|
| `Router`               | Единственный экземпляр класса `Zend\Router\Http\TreeRouteStack`. Осуществляет маршрутизацию URL. |
|----------------------|-----------------------------------------------------------------------|
| `ServiceManager`       | Собственно, сам менеджер сервисов.                                    |
|----------------------|-----------------------------------------------------------------------|
| `ViewManager`          | Единственный экземпляр класса `Zend\Mvc\View\Http\ViewManager`. Отвечает за |
|                      | подготовку слоя представления к визуализации страницы.                |
|----------------------|-----------------------------------------------------------------------|

Сервисом обычно является произвольный PHP-класс, но это не всегда так. Например, когда ZF3
загружает файлы конфигурации и объединяет данные во вложенные массивы, он сохраняет массивы
в менеджере сервисов как несколько сервисов (!): `ApplicationConfig` and `Config`. 
Первый - массив, загружаемый из файла конфигурации на уровне приложения *application.config.php*,
второй - объединенный массив из файлов конфигурации на уровне модулей и автоматически загруженных
файлов конфигурации на уровне приложения. Таким образом, в менеджере сервисов вы можете хранить
что хотите: PHP-класс, простую переменную или массив.

Из таблицы 3.1 видно, что в ZF3 все может считаться сервисом - даже сам менеджер сервисов.
Более того, класс `Application` также зарегистрирован, как сервис.  

I> Важная деталь о сервисах, на которую надо обратить внимание: они, как правило,
I> хранятся в единственном экземпляре (это называется шаблоном проектирования *одиночка* - *singleton*). Очевидно,
I> вам не нужен второй экземпляр класса `Application` (в этом случае
I> вам будут гарантированы кошмары). 

T> Однако есть важное исключение из выше приведенного правила. Сначало может показаться непонятным, но
T> сервис менеджера событий `EventManager` не хранится в единственном экземпляре. Каждый раз как вы извлекаете его из менеджера сервисов,
T> вы получаете *новый* объект. Это делается с целью улучшения производительности и во избежания возможных конфликтов событий между разными компонентами.
T> Мы обсудим это в разделе *О менеджере событий* позже в данной главе.

Менеджер сервисов определяет несколько методов, необходимых для нахождения сервиса
и его извлечения из менеджера (см. табл. 3.2 ниже).

{title="Таблица 3.2. Методы класса ServiceManager"}
|----------------------|-----------------------------------------------------------------------|
| Имя метода           | Описание                                                              |
|----------------------|-----------------------------------------------------------------------|
| `has($name)`         | Проверяет, зарегистрирован ли такой сервис.                           |
|----------------------|-----------------------------------------------------------------------|
| `get($name)`         | Извлекает экземпляр зарегистрированного сервиса.                      |
|----------------------|-----------------------------------------------------------------------|
| `build($name, $options)` | Всегда создает новый экземпляр запрошенного сервиса.              |
|----------------------|-----------------------------------------------------------------------|

Вы можете проверить, зарегистрирован ли сервис, передав его имя методу `has()`
менеджера сервисов. Он возвращает `true`, если сервис зарегистрирован, или `false`,
если сервис с таким именем не зарегистрирован.

Вы можете извлечь сервис по его имени позже с помощью
метода `get()` менеджера сервисов. Этот метод принимает один единственный параметр,
представляющий имя сервиса. Взглянем на следующий пример:

{line-numbers=off,lang=php}
~~~
<?php 

// Извлекает массив конфигурации приложения.
$appConfig = $serviceManager->get('ApplicationConfig');

// Использует его (например, извлекает список модулей).
$modules = $appConfig['modules'];
~~~		

И, наконец, метод `build()` всегда создает новый экземпляр сервиса, когда вы вызываете его (по сравнению с `get()`, который 
обычно создает экземпляр сервиса только один раз и возвращает его на все последующие запросы).

T> Обычно вы будете извлекать сервисы из менеджера сервисов не в *любом* месте вашего кода, а внутри *фабрики (factory)*. Фабрика - это код,
T> ответственный за создание объектов. Когда вы создаете объект, вы извлечете сервисы, от которых он зависит, 
T> и передадите эти сервисы (зависимости) конструктору объекта. Это также называется *внедрением зависимостей (dependency injection)*.

I> Если у вас есть опыт с Zend Framework 2, вы можете заметить, что все несколько изменилось. 
I> В ZF2 применялся шаблон `ServiceLocator`, позволяющий извлекать зависимости из менеджера сервисов в *любой* части приложения 
I> (в контроллерах, других сервисах, и т.д.) В ZF3 же вам придется передавать зависимости принудительно (explicitly). Это немного более утомительно, 
I> но удаляет "скрытые" зависимости и делает ваш код более легким в понимании.

### Регистрация сервиса

При написании веб-сайта, вам часто придется регистрировать ваш собственный сервис в менеджере
сервисов. Чтобы это сделать, один из способов - вызвать метод `setService()` менеджера сервисов. Давайте создадим и зарегистрируем
класс сервиса конвертера валют, который будет использоваться, например, на странице корзины покупок
для конвертации EUR->USD.

{line-numbers=on,lang=php}
~~~
<?php 
// Определяем пространство имен, где находится наш сервис.
namespace Application\Service;

// Определяем класс сервиса конвертера.
class CurrencyConverter 
{
    // Конвертирование евро в доллары.
    public function convertEURtoUSD($amount) 
    {
        return $amount*1.25;
    }
	
    //...
}
~~~

В строках 6-15 мы определяем класс `CurrencyConverter` (для упрощения он будет иметь
только один метод - метод конвертации валют `convertEURtoUSD()`).

{line-numbers=off,lang=php}
~~~
// Создаем экземпляр класса.
$service = new CurrencyConverter();
// Сохраняем его в менеджере сервисов.
$serviceManager->setService(CurrencyConverter::class, $service);
~~~

В примере выше мы инстанцируем класс с помощью оператора `new` и регистрируем его с помощью
метода менеджера сервисов `setService()` (мы полагаем, что переменная `$serviceManager` - 
типа класса `Zend\ServiceManager\ServiceManager` и была объявлена где-то еще). 

Метод `setService()` принимает два параметра: строку с именем сервиса и экземпляр сервиса.
Имя сервиса должно быть уникальным среди имен всех возможных сервисов. 

Как только сервис помещается в менеджер сервисов, вы можете извлечь его позже с помощью метода `get()`. Посмотрим на следующий пример:

{line-numbers=off,lang=php}
~~~
<?php 
// Извлекает менеджер конвертации валют.
$service = $serviceManager->get(CurrencyConverter::class);

// Использует его (конвертирует средства).
$convertedAmount = $service->convertEURtoUSD(50);
~~~		

### Имена сервисов

Разные сервисы могут использовать разные стили именования. Например, один и тот же
сервис конвертации валюты может быть зарегистрирован под разными именами: `CurrencyConverter`,
`currency_converter` и так далее. Чтобы применить некоторые правила формирования имен, рекомендуется регистрировать 
сервис, используя его полностью определенное имя, следующим образом:

{line-numbers=off,lang=php}
~~~
$serviceManager->setService(CurrencyConverter::class);
~~~

В примере выше мы используем ключевое слово `class`. Оно появилось в версии PHP 5.5 и используется 
для разрешения имен классов. Имя `CurrencyConverter::class` расширено до полностью определенного, 
как `\Application\Service\CurrencyConverter`.

### Переопределение существующего сервиса

Если вы попытаетесь зарегистрировать имя сервиса, которое уже существует, менеджер сервисов выбросит исключение. Однако иногда
вы хотите переопределить сервис с таким же именем (чтобы заменить его новым). Для этого вы
можете использовать метод `setAllowOverride()` менеджера сервисов:

{line-numbers=of,lang=php}
~~~
<?php 
// Позволяет заменять сервисы 
$serviceManager->setAllowOverride(true);

// Сохраняет экземпляр в менеджер сервисов. Исключения не будет,
// даже если есть другой сервис с таким именем.
$serviceManager->setService(CurrencyConverter::class, $service);
~~~

В коде выше метод `setAllowOverride()` берет один булевый параметр, определяющий, разрешать ли
замену сервиса `CurrencyConverter`, если такое имя уже существует, или нет.
		
### Регистрация вызываемых (invokable) классов		

Минус метода `setService()` в том, что необходимо создавать экземпляр сервиса до того,
как он на самом деле понадобится. Если вы не используете сервис вообще, инстанцирование
сервиса будет лишь тратой времени и памяти. Чтобы решить эту проблему, менеджер сервисов
предоставляет метод `setInvokableClass()`.

{line-numbers=off,lang=php}
~~~
<?php 
// Регистрация вызываемого класса
$serviceManager->setInvokableClass(CurrencyConverter::class);
~~~

В этом примере мы передаем менеджеру сервисов полностью определенное имя сервиса вместо того,
чтобы передавать его экземпляр. Таким образом, сервис будет инстанцирован менеджером только тогда, когда
кто-нибудь вызовет метод `get(CurrencyConverter::class)`. Это также называется ленивой загрузкой.

T> Сервисы часто зависят друг от друга. Например, сервис конвертера валюты может использовать сервис менеджера сущностей (entity manager), 
T> чтобы прочитать курсы валют из базы данных. Недостаток метода `setInvokableClass()` - то, что он не позволяет передавать параметры (зависимости)
T> сервису во время его инстанцирования. Чтобы разрешить эту проблему, вы можете использовать *фабрики (factories)*, как описано ниже.

### Регистрация фабрики

*Фабрика (factory)* - это класс, который может делать только одну вещь - создавать другие объекты других классов. 

Вы регистрируете фабрику для сервиса с помощью метода `setFactory()` менеджера сервисов:

Самая простая фабрика - это фабрика `InvokableFactory`, она аналогична вызову метода `setInvokableClass()` из предыдущей секции. 

{line-numbers=off,lang=php}
~~~
<?php 
use Zend\ServiceManager\Factory\InvokableFactory;

// Это эквивалентно вызову метода setInvokableClass() из предыдущего раздела.
$serviceManager->setFactory(CurrencyConverter::class, InvokableFactory::class);
~~~

После того как вы зарегистрировали фабрику, вы можете извлечь сервис из менеджера сервисов как обычно методом `get()`. Сервис будет
инстанцирован в момент извлечения (ленивая загрузка).

Иногда инстанцирование сервиса может быть сложнее, чем просто создание экземпляра сервиса через
оператор `new` (как делает фабрика `InvokableFactory`). Вам, возможно, придется передать некоторые параметры конструктору сервиса или вызвать
некоторые методы сервиса сразу после его создания. Эти сложные алгоритмы инстанцирования могут быть инкапсулированы
в вашу собственную фабрику. Как правило, класс фабрики реализует `FactoryInterface`:

{line-numbers=off,lang=php}
~~~
<?php
namespace Zend\ServiceManager\Factory;

use Interop\Container\ContainerInterface;

interface FactoryInterface
{
    public function __invoke(ContainerInterface $container, 
                        $requestedName, array $options = null);
}
~~~

Как видно из определения `FactoryInterface`, фабричный класс должен предоставлять магический
метод `__invoke` , возвращающий экземпляр одного сервиса. Менеджер сервисов передается
методу `__invoke` как параметр `$container`; он может использоваться при создании сервиса
для доступа к другим сервисам (для внедрения *зависимостей*). Второй аргумент (`$requestedName`) - это имя сервиса.
Третий аргумент (`$options`) может использоваться для передачи параметров сервису, и используется только когда вы 
извлекаете сервис с помощью метода `build()` менеджера сервисов.

Для примера давайте напишем фабрику для нашего сервиса конвертации валют (см. код ниже).
Мы не будем использовать сложные алгоритмы создания сервиса `CurrencyConverter`, но для более
тяжелых сервисов, вам, возможно, они понадобятся.

{line-numbers=off,lang=php}
~~~
<?php 
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\CurrencyConverter;

// Класс фабрики
class CurrencyConverterFactory implements FactoryInterface
{
    public function __invoke(ContainerInterface $container, 
                     $requestedName, array $options = null) 
    {
        // Создание экземпляра класса.
        $service = new CurrencyConverter();	
	
        return $service;
    }
}
~~~

I> Технически, в ZF3 вы *можете* использовать один и тот же класс фабрики для инстанциации нескольких сервисов, которые
I> имеют схожий код инстанциации (для этой цели вы можете использовать аргумент `$requestedName`, передаваемый методу `__invoke()` фабрики).
I> Однако, *в большинстве случаев* вы будете создавать новую фабрику для каждого отдельного сервиса. 

### Регистрация абстрактной фабрики

Возможен еще более сложный случай фабрики - когда вам нужно определить,
какие имена сервисов должны быть зарегистрированы во время выполнения.
В этой ситуации вы можете использовать *абстрактную фабрику*. Класс абстрактной
фабрики должен определять интерфейс `AbstractFactoryInterface`:

{line-numbers=off,lang=php}
~~~
<?php 
namespace Zend\ServiceManager\Factory;

use Interop\Container\ContainerInterface;

interface AbstractFactoryInterface extends FactoryInterface
{
    public function canCreate(ContainerInterface $container, $requestedName);
}
~~~

Абстрактная фабрика имеет два метода: `canCreate()`
и `__invoke()`. Первый нужен для проверки того, может ли фабрика создать
сервис с определенным именем. Второй позволяет, собственно, создать сервис.
Оба метода принимают два параметра: менеджер сервисов (`$container`) и имя сервиса (`$requestedName`).

По сравнению с обычным классом фабрики, разница состоит в том, что обычный класс *обычно* создает 
только один сервис, в то время как абстрактный может динамически создать столько
сервисов, сколько необходимо.

Вы можете зарегистрировать абстрактную фабрику с помощью метода `setAbstractFactory()` менеджера сервисов.

T> Абстрактные фабрики - это очень мощная вещь, но их нужно использовать только когда очень нужно,
T> поскольку они негативно влияют на производительность. Лучше использовать обычные (не абстрактные) фабрики.

### Регистрация псевдонима сервиса

Иногда вам понадобится создать *псевдоним* для сервиса. Псевдоним
похож на символьную ссылку: он ссылается на уже существующий сервис.
Для создания псевдонима используется метод менеджера сервисов `setAlias()`:

{line-numbers=off,lang=php}
~~~
<?php 
// Регистрируем псевдоним для сервиса CurrencyConverter
$serviceManager->setAlias('CurConv', CurrencyConverter::class);
~~~

После регистрации псевдонима вы можете извлечь сервис и по его имени, и по псевдониму,
используя метод `get()`.

### Общие (shared) и необщие (non-shared) сервисы

По умолчанию сервисы хранятся в менеджере сервисов в одном экземпляре (шаблон проектирования *singleton*). 
Например, когда вы два раза подряд извлекаете сервис `CurrencyConverter`, вы получите один и тот же объект.
Это называется *общим* (shared) сервисом.

Но в некоторых (редких) случаях, вам может понадобиться создавать *новый* экземпляр сервиса каждый раз как кто-нибудь
извлекает его из менеджера сервисов. Пример - сервис менеджера событий `EventManager` - вы получите новый экземпляр каждый
раз как вы извлекаете его.

Чтобы пометить сервис как non-shared, вы можете воспользоваться методом `setShared()` менеджера сервисов:

{line-numbers=off,lang=php}
~~~
$serviceManager->setShared('EventManager', false);
~~~ 

### Конфигурация менеджера сервисов

В вашем веб-сайте, вы будете обычно регистрировать сервисы в файле конфигурации (вместо вызова методов
сервис-менеджера, как было уже показано выше).

Для автоматической регистрации сервиса в менеджере, как правило, используется
ключ `service_manager` файла конфигурации. Вы можете поместить этот ключ либо
в файл конфигурации на уровне приложения, либо файл конфигурации на уровне модуля.

W> Если вы поместили этот ключ в файл конфигурации на уровне модуля, помните
W> об опасности перезаписи имени во время слияния конфигураций.
W> Не регистрируйте одинаковые имена сервисов в разных модулях.

Ключ `service_manager` должен выглядеть так:

{line-numbers=on,lang=php}
~~~
<?php 
return [
    //...

    // Регистрация сервисов под этим ключом
    'service_manager' => [
        'services' => [
            // Регистрация экземпляров классов сервисов
            //...
        ],
        'invokables' => [
            // Регистрация вызываемых классов
            //...
        ],
        'factories' => [
            // Регистрация фабрик
            //...
        ],
        'abstract_factories' => [
            // Регистрация абстрактных фабрик
            //...
        ],
        'aliases' => [
            // Регистрация псевдонимов сервисов
            //...
        ],
        'shared' => [
            // Укажите какие сервисы должны быть non-shared
        ]
    ],
  
    //...
];
~~~

Как видите в примере выше, ключ `service_manager` может содержать несколько
подключей для регистрации сервисов по-разному:

* подключ `services` (строка 7) позволяет зарегистрировать экземпляры классов;
* подключ `invokables` (строка 11) позволяет зарегистрировать полное имя класса сервиса;
  сервис будет инстанцирован с использованием ленивой загрузки;
* подключ `factories` (строка 15) позволяет зарегистрировать фабрику, которая сможет
  создавать экземпляры одного сервиса;
* `abstract_factories` (строка 19) может быть использован для регистрации абстрактных фабрик,
  которые могут регистрировать несколько сервисов по имени;
* подключ `aliases` (строка 23) предоставляет возможность зарегистрировать псевдоним для сервиса.
* подключ `shared` (строка 27) указывает какие сервисы должны быть non-shared.

В качестве примера давайте зарегистрируем наш сервис `CurrencyConverter` и псевдоним для него:

{line-numbers=off,lang=php}
~~~
<?php 
use Zend\ServiceManager\Factory\InvokableFactory;
use Application\Service\CurrencyConverter;

return [
    //...

    // Register the services under this key
    'service_manager' => [
        'factories' => [
            // Register CurrencyConverter service.
            CurrencyConverter::class => InvokableFactory::class
        ],
        'aliases' => [
            // Register an alias for the CurrencyConverter service.
            'CurConv' => CurrencyConverter::class
        ],        
  ],
  
  //...
];
~~~

## Менеджеры плагинов

Теперь, когда вы понимаете, что такое менеджер сервисов, понятие
*менеджеров плагинов* не должно вызывать трудностей. *Менеджер плагинов* - почти то же самое, что
и менеджер сервисов, но он может инстанцировать сервисы только одного типа. Какого - 
жестко закодировано в классе менеджера плагинов.

Зачем это может понадобиться? На самом деле, менеджеры плагинов широко используются в ZF3, так как они 
позволяют инстанцировать плагины только тогда, когда кто-то обращается к плагину (что экономит процессорное
время и память). Существуют отдельные менеджеры плагинов для:

  * контроллеров (класс `Zend\Mvc\Controller\ControllerManager`)
  * плагинов контроллеров (класс `Zend\Mvc\Controller\PluginManager`)
  * помощников представлений (класс `Zend\View\HelperPluginManager`)
  * элементов форм (класс `Zend\Form\FormElementManager\FormElementManagerV3Polyfill`) 
  * фильтров (класс `Zend\Filter\FilterPluginManager`)
  * валидаторов (класс `Zend\Validator\ValidatorPluginManager`)
  * и, возможно, чего-то другого
  
Так как любой менеджер плагинов наследуется от базового класса `Zend\ServiceManager\ServiceManager`,
все менеджеры плагинов могут иметь схожую конфигурацию. Например, контроллеры регистрируются под
ключом `controllers` в файле *module.config.php*, и у этого ключа могут быть те же подключи:
*services*, *invokables*, *factories*, *abstract_factories*, и *aliases*. Эту же структуру
имеет ключ *view_helpers*, используемый для регистрации помощников представлений, и ключ *controller_plugins*,
используемый для регистрации плагинов контроллера, и так далее.

## О менеджере событий

T> В этом разделе мы дадим продвинутую информацию о менеджере событий (event manager). Вы можете спокойно пропустить этот раздел,
   однако прочитайте его, если планируете создавать сложные обработчики событий.

Ранее в этой главе мы упомянули, что жизненный цикл приложения состоит из событий (*events*). 
Один класс может вызвать (*trigger*) событие, а другие классы могут обработать (*listen*) событие. Технически, вызов события означает просто напросто
вызов "callback" метода другого класса. Менеджер событий реализован внутри компонента `Zend\EventManager`.

T> Важно знать меру в использовании событий. Например, ZF3 (и в частности его компонент `Zend\Mvc`) сильно зависит от событий в своей работе, 
T> и по этой причине его исходный код - это "довольно сложная для понимания" комбинация обработчиков событий.
T> К счастью, в большинстве случаев вам не нужно понимать как ZF3 вызывает события и реагирует на них внутри своего кода, вам только нужно знать
T> что такое событие, какие события есть в жизненном цикле приложения и в чем разница между обычным *менеджером событий* и
T> *общим менеджером событий (shared event manager)*. 

### Event и MvcEvent

Событие (*event*) - это технически экземпляр класса `Zend\EventManager\Event`. 
Событие может иметь как минимум следующие части:

  * *имя* - уникально идентифицирует событие;
  * *цель (target)* - обычно это указатель на объект, который вызвал событие;
  * и *параметры* - аргументы, которые передаются обработчикам событий.

Также возможно создавать производные типы событий, расширяя класс `Event`.
Например, компонент `Zend\Mvc` определяет производный класс события `Zend\Mvc\MvcEvent`, 
который наследуется от класса `Event` и добавляет некоторые свойства и методы, которые нужны
для работы компонента `Zend\Mvc`.

### EventManager и SharedEventManager

Важно понимать разницу между *обычным* менеджером событий и *общим (shared)* менеджером событий.

Обычный менеджер событий не хранится в единственном экзепляре в менеджере сервисов. Каждый раз как вы извлекаете сервис `EventManager`
из менеджера сервисов, вы получаете новый экземпляр. На самом деле это делается для двух целей (приватность событий и производительность): 

  * Подразумевается по умолчанию, что класс, использующий менеджер событий для вызова событий будет использовать свой собственный экземпляр менеджера событий,
    поскольку он не хочет, чтобы другие классы автоматически могли слушать эти события. События, вызываемые классом, принадлежат приватно 
    этому классу.

  * Если все будут подписываться на события от всех классов, будет ад производительности - слишком много обработчиков событий 
    будут вызываться, увеличивая время загрузки страницы. Лучше избегать этого, оставив события по умолчанию приватными.
    
Но, в случае если кому-нибудь *нужно* намеренно подписаться на события *всех* или *только некоторых* классов, есть специальный *общий (shared)* менеджер событий. Сервис `SharedEventManager`
хранится в менеджере сервисов как синглтон, так что вы можете быть уверены, что все будут иметь только один его экземпляр.

С `SharedEventManager`ом, вы можете прикрепить обработчик событий к приватным событиям, вызываемым конкретным классом (или некоторыми классами).
Вы указываете уникальные идентификаторы классов, от которых вы хотите слушать события. Вот так просто!

T> Некоторые примеры того, как вы можете слушать и реагировать на события, можно найти в главах [Создание нового модуля](#modules)
T> и [Управление пользователями и аутентификация](#users).


## Выводы

В этой главе мы ознакомились с теорией основ работы сайта на базе ZF3.

ZF3 использует пространства имен PHP и автозагрузку классов, упрощая тем самым
разработку приложений, которые используют сторонние компоненты. Пространства имен позволяют
разрешать конфликты имен между компонентами кода и позволяют делать длинные имена короче.

Автозагрузка классов делает возможным использование любого PHP-класса в любой библиотеке, установленной с
Composer, без использования оператора `require_once`. Composer также предоставляет автозагрузчик PSR-4
для классов, расположенных в модулях вашего веб-приложения.

Большинство компонентов Zend Framework 3 требуют конфигурации. Вы можете определить параметры конфигурации либо
на уровне приложения, либо на уровне модулей. 

Главная цель любого веб-приложения - обработка HTTP-запроса и создание HTTP-ответа, содержащего,
как правило, HTML-код запрашиваемой веб-страницы. Когда веб-сервер Apache получает HTTP-запрос от
браузера клиента, он запускает файл *index.php*, который также называется скриптом входа на сайт.
Для каждого HTTP-запроса создается объект `Zend\Mvc\Application`, чей "жизненный цикл" состоит из нескольких
этапов (или событий).

Бизнес-логику веб-приложения можно рассматривать как набор сервисов. В Zend Framework 3 менеджер сервисов -
это централизованный контейнер для всех сервисов приложения. Сервис - это, как правило, PHP-класс, но,
в целом, это при необходимости может быть и переменная или массив.
