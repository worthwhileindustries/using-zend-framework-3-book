# Выгрузка файлов на сервер с помощью форм {#uploads}

В этой главе вы узнаете о выгрузке (uploading) файлов с помощью форм. Сперва мы рассмотрим такие основные моменты,
как возможность выгрузки файлов на сервер и передача данных в двоичной кодировке, а затем приведем рабочий пример
галереи изображений, показывающий, как выгружать изображения на веб-сервер.

Компоненты ZF3, рассматриваемые в этой главе:

|--------------------------------|---------------------------------------------------------------|
| *Компонент*                    | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Form`                    | Содержит базовые классы моделей форм.                         |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Filter`                  | Содержит различные классы фильтров.                           |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Validator`               | Реализует различные классы валидаторов.                       |
|--------------------------------|---------------------------------------------------------------|
| `Zend\InputFilter`             | Реализует контейнер для фильтров/валидаторов.                 |
|--------------------------------|---------------------------------------------------------------|

## О выгрузке файлов на сервер по протоколу HTTP

HTML-формы могут выгружать (upload) файлы сколь угодно больших размеров [^rfc-1867].
Файлы, как правило, передаются через HTTP-метод POST [^get].

[^rfc-1867]: Выгрузка файлов по HTTP описана в [RFC-1867](http://www.ietf.org/rfc/rfc1867.txt). Этот механизм
             позволяет выгружать большие файлы, используя бинарное кодирование передаваемых данных.
             Для этой цели используется тип кодировки "multipart/form-data".
             
[^get]: HTTP-метод GET неэффективен для выгрузки файлов, так как у длины URL есть предел.
        Кроме того, URL-кодирование данных файлов значительно увеличивает длину URL.

По умолчанию, HTTP использует *URL-кодирование* для передачи данных форм. Вы могли видеть 
это кодирование в предыдущих главах. Однако, оно неэффективно для выгрузки больших файлов,
так как такое кодирование бинарных данных сильно увеличивает длину HTTP-запроса. Для выгрузки
данных лучше использовать так называемое *бинарное транспортное кодирование (binary transfer encoding)*, рассматриваемое
в следующем разделе.
		
### Бинарное транспортное кодирование HTTP

Простая HTML-форма с возможностью выгрузки файлов показана в примере кода ниже. Бинарный тип кодирования
устанавливается заданием атрибута `enctype` формы со значением "multipart/form-data":

{line-numbers=on, lang=html}
~~~
<form action="upload" method="POST" enctype="multipart/form-data">
    <input type="file" name="myfile">
    <br/>
    <input type="submit" name="Submit">
</form>
~~~

В строке 1 мы явно задаем кодирование "multipart/form-data" (атрибут `enctype) для использования
эффективного бинарного кодирования передачи данных формы.

В строке 2 мы определяем поле ввода с типом "file" и именем "myfile". Это поле позволит
посетителям сайта выбирать файл для выгрузки.

Если вы сохраните представленную выше разметку в файл *.html* и откроете его в своем браузере,
вы увидите страницу как на рисунке 10.1.

![Рисунок 10.1. Простая HTML-форма с возможностью выгрузки файлов](../en/images/uploads/html_upload_form.png)

Элемент файла имеет кнопку поиска *Browse...* , которая позволяет выбрать файл для выгрузки.
После того как пользователь сайта выбрал файл и нажал кнопку отправки формы, веб-браузер посылает
веб-серверу HTTP-запрос, содержащий данные выгружаемого файла.
Пример ниже показывает, как может выглядеть HTTP-запрос:

{line-numbers=on, lang=text}
~~~
POST http://localhost/upload HTTP/1.1
Host: localhost
Content-Length: 488
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) 
Content-Type: multipart/form-data; boundary=----j1bOrwgLvOC3dy7o
Accept-Encoding: gzip,deflate,sdch

------j1bOrwgLvOC3dy7o
Content-Disposition: form-data; name="myfile"; filename="Somefile.txt"
Content-Type: text/html

(двоичные данные файла)
------j1bOrwgLvOC3dy7o
Content-Disposition: form-data; name="Submit"

Отправка запроса
------j1bOrwgLvOC3dy7o--
~~~

Как видите, HTTP-запрос с типом кодирования "multipart/form-data" выглядит аналогично обычному
HTTP-запросу (содержит строку статуса, заголовки и область содержимого), однако он имеет следующие
важные отличия:

* Строка 5 устанавливает заголовок Content-Type" со значением  "multipart/form-data". Форма собирается
  из полей, отмеченных "границами" -- уникальными случайно сгенерированными последовательностями символов,
  отделяющими поля формы друг от друга.
  
* Строки 8-17 представляют собой содержимое HTTP-запроса. Поля формы разделены "границами" (строки 8, 13, 17).
  Данные выгружаемого файла передаются в двоичном формате (строка 12), что позволяет уменьшить до минимума размер
  содержимого.

W> По умолчанию, настройки PHP-движка не позволяют выгружать большие файлы (больше 2МБ). Для выгрузки таких
W> файлов нужно изменить файл конфигурации *php.ini*, а также параметры `post_max_size` и `upload_max_filesize`.
W> О том, как это сделать, можете прочитать в [Приложение А. Организация среды веб-разработки.](#devenv). 
W> Установив эти настройки на `100M` позволит выгружать на сервер файлы размером до 100 Мб, и этого, как правило, будет достаточно. 
W> Если вы планируете выгрузку очень больших файлов вплоть до 1 ГБ, лучше задайте в настройках 1024М. 
W> Не забудьте перезапустить веб-сервер Apache после изменения файла конфигурации.

### Суперглобальный массив $_FILES в PHP 
  
При выгрузке посетителем сайта файлов на ваш веб-сервер Apache, эти файлы помещаются во временное хранилище
(обычно в системный временный каталог - */tmp* в Linux и *C:\\Windows\\Temp* в Windows).
PHP-скрипт принимает информацию о файле в специальный суперглобальный массив `$_FILES`.
  
I> Массив `$_FILES` аналогичен суперглобальным `$_GET` и `$_POST`. Два последних используются
I> для хранения переменных GET и POST соответственно, в то время как первый используется для
I> хранения информации о выгружаемых на сервер файлах.
  
Например, для вышеупомянутой формы выгрузки суперглобальный массив `$_FILES` будет выглядеть
следующим образом (выходные данные генерируются с помощью PHP-функции `var_dump()`):
  
{line-numbers=on, lang=text}
~~~
array (size=1)
    'myfile' => 
        array (size=5)
            'name' => string 'somefile.txt' (length=12)
            'type' => string 'text/plain' (length=10)
            'tmp_name' => string '/tmp/phpDC66.tmp' (length=16)
            'error' => int 0
            'size' => int 18
~~~

Как видите из этого примера, массив `$_FILES` содержит запись для каждого выгружаемого
на сервер файла. Для каждого файла он содержит следующую информацию:

  * `name` -- исходное имя файла (строка 4).
  * `type` -- MIME-тип [^mime] файла (строка 5).
  * `tmp_name` -- временное имя для выгружаемого файла (строка 6).
  * `error` -- код ошибки, сигнализирующий о статусе выгрузки (строка 7); 
     нулевой код ошибки означает, что файл был корректно выгружен на сервер.
  * `size` -- размер файла в байтах (строка 8).

[^mime]: MIME-тип (Multipurpose Internet Mail Extension - Многоцелевое расширение почты Интернета), также 
         известный как "тип содержимого" - стандартный идентификатор, используемый в Интернете для 
         указания типа данных, которые содержит файл. Например, MIME-тип "text/plain"
		 присваивается текстовому файлу, а MIME-тип "application/octet-stream" - бинарному.
  
PHP-движок хранит выгруженные файлы во временном хранилище, которое очищается, как только завершается
выполнение PHP-скрипта. Таким образом, если вы хотите сохранить выгруженные на сервер файлы в какой-нибудь
каталог для дальнейшего использования, нужно воспользоваться PHP-функцией `move_uploaded_file()`. Она
принимает два аргумента: первый - это имя временного файла, а второй - имя файла назначения.

T> Вы, наверное, не понимаете, почему нельзя использовать обычную PHP-функцию `rename()`, чтобы
T> переместить временный выгруженный файл в его путь назначения. Специальная функция для перемещения
T> выгруженных на сервер файлов существует в PHP из соображений безопасности. Функция `move_uploaded_file()` 
T> аналогична функции `rename()`, за исключением того, что она делает дополнительные проверки для гарантии того,
T> что файл на самом деле был передан через метод запроса POST и что процесс выгрузки на сервер завершился без ошибок.

Следующий фрагмент кода показывает, как перемещать файл, выгруженный на сервер с помощью простой формы,
которую мы рассмотрели выше:

{line-numbers=on, lang=php}
~~~
$destPath = '/path/to/your/upload/dir';
$result = move_uploaded_file($_FILES['myfile']['tmp_name'], $destPath);
if(!$result) {
    // Возникла какая-то ошибка.
}
~~~
  
В строке 1 этого примера мы задаем `$destPath` - имя каталога, куда нужно сохранить выгруженный файл.

В строке 2 мы вызываем функцию `move_uploaded_file()` и передаем ей два аргумента: путь к временному файлу
и путь назначения.
  
T> Передача имени каталога в качестве второго аргумента функции `move_uploaded_file()`
T> подходит для тех случаев, когда вы не хотите переименовывать файл. Если вам нужно сохранить выгруженный
T> файл под другим именем, можете вместо имени директории указать полный путь к файлу.

В строке 3 мы проверяем возвращаемое значение функции. При успешной операции функция
вернет `true`. Если произошли какие-либо ошибки (например, если прав доступа к каталогу
недостаточно для сохранения файла), вернется булевое `false`.
 
## Доступ к выгруженным на сервер файлам в ZF3

В классе контроллера вы, как правило, не взаимодействуете с массивом
`$_FILES` напрямую, вместо этого используется класс `Request` или
плагин контроллера `Params`, как показано в примере ниже:

{line-numbers=on, lang=php}
~~~
<?php 
//...
class IndexController extends AbstractActionController 
{
    // Пример действия контроллера, предназначенного для обработки выгруженный на сервер файлов.
    public function uploadAction() 
    {
        // Получаем массив $_FILES целиком.
        $files = $this->getRequest()->getFiles();
  
        // То же самое, но с помощью плагина контроллера Params.
        $files = $this->params()->fromFiles();
  
        // Получаем один элемент массива $_FILES.
        $files = $this->params()->fromFiles('myfile');
    }
}
~~~

В строке 9 приведенного выше кода мы вызываем метод `getRequest()` класса контроллера для доступа
к объекту `Request`, а также метод `getFiles()` объекта запроса для извлечения информации сразу о 
всех выгруженных на сервер файлах.

В строке 12 мы делаем то же самое с помощью плагина контроллера `Params`. Мы используем его метод
`fromFiles()`, чтобы получить информацию о всех выгруженных файлах.

При необходимости, можно извлечь информацию только об определенном файле. В строке 15 мы используем
тот же метод `fromFiles()` и передаем ему имя поля файла для извлечения. Таким образом можно извлечь
одну запись файла из суперглобального массива `$_FILES`.
  
## Выгрузка файлов на сервер и модель формы ZF3

Чтобы добавить возможность выгрузки файлов к модели формы, нужно добавить
элемент класса `Zend\Form\Element\File` таким образом:

{line-numbers=on, lang=php}
~~~
    // Добавьте следующий код в метод формы addElements().
  
    // Добавляем поле "file".
    $this->add([
            'type'  => 'file',
            'name' => 'file',
            'attributes' => [                
                'id' => 'file'
            ],
            'options' => [
            'label' => 'Upload file',
            ],
        ]);
~~~

В этом фрагменте мы вызываем метод `add()`, предоставляемый базовым классом `Form`,
и передаем ему массив конфигурации, описывающий элемент. Ключ массива `type` (строка 5)
должен быть либо именем класса `Zend\Form\Element\File`, либо его псевдонимом "file".

## Валидация выгруженных на сервер файлов

Выгруженные файлы нужно проверить на корректность, как и любые другие данные форм. Например,
вам нужно проверить, что:

  * файлы были на самом деле выгружены через HTTP-запрос методом POST, а не были просто скопированы из какого-либо каталога;
  
  * файлы были успешно выгружены (нулевой код ошибки);
  
  * имена файлов и/или их расширения допустимы (возможно, вы, например, хотите сохранять только JPEG-файлы и отклонять все остальные);
  
  * размер файла лежит в допустимом диапазоне (например, вы хотите гарантировать, что файл не слишком большой);
  
  * общее количество выгруженных на сервер файлов не превышает какой-то допустимый предел.

Для подобных проверок ZF3 предоставляет большое количество полезных валидаторов файлов (перечислены в таблице 10.1).
Эти классы валидаторов принадлежат компоненту `Zend\Validator` и "живут" в пространстве имен `Zend\Validator\File`.
  
{title="Таблица 10.1. Стандартные валидаторы файлов"}
|---------------------|------------------|---------------------------------------------------------------|
| *Имя класса*        | *Псевдоним*      | *Описание*                                                    |
|---------------------|------------------|---------------------------------------------------------------|
| `Count`             | `FileCount`      | Проверяет, находится ли количество файлов в заданном диапазоне (min, max). |
|---------------------|------------------|---------------------------------------------------------------|
| `WordCount`         | `FileWordCount`  | Подсчитывает количество слов в файле и проверяет, лежит ли оно в заданном диапазоне. |
|---------------------|------------------|---------------------------------------------------------------|
| `Upload`            | `FileUpload`     | Осуществляет проверки безопасности для гарантии того, что все файлы были выгружены на сервер через HTTP-запрос методом POST и не было ошибок выгрузки. |
|---------------------|------------------|---------------------------------------------------------------|
| `UploadFile`        | `FileUploadFile` | Осуществляет проверки безопасности для гарантии того, что файл был выгружен на сервер через HTTP-запрос методом POST и не было ошибок выгрузки. |
|----------------------------------------|---------------------------------------------------------------|
| `Size`              | `FileSize`       | Проверяет, лежит ли размер файла в заданном диапазоне.        |
|---------------------|------------------|---------------------------------------------------------------|
| `FilesSize`         | `FileFilesSize`  | Проверяет, что суммарный размер всех файлов лежит в заданном диапазоне. |
|---------------------|------------------|---------------------------------------------------------------|
| `Extension`         | `FileExtension`  | Проверяет, что расширение файла принадлежит списку допустимых расширений. |
|---------------------|------------------|---------------------------------------------------------------|
| `ExcludeExtension`  | `FileExcludeExtension` | Проверяет, что расширение файла НЕ принадлежит набору расширений. |
|---------------------|------------------|---------------------------------------------------------------|
| `MimeType`          | `FileMimeType`   | Проверяет, что MIME-тип принадлежит списку допустимых MIME-типов. |
|---------------------|------------------|---------------------------------------------------------------|
| `ExcludeMimeType`   | `FileExcludeMimeType` | Проверяет, что MIME-тип файла НЕ принадлежит списку MIME-типов. |
|---------------------|------------------|---------------------------------------------------------------|
| `IsImage`           | `FileIsImage`    | Проверяет, что файл является изображением (JPEG, PNG, GIF и т.д.) |
|---------------------|------------------|---------------------------------------------------------------|
| `ImageSize`         | `FileImageSize`  | Проверяет, что размерность файла изображения лежит в заданном диапазоне. |
|---------------------|------------------|---------------------------------------------------------------|
| `Exists`            | `FileExists`     | Проверка на то, что файл существует на диске.                 |
|---------------------|------------------|---------------------------------------------------------------|
| `NotExists`         | `FileNotExists`   | Проверка на то, что файл не существует на диске.             |
|---------------------|------------------|---------------------------------------------------------------|
| `IsCompressed`      | `FileIsCompressed` | Проверяет, что файл является архивом (ZIP, TAR, и т.д.)     |
|---------------------|------------------|---------------------------------------------------------------|
| `Hash`              | `FileHash`       | Проверяет, что содержимое файла соответствует заданному(-ым) хэшу(-ам). |
|---------------------|------------------|---------------------------------------------------------------|
| `Crc32`             | `FileCrc32`      | Проверяет, что содержимое файла имеет заданную контрольную сумму CRC32. |
|---------------------|------------------|---------------------------------------------------------------|
| `Sha1`              | `FileSha1`       | Проверяет, что содержимое файла имеет заданный SHA1-хэш.      |
|---------------------|------------------|---------------------------------------------------------------|
| `Md5`               | `FileMd5`        | Проверяет, что содержимое файла имеет заданный MD5-хэш.       |
|---------------------|------------------|---------------------------------------------------------------|

Как видите из таблицы, валидаторы можно приблизительно разделить на следующие группы:

 * валидаторы, проверяющие, что файлы действительно были выгружены через HTTP-запрос методом POST и что статус выгрузки файлов  - OK;
 * валидаторы, проверяющие количество выгруженных файлов и их размер;
 * валидаторы, проверяющие расширение и MIME-тип файлов;
 * валидаторы, проверяющие, является ли файл изображением, а также его размерность;
 * и валидаторы, проверяющие хэш файла (или контрольную сумма) [^хэш].

[^хэш]: Хэш файла используется для проверки целостности данных файла (например, для гарантии того,
        что данные файла не были повреждены). Существует несколько хэш-алгоритмов (MD5, SHA-1, CRC32 и др.)

T> Обратите внимание, что поскольку валидаторы файлов "живут" в пространстве имен `Zend\Validator\File`, их
T> псевдонимы (которые вы используете при создании валидатора с помощью фабрики) начинаются с префикса `File`. Например,
T> у валидатора `IsImage` псевдоним `FileIsImage`.
         
Мы покажем, как использовать некоторые из этих валидаторов файлов в примере галереи изображений *Image Gallery*
позже в этой главе.
		 
## Фильтрация выгружаемых на сервер файлов

Zend Framework 3 предоставляет несколько фильтров, предназначенных для "преобразования" полей файла. Классы
этих фильтров (перечислены в таблице 10.2) принадлежат компоненту `Zend\Filter` и "живут" в пространтсве имен `Zend\Filter\File`.

{title="Таблица 10.2. Стандартные фильтры файлов"}
|-----------------|---------------|---------------------------------------------------------------|
| *Имя класса*    | *Псевдоним*   | *Описание*                                                    |
|-----------------|---------------|---------------------------------------------------------------|
| `Rename`        | `FileRename`  | Переименовывает/перемещает произвольный файл.                 |
|-----------------|---------------|---------------------------------------------------------------|
| `RenameUpload`  | `FileRenameUpload` | Переименовывает/перемещает выгруженный файл с проверками безопасности. |
|-----------------|---------------|---------------------------------------------------------------|
| `Encrypt`       | `FileEncrypt` | Зашифровывает заданный файл и сохраняет содержимое зашифрованного файла. |
|-----------------|---------------|---------------------------------------------------------------|
| `Decrypt`       | `FileDecrypt` | Дешифрует заданный файл и сохраняет содержимое дешифрованного файла. |
|-----------------|---------------|---------------------------------------------------------------|
| `LowerCase`     | `FileLowerCase`| Переводит содержимое файла в нижний регистр.                 |
|-----------------|---------------|---------------------------------------------------------------|
| `UpperCase`     | `FileUpperCase`| Переводит содержимое файла в верхний регистр.                |
|-----------------|---------------|---------------------------------------------------------------|

Как видите из таблицы, валидаторы можно разделить на следующие группы:

  * фильтры для перемещения файлов из временного хранилища в их постоянный каталог;
  * фильтры для шифрования и дешифрования файлов;
  * фильтры для перевода текстовых файлов в верхний либо нижний регистр.

T> Обратите внимание, что поскольку фильтры файлов "живут" в пространстве имен `Zend\Filter\File`, их
T> псевдонимы (которые вы используете при создании фильтра с помощью фабрики) начинаются с префикса `File`. Например,
T> у фильтра `RenameUpload` псевдоним `FileRenameUpload`.  
  
Фильтры `Encrypt` and `Decrypt` позволяют применять к выгруженным на сервер файлам различные алгоритмы
шифрования/дешифрования (выбранный алгоритм можно добавить, указав определенный адаптер). Фильтры `LowerCase` и
`UpperCase` используются для перевода текста соответственно в нижний и верхний регистры [^четыре].
  
[^четыре]: По мнению автора, описанные выше четыре фильтра не особо полезны при работе с выгруженными
           на сервер файлами, так как необходимость шифрования выгруженного файла или его перевода в нижний (или верхний)
           регистр возникает довольно редко.

Фильтр `Rename` позволяет переименовать и/или переместить произвольный файл (не только выгруженные на сервер файлы).
Он внутренне использует PHP-функцию `rename()`, поэтому, в целом, использовать этот фильтр с выгруженными файлами
не рекомендуется из соображений безопасности.
		   
Фильтр `RenameUpload` выглядит гораздо полезнее остальных, так как он позволяет инкапсулировать вызов
функции `move_uploaded_file()` и переместить/переименовать файл из временного хранилища в его постоянный
каталог. Мы покажем, как использовать фильтр `RenameUpload` в примере галереи изображений *Image Gallery*
позже в этой главе.

## Контейнер InputFilter и выгрузка файлов на сервер

Как вы, возможно, помните, фильтры и валидаторы, присоединенные к модели формы, как правило,
хранятся в контейнере `InputFilter`, который состоит из *входов* (вход обычно представляет собой
класс `Input`, принадлежащий пространству имен `Zend\InputFilter). Для обычных полей формы фильтры
выполняются *перед* валидаторами, а валидаторы - *после* фильтров.

Однако, у выгрузки файлов на сервер есть несколько важных отличий:

  1. для хранения правил валидации для выгружаемых файлов вместо класса `Input` используется 
     специальный класс `FileInput`;
  2. и валидаторы применяются *перед* фильтрами (!).  
     	 
### FileInput 

Для хранения правил валидации для выгружаемых на сервер файлов, вместо обычного класса `Input`
нужно использовать класс FileInput`.

В private-методе модели формы `addInputFilter()` добавьте правила валидации файлового входа следующим образом:

{line-numbers=on, lang=php}
~~~
    $inputFilter->add([
        'type'     => 'Zend\InputFilter\FileInput',
        'name'     => 'file',  // Имя элемента.
        'required' => true,    // Является ли поле обязательным.
        'filters'  => [        // Фильтры.
            // Поместите сюда информацию о фильтрах.   
        ],                
        'validators' => [      // Валидаторы.
            // Поместите сюда информацию о валидаторах.
        ]        
      ]); 
~~~

В этом фрагменте мы задаем ключ "type" (строка 2) со значением `Zend\InputFilter\FileInput`. Остальные
ключи аналогичны тем, что мы использовали до этого при добавлении правил валидации к модели формы.

Поведение класса `FileInput` отличается от `Input` в следующих аспектах:

 1. Он ожидает данные, которые вы передаете в качестве входа, в формате массива `$_FILES` (запись массива
    с ключами `tmp_name`, `error`, `type`).
    
 2. Валидатор `Zend\Validator\File\Upload` автоматически добавляется в начало цепи валидаторов входных данных
    перед всеми остальными валидаторами.

 3. Валидаторы, добавленные в цепочку валидаторов входа, выполняются *перед* фильтрами, добавленными
    в цепочку фильтров. Это противоположно поведению класса `Input`.
  	
### Выполнение валидаторов перед фильтрами

Для обычных полей формы фильтры, как правило, выполняются *перед* валидаторами, а валидаторы - *после* фильтров.
Однако, при выгрузке файлов на сервер последовательность обратная.

I> При выгрузке файлов на сервер валидаторы выполняются *перед* фильтрами. Это поведение противоположно
I> обычному. 

При работе с выгруженными на сервер файлами, сперва нужно проверить, что данные, извлеченные
из суперглобального массива `$_FILES` корректны, и только затем делать с ними что угодно (перемещать
в каталог хранилища, переименовывать и т.д.). По этой причине валидаторы файлов должны запускаться
в первую очередь, а фильтры - в последнюю.

Рассмотрим, как это выполняется, вспомнив типичный рабочий процесс для формы: 

 * Сперва мы вызываем метод setData()`, чтобы заполнить форму данными.
 * Затем вызываем метод `isValid()` для выполнения фильтров и валидаторов в присоединенном к форме фильтре входных данных.
 * При успешной валидации вызываем метод `getData()` для извлечения отфильтрованных и валидированных данных из фильтра
   входных данных, присоединенного к форме.
 * При неудаче вызываем метод `getMessages()` для извлечения сообщений об ошибках.

Рабочий процесс при использовании `FileInput` такой же, однако важно понимать, что происходит
на каждом его этапе:

 * Вызываем метод setData()`, чтобы заполнить форму данными.
 * Вызываем метод `isValid()`, чтобы **выполнить валидаторы** в присоединенном к форме фильтре входных данных.
 * При успешной валидации вызываем метод `getData()`, чтобы **выполнить фильтры** и извлечь отфильтрованные
  и валидированные данные из фильтра входных данных, присоединенного к форме.
 * При неудаче вызываем метод `getMessages()` для извлечения сообщений об ошибках.
 
I> Обратите внимание на то, что для `FileInput` добавленные фильтры запускаются только если 
I> вызван метод `getData()`. 

При использовании и входов `Input`, и `FileInput` в фильтре входных данных формы (что является довольно распространенным случаем),
фильтры все равно выполняются первыми для обычных входов, однако для файловых входов первыми выполняются валидаторы.

## Действие контроллера и выгрузка файлов на сервер

В этом разделе мы приведем небольшой пример кода, показывающий, как обрабатывать выгрузку файлов на сервер
в методе действия контроллера. Мы привлечем внимание читателя к специфичным для выгрузки файлов аспектам.

Предположим, что мы хотим добавить веб-страницу, отображающую форму (назовем ее `YourForm`), которая
умеет выгружать файлы на сервер. Для этого нам нужно добавить в класс контроллера метод `uploadAction()`.

{line-numbers=on, lang=php}
~~~
<?php
//...
class IndexController extends AbstractActionController 
{
    // Действие "upload", отображающее страницу Upload.
    public function uploadAction() 
    {
        // Создаем модель формы.
        $form = new YourForm();
        
        // Проверяем, отправил ли пользователь форму.
        if($this->getRequest()->isPost()) {
            
            // Обязательно объедините информацию о файлах!
            $request = $this->getRequest();
            $data = array_merge_recursive(
                $request->getPost()->toArray(),
                $request->getFiles()->toArray()
            );
                
            // Передаем форме данные.
            $form->setData($data);
                
            // Выполняем валидаторы файлов.
            if($form->isValid()) {
                    
                // Выполняем фильтры файлов.
                $data = $form->getData();
                    
                // Перенаправляем пользователя на другую страницу.
                return $this->redirect()->toRoute('application', ['action'=>'index']);
            }                        
        } 
        
        // Визуализируем страницу.
        return new ViewModel([
                    'form' => $form
                ]);
    }
}
~~~

Как видите из этого фрагмента кода, `uploadAction()` выглядит как обычное действие контроллера,
реализующее типичный рабочий процесс формы, однако у него есть несколько специфичных для выгрузки
файлов на сервер аспектов (отмечены **жирным** шрифтом):

  * В строке 9 мы создаем экземпляр модели формы `YourForm` с помощью оператора `new`.

  * В строке 12 мы проверяем, является ли запрос HTTP-запросом методом POST. Если это так,
    мы **получаем данные из суперглобальных PHP-массивов `$_POST` и `$_FILES и объединяем 
	их в один массив (строки 15-19). Это необходимо для корректной обработки выгруженных на
	сервер файлов, если таковые имеются. Затем мы передаем этот массив модели формы с помощью
	метода `setData()` (строка 22)**.
  
  * В строке 25 мы вызываем метод модели формы `isValid()`. Он запускает фильтр входных
    данных, присоединенный к модели формы. Для входов `FileInput` **этот метод выполнит
	только присоединенные валидаторы**.

  * Если данные действительны, мы вызываем метод `getData()` (строка 28). Для входов `
    FileInput` **этот запустит присоединенные фильтры**. Фильтры файлов могут, к примеру,
	перемещать выгруженные на сервер файлы в их постоянный каталог.

  * В случае успеха мы перенаправляем пользователя к действию контроллера "index" (строка 31).
  
I> При работе с этим действием контроллера следует помнить три вещи: 1) объединяйте суперглобальные
I> массивы $_POST` и `$_FILES` перед тем, как передать их методу формы `setData()`; 2) используйте
I> метод формы `isValid()` для проверки выгружаемых файлов на корректность (то есть, запускайте валидаторы);
I> 3) используйте метод формы `getData()` для запуска фильтров файлов.
 
## Пример: Image Gallery

Для демонстрации использования выгрузки файлов на сервер в Zend Framework 3, мы создадим галерею
изображений, которая будет состоять из двух веб-страниц: страницы для выгрузки изображений (рисунок 10.2);
и страницы галереи, содержащей список выгруженных изображений (рисунок 10.3).

T> Рабочий пример такой галереи *Image Gallery* можно посмотреть в приложении *Form Demo*, которое
T> идет вместе с этой книгой.

{width=80%}
![Рисунок 10.2. Страница выгрузки изображений](../en/images/uploads/upload_image_form.png)

{width=80%}
![Рисунок 10.3. Страницы галереи изображений](../en/images/uploads/image_gallery.png)

Для этого мы примера мы создадим следующее:
  
  * модель формы `ImageForm` с возможностью выгрузки файлов на сервер;
  * класс сервиса `ImageManager`, предназначенный для получения списка выгруженных изображений, извлечения информации об изображении и изменения его размера.
  * класс `ImageController`, который будет содержать обслуживающие веб-страницу методы действия;
  * фабрику `ImageControllerFactory`, которая будет инстанцировать контроллер и внедрять в него зависимости;
  * файл шаблона представления`.phtml` для каждого метода действия контроллера.

### Добавление модели FormModel

Для этого примера нам понадобится модель формы, которая будет использоваться для выгрузки файлов изображений.
Назовем класс этой модели формы `ImageForm`. Этот класс позволит нам выгружать на сервер файлы изображений.
Форма будет иметь следующие поля:

  * поле `file` позволит пользователю выбрать файл изображения для выгрузки;
    
  * кнопка `submit`, позволяющая отправить данных формы на сервер.

Ниже представлен код модели формы `ImageForm. Его нужно поместить в файл *ImageForm.php*, хранящийся
в каталоге *Form* под корневым каталогом модуля:
  
{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Form;

use Zend\Form\Form;

// Эта форма используется для выгрузки файлов изображений.
class ImageForm extends Form
{
    // Конструктор.     
    public function __construct()
    {
        // Определяем имя формы.
        parent::__construct('image-form');
     
        // Устанавливаем метод POST для этой формы.
        $this->setAttribute('method', 'post');
                
        // Задаем бинарное кодирование содержимого.
        $this->setAttribute('enctype', 'multipart/form-data');
				
        $this->addElements();        
    }
    
    // Этот метод добавляет элементы к форме.
    protected function addElements() 
    {
        // Add "file" field.
        $this->add([
            'type'  => 'file',
            'name' => 'file',
            'attributes' => [                
                'id' => 'file'
            ],
            'options' => [
                'label' => 'Image file',
            ],
        ]);        
          
        // Добавляем кнопку отправки формы..
        $this->add([
            'type'  => 'submit',
            'name' => 'submit',
            'attributes' => [                
                'value' => 'Upload',
                'id' => 'submitbutton',
            ],
        ]);               
    }
}
~~~

Мы уже рассмотрели создание модели формы, и приведенный выше код не должен вызывать каких-либо
проблем в его понимании. Мы лишь хотим обратить внимание читателя на то, что в строке 19 мы
задаем значение "multipart/form-data" для атрибута формы "enctype", чтобы формой использовалось
бинарное кодирование ее данных.

T> Вообще говоря, явно задавать атрибут "enctype" в конструкторе формы необязательно, так как 
T> элемент `Zend\Form\Element\File` делает это автоматически, когда вы вызываете метод формы
T> `prepare()`.

### Добавление правил валидации к модели ImageForm

Для демонстрации использования валидаторов и фильтров, предназначенных для работы с выгрузкой
файлов на сервер, мы добавим их к классу модели формы `ImageForm`. Мы хотим добиться следующих целей:

 * проверять, действительно ли файл был выгружен на сервер через HTTP-запрос методом POST, используя валидатор `UploadFile`;
 * проверять, что выгруженный файл является изображением (JPEG, PNG, GIF и т.д.), используя валидатор `IsImage`;
 * проверять, что размерность изображения находится внутри какиз-то допустимых границ; это мы сделаем с помощью валидатора `ImageSize`;
 * перемещать выгруженный на сервер файл в его постоянный каталог, используя фильтр `RenameUpload`.

Чтобы добавить правила валидации, измените код класса `ImageForm` следующим образом:
 
{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Form;

use Zend\InputFilter\InputFilter;

// Эта форма используется для выгрузки файлов изображений.
class ImageForm extends Form
{
    // Конструктор
    public function __construct()
    {
        // ...
	
        // Добавляем правила валидации
        $this->addInputFilter();          
    }
  
    // ...
	
    // Этот метод создает фильтр входных данных (используется для фильтрации/валидации формы).
    private function addInputFilter() 
    {
        $inputFilter = new InputFilter();   
        $this->setInputFilter($inputFilter);
     
        // Добавляем правила валидации для поля "file".	 
        $inputFilter->add([
                'type'     => 'Zend\InputFilter\FileInput',
                'name'     => 'file',
                'required' => true,   
                'validators' => [
                    ['name'    => 'FileUploadFile'],
                    [
                        'name'    => 'FileMimeType',                        
                        'options' => [                            
                            'mimeType'  => ['image/jpeg', 'image/png']
                        ]
                    ],
                    ['name'    => 'FileIsImage'],
                    [
                        'name'    => 'FileImageSize',
                        'options' => [
                            'minWidth'  => 128,
                            'minHeight' => 128,
                            'maxWidth'  => 4096,
                            'maxHeight' => 4096
                        ]
                    ],
                ],
                'filters'  => [                    
                    [
                        'name' => 'FileRenameUpload',
                        'options' => [  
                            'target'=>'./data/upload',
                            'useUploadName'=>true,
                            'useUploadExtension'=>true,
                            'overwrite'=>true,
                            'randomize'=>false
                        ]
                    ]
                ],   
            ]);                
    }
}
~~~

В этом фрагменте мы добавляем следующие валидаторы файлов:

  *  Валидатор `UploadFile` (строка 32) проверяет, действительно ли файл был выгружен на
     сервер через HTTP-запрос методом POST.

  *  Валидатор `MimeType` (строка 34) проверяет, является ли выгруженный файл изображением JPEG или PNG.
     Это осуществляется извлечением из данных файлов информации MIME.  
     
  *  Валидатор `IsImage` (строка 39) проверяет, является ли выгруженный файл изображением (PNG, JPG, 
     GIF и т.д.). Это осуществляется извлечением из данных файлов информации MIME.

  *  Валидатор `ImageSize` (строка 41) позволяет проверить, что размерность изображения лежит в допустимом. 
     диапазоне. В коде выше мы проверяем, что и ширина, и высота изображения - от 128 до 4096 пикселей.
	 
В строке 52 мы добавляем фильтр `RenameUpload` и настраиваем его таким образом, чтобы выгруженный
на сервер файл сохранялся в каталог *APP_DIR/data/upload*. Этот фильтр будет использовать одинаковое
имя для файла назначения и исходного файла (опция `useUploadName`). Если файл с таким именем уже
существует, фильтр его перезапишет (опция `overwrite`).
	 
W> Для работы валидаторов `MimeType` и `IsImage` нужно подключить расширение PHP `fileinfo`. Это расширение уже
W> подключено в Linux Ubuntu, но не подключено в Windows. После этого не забудьте перезапустить HTTP-сервер Apache.
     
### Написание сервиса ImageManager

Так как мы стараемся писать код, соответствующий паттерну предметно-ориентированного проектирования
(Domain Driven Design), мы создадим класс модели сервиса, инкапсулирующий функциональность для управления
изображениями. Мы назовем этот класс `ImageManager` и поместим его в пространство имен `Application\Service`.
Также мы зарегистрируем этот сервис в менеджере сервисов веб-приложения.

Класс сервиса `ImageManager` будет иметь следующие public-методы (перечислены в таблице 10.3):

{title="Таблица 10.3. Public-методы класса ImageManager."}
|---------------------------------|------------------------------------------------------------------|
| *Метод*                         | *Описание*                                                       |
|---------------------------------|------------------------------------------------------------------|
| `getSaveToDir()`                | Возвращаем путь к каталогу, куда мы сохраняем файлы изображений. |
|---------------------------------|------------------------------------------------------------------|
| `getSavedFiles()`               | Возвращает массив имен сохраненных файлов.                       |
|---------------------------------|------------------------------------------------------------------|
| `getImagePathByName($fileName)` | Возвращает путь к сохраненному файлу изображения.                |
|---------------------------------|------------------------------------------------------------------|
| `getImageFileInfo($filePath)`   | Извлекает информацию о файле (размер, MIME-тип) по его пути.     |
|---------------------------------|------------------------------------------------------------------|
| `getImageFileContent($filePath)`| Возвращает содержимое файла изображения. При ошибке возвращает булевое false. |
|---------------------------------|------------------------------------------------------------------|
| `resizeImage($filePath, $desiredWidth)` | Изменяет размер изображения, сохраняя соотношение сторон.|
|---------------------------------|------------------------------------------------------------------|

T> На самом деле, мы могли бы поместить код, который планировали добавить в сервис, в действия контроллера,
T> но это бы сделало контроллер толстым и полностью тестируемым. С помощью класса сервиса мы улучшаем принцип
T> разделения ответственностей и возможность повторного использования кода.

Добавим файл *ImageManager.php* в каталог *Service* под корневым каталогом
модуля. В этот файл поместим следующий код:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Service;

// Сервис менеджера изображений.
class ImageManager 
{
    // Каталог, куда мы сохраняем файлы изображений.
    private $saveToDir = './data/upload/';
        
    // Возвращаем путь к каталогу, куда мы сохраняем файлы изображений.
    public function getSaveToDir() 
    {
        return $this->saveToDir;
    }  
}
~~~

Как видите из фрагмента выше, мы определяем класс `ImageManager` в строке 5. У него есть private-свойство
`$saveToDir` [^свойство], которое содержит путь к каталогу, где находятся выгруженные на сервер файлы (строка 8)
(мы храним выгруженные файлы в каталоге *APP_DIR/data/upload*).

Public-метод `getSaveToDir()` (строка 11) позволяет извлечь путь к каталогу выгрузки.

[^property]: Хотя класс `ImageManager` является сервисом, он может иметь свойства, 
             предназначенные для внутреннего использования.

Далее, мы хотим добавить public-метод `getSavedFiles()` к классу сервиса. Этот метод будет просматривать
каталог выгрузки и возвращать массив, содержащий имена выгруженных на сервер файлов. Чтобы добавить метод
`getSavedFiles()`, измените код таким образом:
            
{line-numbers=on, lang=php}
~~~
<?php
//...

// Сервис менеджера изображений.
class ImageManager 
{
    //...
  
    // Возвращает массив имен выгруженных на сервер файлов.
    public function getSavedFiles() 
    {
        // Каталог, куда мы планируем сохранять выгруженные файлы..
        
        // Проверяем, существует ли уже каталог, и, если нет, то
        // создаем его.
        if(!is_dir($this->saveToDir)) {
            if(!mkdir($this->saveToDir)) {
                throw new \Exception('Could not create directory for uploads: ' . 
                             error_get_last());
            }
        }
        
        // Просматриваем каталог и создаем список выгруженных файлов. 
        $files = [];        
        $handle  = opendir($this->saveToDir);
        while (false !== ($entry = readdir($handle))) {
            
            if($entry=='.' || $entry=='..')
                continue; // Пропускаем текущий и родительский каталоги.
            
            $files[] = $entry;
        }
        
        // Возвращаем список выгруженных файлов.
        return $files;
    }  
}
~~~             

Выше, в методе `getSavedFiles()` мы сперва проверяем, существует ли каталог (строка 16), и, если нет,
то пытаемся его создать (строка 17). Затем мы получаем список файлов в каталоге (строки 24-32) и
и возвращаем его.

После этого, добавим три метода для получения информации о выгруженном на сервер файле: 
 
  * метод `getImagePathByName()` будет принимать имя файла и добавлять в начало этого имени путь 
    к каталогу выгрузки.
    
  * метод `getImageFileInfo()` будет извлекать информацию MIME о файле и его размер в байтах;
  
  * и `getImageFileContent()` будет читать данные файла и возвращать их в виде строки.
  
Чтобы добавить эти методы, внесите следующие изменения в код:
  
{line-numbers=on, lang=php}
~~~
<?php
//...

// Сервис менеджера изображений.
class ImageManager 
{
    //...  
  
    // Возвращает путь к сохраненному файлу изображения.
    public function getImagePathByName($fileName) 
    {
        // Принимаем меры предосторожности, чтобы сделать файл безопасным.
        $fileName = str_replace("/", "", $fileName);  // Убираем слеши.
        $fileName = str_replace("\\", "", $fileName); // Убираем обратные слеши.
                
        // Возвращаем сцепленные имя каталога и имя файла.
        return $this->saveToDir . $fileName;                
    }
  
    // Возвращает содержимое файла изображения. При ошибке возвращает булевое false. 
    public function getImageFileContent($filePath) 
    {
        return file_get_contents($filePath);
    }
    
    // Извлекает информацию о файле (размер, MIME-тип) по его пути.
    public function getImageFileInfo($filePath) 
    {
        // Пробуем открыть файл        
        if (!is_readable($filePath)) {            
            return false;
        }
            
        // Получаем размер файла в байтах.
        $fileSize = filesize($filePath);

        // Получаем MIME-тип файла.
        $finfo = finfo_open(FILEINFO_MIME);
        $mimeType = finfo_file($finfo, $filePath);
        if($mimeType===false)
            $mimeType = 'application/octet-stream';
    
        return [
            'size' => $fileSize,
            'type' => $mimeType 
        ];
    }  
}
~~~
             
И наконец, мы хотим добавить функциональность для изменения размера в класс `ImageManager`. Этот набор
функций будет использоваться для создания миниатюр изображений. Добавим метод `resizeImage()` к классу
`ImageManager` следующим образом:
			
{line-numbers=on, lang=php}
~~~
<?php
//...
class ImageManager 
{
    //...    
  
    //  Изменяет размер изображения, сохраняя соотношение сторон.
    public  function resizeImage($filePath, $desiredWidth = 240) 
    {
        // Получаем исходную размерность файла.
        list($originalWidth, $originalHeight) = getimagesize($filePath);

        // Вычисляем соотношение сторон.
        $aspectRatio = $originalWidth/$originalHeight;
        // Вычисляем получившуюся высоту.
        $desiredHeight = $desiredWidth/$aspectRatio;

        // Получаем информацию об изображении
        $fileInfo = $this->getImageFileInfo($filePath);
        
        // Изменяем размер изображения.
        $resultingImage = imagecreatetruecolor($desiredWidth, $desiredHeight);
        if (substr($fileInfo['type'], 0, 9) =='image/png')
            $originalImage = imagecreatefrompng($filePath);
        else
            $originalImage = imagecreatefromjpeg($filePath);
        imagecopyresampled($resultingImage, $originalImage, 0, 0, 0, 0, 
                $desiredWidth, $desiredHeight, $originalWidth, $originalHeight);

        // Сохраняем измененное изображение во временное хранилище.
        $tmpFileName = tempnam("/tmp", "FOO");
        imagejpeg($resultingImage, $tmpFileName, 80);
        
        // Возвращаем путь к получившемуся изображению.
        return $tmpFileName;
    }
}
~~~

Метод `resizeImage()` принимает два аргумента: `$filePath` (путь к файлу изображения) и/или
`$desiredWidth` (ширина миниатюры). Внутри метода мы сначала вычисляем подходящую высоту миниатюры
(строки 11-16), сохраняя соотношение сторон. Затем мы изменяем размер исходного изображения так,
как нам требуется, и сохраняем его во временный файл (строки 19-32).

Как только класс `ImageManager` будет готов, нужно зарегистрировать сервис `ImageManager` в менеджере
сервисов веб-приложения, добавив следующие строки в файл конфигурации *module.config.php*.

{line-numbers=off, lang=php}
~~~
<?php
return [
    // ...    
    'service_manager' => [
        // ...
        'factories' => [
            // Регистрируем сервис ImageManager
            Service\ImageManager::class => InvokableFactory::class,            
        ],
    ],    
    // ...
];
~~~

### Добавление ImageController

Теперь создадим класс контроллера `ImageController` для нашего примера *Image Gallery*. У
контроллера будут следующие методы действия (перечислены в таблице 10.4):

{title="Таблица 10.4. Методы действия класса ImageController."}
|---------------------------------|------------------------------------------------------------------|
| *Метод действия*                | *Описание*                                                       |
|---------------------------------|------------------------------------------------------------------|
| `__construct()`                 | Позволит внедрить в контроллер зависимость `ImageManager`.       |
|---------------------------------|------------------------------------------------------------------|
| `uploadAction()`                | Показывает страницу выгрузки изображения, позволяющую выгрузить на сервер одно изображение. |
|---------------------------------|------------------------------------------------------------------|
| `indexAction()`                 | Отображает страницу галереи изображений со списком выгруженных изображений. |
|---------------------------------|------------------------------------------------------------------|
| `fileAction()`                  | Предоставляет возможность скачать изображение в полном размере либо его миниатюру. |
|---------------------------------|------------------------------------------------------------------|

Для начала создадим файл *ImageController.php* в каталоге *Application/Controller* под корневым
каталогом модуля. Добавим в этот файл следующий код заглушки:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;
use Application\Form\ImageForm;

// Этот контроллер предназначен для управления выгрузками файлов изображений на сервер.
class ImageController extends AbstractActionController 
{
    // Менеджер изображений.
    private $imageManager;
  
    // Метод конструктора используется для внедрения зависимостей
    // в контроллер.
    public function __construct($imageManager)
    {
        $this->imageManager = $imageManager;
    }
  
    // Это действие контроллера "index" (действие по умолчанию). Оно отображает
    // страницу Image Gallery, которая содержит список выгруженных изображений.
    public function indexAction() 
    {                
    }
    
    // Это действие показывает форму выгрузки изображений. Эта страница позволяет
    // выгрузить один файл на сервер.
    public function uploadAction() 
    {
    }
    
    // Это действие 'file', которое вызывается, когда пользователь хочет
    // открыть файл изображения в своем браузере или сгенерировать миниатюру.     
    public function fileAction() 
    {        
    }    
}
~~~

В этом фрагменте мы определили класс `ImageController`, который "живет" в пространстве имен
`Application\Controller`, и добавили в этот класс метод конструктора и три заглушки метода действия:
`indexAction()`, `uploadAction()` и `fileAction()`. Далее мы заполним кодом эти методы действия.

#### Добавление действия выгрузки и соответствующего шаблона представления

Первым делом мы заполним метод `uploadAction()` нашего контроллера. Этот метод действия будет обрабатывать
страницу *Upload a New Image*, содержащую форму выгрузки на сервер. Форма будет предоставлять возможность
выгружать файл изображения в галерею.

Измените файл *ImageController.php* таким образом:

{line-numbers=on, lang=php}
~~~
<?php
//...
class ImageController extends AbstractActionController 
{
    //...
    public function uploadAction() 
    {
        // Создаем модель формы.
        $form = new ImageForm();
        
        // Проверяем, отправил ли пользователь форму.
        if($this->getRequest()->isPost()) {
            
            // Обязательно объедините информацию о файлах!
            $request = $this->getRequest();
            $data = array_merge_recursive(
                $request->getPost()->toArray(),
                $request->getFiles()->toArray()
            );
            
            // Передаем данные форме.
            $form->setData($data);
            
            // Валидируем форму.
            if($form->isValid()) {
                
                // Перемещаем выгруженный файл в его каталог назначения.
                $data = $form->getData();
                
                // Перенаправляем пользователя на страницу "Image Gallery".
                return $this->redirect()->toRoute('images');
            }                        
        } 
        
        // Визуализируем страницу.
        return new ViewModel([
                     'form' => $form
                 ]);
    }
}
~~~



В описанном выше методе `uploadAction()` мы далем следующее.

В строке 9 мы создаем экземпляр модели формы `ImageForm` с помощью оператора `new`.

В строке 12 мы проверяем, является ли запрос HTTP-запросом методом POST. Если это так, мы получаем
данные из суперглобальных массивов `$_POST` и `$_FILES`и объединяем их в один массив (строки 15-19).
Это необходимо для корректной обработки выгруженных на сервер файлов, если таковые имеются. Затем
мы передаем этот массив модели формы с помощью метода `setData() (строка 22).

В строке 25 мы вызываем метод модели формы `isValid()`. Этот метод запускает фильтр входных данных, присоединенный
к модели формы. Так как в этом фильтре у нас только один файловый вход, запустится только три валидатора файлов:
`UploadFile`, `IsImage` и `ImageSize`. 

Если данные действительны, мы вызываем метод `getData()` (строка 28). Для нашего поля файла, он запустит
фильтр `RenameUpload`, который перемещает выгруженный на сервер файл в его постоянный каталог.

После этого, в строке 31, мы перенаправляем пользователя к "index"-действию контроллера. (мы заполним
этот метод действия немного позже).

Теперь пора добавить шаблон представления для действия "upload". Добавьте шаблон представления
*upload.phtml* под каталогом *application/image* под каталогом модуля *view*.

{line-numbers=on, lang=php}
~~~
<?php
$form = $this->form;
$form->get('submit')->setAttributes(['class'=>'btn btn-primary']);
$form->prepare();
?>

<h1>Upload a New Image</h1>

<p>
    Пожалуйста, заполните следующую форму и нажмите кнопку <i>Upload</i>.
</p>

<div class="row">
    <div class="col-md-6">
        <?= $this->form()->openTag($form); ?>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('file')); ?>
            <?= $this->formElement($form->get('file')); ?>
            <?= $this->formElementErrors($form->get('file')); ?> 
            <div class="hint">(PNG and JPG formats are allowed)</div>
        </div>
                
        <?= $this->formElement($form->get('submit')); ?>
        
        <?= $this->form()->closeTag(); ?>
    </div>    
</div>    
~~~

В коде шаблона представления мы сперва задаем атрибут "class" (строка 3). Это нужно,
чтобы применить красивые стили Twitter Bootstrap к кнопке отправки формы *Submit*.

Затем мы визуализируем форму с помощью общих помощников видов, которые мы обсудили в [Cбор пользовательских данных с помощью форм](#forms).
Для визуализации поля "file" мы используем общий помощник вида `FormElement`.

I> Как правило, помощник вида `FormElement` используется для визуализации поля файла.
I> `FormElement` внутренне вызывает помощник вида `FormFile`, который выполняет фактическую
I> визуализацию.

#### Добавление index действия и соответствующего шаблона представления

Следующий метод действия, который мы заполним - `indexAction()`. Это действие будет обрабатывать
страницу *Image Gallery*, содержащую список выгруженных на сервер файлов и их миниатюры. Для каждого
изображения будет кнопка "Show In Natural Size" (показать в исходном размере) для открытия изображения
в новой вкладке браузера.

Измените файл *ImageController.php*, как показано ниже:

{line-numbers=on, lang=php}
~~~
<?php
//...
class ImageController extends AbstractActionController 
{
    //...
    public function indexAction() 
    {
        // Получаем список уже сохраненных файлов.
        $files = $this->imageManager->getSavedFiles();
        
        // Визуализируем шаблон представления.
        return new ViewModel([
            'files'=>$files
        ]);
    }
}
~~~

Во фрагменте выше мы используем метод `getSavedFiles()` класса `ImageManager` для извлечения
списка выгруженных на сервер файлов и передаем их представлению для визуализации.

T> Заметьте, насколько это действие контроллера "тонкое" и понятное! Мы добились этого,
T> переместив набор функций для управления изображениями в модель сервиса `ImageManager`.

Добавьте шаблон представления *index.phtml* в каталог *application/image* под каталогом
модуля *view*. Содержимое файла показано ниже:

{line-numbers=on, lang=php}
~~~
<h1>Image Gallery</h1>
 
<p>
    Эта страница отображает список выгруженных изображений.
</p>

<p>
    <a href="<?= $this->url('images', ['action'=>'upload']); ?>" 
        class="btn btn-primary" role="button">Upload More</a>
</p>

<hr/>

<?php if(count($files)==0): ?>

<p>
  <i>Нет файлов для отображения.</i>
</p>

<?php else: ?>

<div class="row">
    <div class="col-sm-6 col-md-12">

        <?php foreach($files as $file): ?>  

        <div class="img-thumbnail">
                
            <img src="<?= $this->url('images', ['action'=>'file'], 
                ['query'=>['name'=>$file, 'thumbnail'=>true]]); ?>">
                
            <div class="caption">
                <h3><?php echo $file; ?></h3>                    
                <p>
                <a target="_blank" href="<?= $this->url('images', ['action'=>'file'], 
                    ['query'=>['name'=>$file]]); ?>" 
                    class="btn btn-default" role="button">Show in Natural Size</a>
                </p>
            </div>
        </div>

        <?php endforeach; ?>
    </div>
</div>

<?php endif; ?>

<hr/>
~~~

В этом фрагменте кода мы создаем HTML-разметку для кнопки *Upload More*.

Далее мы проверяем, является ли массив `$files` пустым. Если он пустой, мы выводим
сообщение "Нет файлов для отображения"; иначе мы проходим по файлам и выводим миниатюры
всех выгруженных на сервер изображений.

Для визуализации миниатюры мы используем тег `<img>`. Мы задаем его атрибут `src` с помощью URL,
указывающего на действие "file" нашего контроллера `ImageController`. Через часть запроса URL
действию передаются два параметра: имя изображения и флаг миниатюры.

Для стилизации миниатюр мы используем предоставляемый Twitter Bootstrap CSS-класс ".img-thumbnail".

T> За дополнительной информацией о стилях Twitter Bootstrap, пожалуйста, обратитесь к официальной
T> дкоументации Bootstrap.

Под каждой миниатюрой мы размещаем ссылку "Show in Natural Size" (показать в исходном размере), которая направляет к действию
"file" контроллера `ImageController` Когда посетитель сайта нажимает на ссылку, ему показывается изображение
в исходном размере, и это изображение будет открыто в другой вкладке (обратите внимание на атрибут ссылки `target="_blank").

#### Добавление действия file

Последнее действие, которое мы заполним - это метод `ImageController::fileAction()`. Этот метод
позволит предварительно просматривать выгруженное на сервер изображение или генерировать его миниатюру.
Метод действия будет принимать два GET-параметра:

  * параметр "name" определяет имя файла для предварительного просмотра;
  * параметр "thumbnail" - это флаг, указывающий, хотим ли мы вывести изображение в полном размере или
    его уменьшенную копию.

Измените файл *ImageController.php* следующим образом:

{line-numbers=on, lang=php}
~~~
 <?php
//...
class ImageController extends AbstractActionController 
{
    //...
    public function fileAction() 
    {
        // Получаем имя файла из GET-переменной.
        $fileName = $this->params()->fromQuery('name', '');

        // Проверяем, что нужно пользователю: изображение в полном размере или миниатюра.
        $isThumbnail = (bool)$this->params()->fromQuery('thumbnail', false);
    
        // Получаем путь к файлу изображения.
        $fileName = $this->imageManager->getImagePathByName($fileName);
        
        if($isThumbnail) {
        
            // Изменяем размер изображения.
            $fileName = $this->imageManager->resizeImage($fileName);
        }
                
        // Получаем информацию файла изображения (размер и MIME-тип).
        $fileInfo = $this->imageManager->getImageFileInfo($fileName);        
        if ($fileInfo===false) {
            // Устанавливаем код состояния 404 Not Found
            $this->getResponse()->setStatusCode(404);            
            return;
        }
                
        // Запсиываем HTTP-заголовки.
        $response = $this->getResponse();
        $headers = $response->getHeaders();
        $headers->addHeaderLine("Content-type: " . $fileInfo['type']);        
        $headers->addHeaderLine("Content-length: " . $fileInfo['size']);
            
        // Записываем содержимое файла.
        $fileContent = $this->imageManager->getImageFileContent($fileName);
        if($fileContent!==false) {                
            $response->setContent($fileContent);
        } else {        
            // Устанавливаем код состояния 500 Server Error.
            $this->getResponse()->setStatusCode(500);
            return;
        }
        
        if($isThumbnail) {
            // Удаляем временный файл миниатюры изображения.
            unlink($fileName);
        }
        
        // Возвращаем экземпляр Response, чтобы избежать визуализации представления по умолчанию.
        return $this->getResponse();
    }    
}
~~~

В этом фрагменте мы первым делом получаем параметры "name" и "thumbnail" из суперглобального
массива `$_GET` (строки 9, 12). Если параметры отсутствуют, вместо них используются значения
по умолчанию.

В строке 15 мы используем метод `getImagePathByName()`, предоставляемый сервисом `ImageManager`,
чтобы получить абсолютный путь к изображению по его имени.

Если запрашивается миниатюра, мы изменяем размер изображения с помощью метода `ImageManager` 
`resizeImage()` (строка 20). Этот метод возвращает путь к временному файлу, содержащему миниатюру.

Затем мы получаем информацию о файле изображения (его MIME-тип и размер файла) с помощью метода
`ImageManager` `getImageFileInfo()` (строка 24).

И наконец, мы создаем объект `Response`, заполняем его заголовки информацией об изображении,
задаем его содержимое данными файла изображения (строки 32-45) и возвращаем объект `Response`
из действия контроллера (строка 53).

I> Обратите внимание, что возврат объекта `Response` отключает визуализацию шаблона представления
I> по умолчанию для этого метода действия. По этой причине мы не создаем файл шаблона представления *file.phtml*.

#### Создание фабрики для контроллера

Так как `ImageController` использует сервис `ImageManager`, нам нужно как-то передать ему экземпляр
`ImageManager` (для внедрения зависимости в конструктор контроллера). Мы сделаем это с помощью *фабрики*.

Создайте файл `ImageControllerFactory.php` под подкаталогом *Controller/Factory*  под корневым каталогом
модуля. Поместите в этот файл следующий код:

{line-numbers=off, lang=php}
~~~
<?php
namespace Application\Controller\Factory;

use Interop\Container\ContainerInterface;
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\ImageManager;
use Application\Controller\ImageController;

/**
 * Это фабрика для ImageController. Ее целью является инстанцирование
 * контроллера.
 */
class ImageControllerFactory implements FactoryInterface
{
    public function __invoke(ContainerInterface $container, 
                        $requestedName, array $options = null)
    {
        $imageManager = $container->get(ImageManager::class);
        
        // Инстанцируем контроллер и внедряем зависимости
        return new ImageController($imageManager);
    }
}
~~~

#### Регистрация ImageController

Чтобы дать ZF3 знать о нашем контроллере, зарегистрируем `ImageController` в файле конфигурации *module.config.php*: 

{line-numbers=off, lang=php}
~~~
<?php
return [
    //...
    'controllers' => [
        'factories' => [
            Controller\ImageController::class => 
                    Controller\Factory\ImageControllerFactory::class,
            //...
        ],
    ],    
    //...
];
~~~

#### Создание маршрута

Также нам нужно добавить *маршрут* для контроллера `ImageController`. Для этого просто измените файл `module.config.php`
следующим образом:

{line-numbers=off, lang=php}
~~~
<?php
return [
    //...
    'router' => [
        'routes' => [
            'images' => [
                'type'    => Segment::class,
                'options' => [
                    'route'    => '/images[/:action]',
                    'constraints' => [
                        'action' => '[a-zA-Z][a-zA-Z0-9_-]*'
                    ],
                    'defaults' => [
                        'controller'    => Controller\ImageController::class,
                        'action'        => 'index',
                    ],
                ],
            ],
        ],
    ],    
    //...
];
~~~

После этого вы сможете обратиться к нашей галереи изображений по URL "http://localhost/images",
"http://localhost/images/upload" или "http://localhost/images/file".

### Результаты

В заключение, отрегулируем права доступа к каталогу, чтобы он был доступным для записи для веб-сервера Apache.
В Linux Ubuntu это, как правило, совершается следующими командами оболочки (замените плейсхолдер `APP_DIR`
именем каталога вашего веб-приложения):

`chown -R www-data:www-data APP_DIR/data`

`chmod -R 775 APP_DIR/data`

Приведенные выше команды соответственно назначают пользователя Apache владельцем каталога и позволяют
веб-серверу записывать данные в каталог.

Теперь, если вы введете URL *http://localhost/images* в адресную строку браузера,
вы увидите страницу галереи изображений, как показано на рисунке 10.4.

{width=80%}
![Рисунок 10.4. Страница галереи изображений](../en/images/uploads/empty_image_gallery.png)

Нажатие на кнопку *Upload More* откроет страницу *Upload a New Image*, где вы можете выбрать файл
изображения для выгрузки на сервер. Если вы выберете недопустимый файл (не являющийся изображением,
либо слишком большое изображение), вы увидите ошибки валидации (см. рисунок 10.5 ниже).

{width=80%}
![Рисунок 10.5. Ошибки валидации файла](../en/images/uploads/image_validation_errors.png)

Если выгрузка файла на сервер завершилась удачно, вы будете перенаправлены обратно на
страницу *Image Gallery* и увидите выгруженное изображение в списке миниатюр. Нажатие на
кнопку *View Full Size* откроет изображение в новой вкладке браузера (см. рисунок 10.6 ниже).

{width=80%}
![Figure 10.6. Opening an Image in Natural Size](../en/images/uploads/image_preview.png)

T> Пример галереи изображений *Image Gallery* можно найти в приложении *Form Demo*, которое
T> идет вместе с этой книгой.

## Выводы

Выгрузка файлов на сервер - стандартное свойство HTML-форм. Выгрузка осуществляется заданием
бинарного типа кодирования содержимого формы. Zend Framework 3 предоставляет удобную функциональность
для выгрузки на сервер и валидации выгруженных файлов.
