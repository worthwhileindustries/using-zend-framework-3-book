# Маршрутизация {#routing}

Когда пользователь вводит URL в браузер, HTTP-запрос в конечном счете посылается действию
контроллера. В этой главе мы рассмотрим, как приложение на базе ZF3 устанавливает соответствие
между URL и контроллерами и их действиями. Установление соответствия выполняется с помощью маршрутизации (routing).
Маршрутизация реализована как часть компонента `Zend\Router`.

Компоненты ZF3, рассматриваемые в этой главе:

|--------------------------------|---------------------------------------------------------------|
| *Компонент*                    | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Router`                  | Реализует поддержку маршрутизации.                            |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Barcode`                 | Вспомогательный компонент, реализующий штрих-коды.            |
|--------------------------------|---------------------------------------------------------------|

## Структура URL

Чтобы лучше понять механизмы маршрутизации, для начала взглянем на структуру URL.
Типичный URL HTTP-запроса состоит из нескольких частей: схемы, имени хоста, пути,
фрагмента и запроса (query).

Рассмотрим, например, URL "http://site1.yourserver.com/path/to/page#section?a=1&b=2" (рисунок 5.1).

![Рисунок 5.1. Типичная структура URL](../en/images/routing/url_segments.png)

Данный URL начинается со схемы (схема, как правило, выглядит как *http* или *https*). 
Затем следует имя хоста - доменное имя вашего веб-сервера (например, *site1.yourserver.com*).
После этого идут необязательные сегменты пути (разделенные символом '/'). То есть, если путь - это "/path/to/page", то 
"path", "to", и "page" будут его сегментами. После решетки ('#'), идет имя фрагмента. И наконец, после 
вопросительного знака следует необязательная часть, называемая запросом (query). Она состоит из одного или нескольких параметров вида "name=value", 
разделенных друг от друга амперсандом ('&'). 

Каждая часть URL использует специальное кодирование символов, называемое *URL-кодированием (URL encoding)*.
Оно гарантирует, что URL состоит только из "безопасных" символов из таблицы ASCII [^ascii]. Если URL
содержит небезопасные символы, они заменяются знаком процента ('%'), за которым следуют две шестнадцатеричные
цифры (например, символ пробела будет заменен на '%20').

[^ascii]: ASCII (American Standard Code for Information Interchange - американский стандартный код для обмена информацией) - это 
          набор символов, используемый для кодирования английского алфавита. Он кодирует 128 символов: цифры, буквы, 
          знаки препинания и несколько управляющих символов, унаследованных от печатных машинок.

## Типы маршрутов

*Маршрутизация (routing)* - это механизм, позволяющий установить соответствие между URL запроса и контроллерами и их действиями. 
Благодаря маршрутизации, ZF3 знает, какой метод действия контроллера следует выполнить в результате
запроса. Например, можно установить соответствие между URL "http://localhost/" и методом `IndexController::indexAction()`,
и между URL "http://localhost/about" и методом `IndexController::aboutAction()`.

I> Вы определяете соответствие между URL и контроллерами с помощью *маршрутов (routes)*. 

Zend Framework 3 предоставляет несколько стандартных типов маршрутов (см. таблицу 5.1). 
Эти типы реализованы в качестве классов и находятся в пространстве имен `Zend\Router\Http`. 

{title="Таблица 5.1. Типы маршрутов"}
|--------------------------------|---------------------------------------------------------------|
| *Тип маршрута*                 | *Описание*                                                 |
|--------------------------------|---------------------------------------------------------------|
| *Literal*                      | Полное сопоставление с путем URL.                             |
|--------------------------------|---------------------------------------------------------------|
| *Segment*                      | Сопоставление с сегментом пути (или несколькими сегментами) URL. |
|--------------------------------|---------------------------------------------------------------|
| *Regex*                        | Сопоставление пути URL с шаблоном регулярного выражения.      |
|--------------------------------|---------------------------------------------------------------|
| *Hostname*                     | Сопоставление имени хоста с каким-либо критерием.             |
|--------------------------------|---------------------------------------------------------------|
| *Scheme*                       | Сопоставление схемы URL с каким-либо критерием.               |
|--------------------------------|---------------------------------------------------------------|
| *Method*                       | Сопоставление метода HTTP (например, GET, POST, и т.д.) с каким-либо критерием. |
|--------------------------------|---------------------------------------------------------------|

Каждый тип маршрута в этой таблице (кроме типа *Method*) может быть сопоставлен с определенной частью
(или несколькими частями) URL. Тип маршрута *Method* сопоставляется с HTTP-методом (либо GET,
либо POST), извлеченным из HTTP-запроса.

## Комбинирование типов маршрутов

Маршруты могут быть скомбинированы с помощью "составных" типов (см. таблицу 5.2).
Такие типы маршрутов позволяют определить сколь угодно сложные правила маршрутизации URL.

{title="Таблица 5.2. Составные типы маршрутов"}
|--------------------------------|---------------------------------------------------------------|
| *Тип маршрута*                 | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| *SimpleRouteStack*             | Объединяет различные типы маршрутов в список с приоритетами. |
|--------------------------------|---------------------------------------------------------------|
| *TreeRouteStack*               | Объединяет различные типы маршрутов в древовидную структуру.  |
|--------------------------------|---------------------------------------------------------------|
| *Part*                         | Объединяет различные типы маршрутов в поддерево.              |
|--------------------------------|---------------------------------------------------------------|
| *Chain*                        | Объединяет различные типы маршрутов в цепь (вырожденное поддерево). |
|--------------------------------|---------------------------------------------------------------|

`TreeRouteStack` и `SimpleRouteStack` используются как типы маршрутов "верхнего уровня". 
*SimpleRouteStack* позволяет организовать различные маршруты в список по степени важности. 
*TreeRouteStack* позволяет *вложить* один маршрут в другой, формируя "дерево". 

На рисунке 5.2 изображена диаграмма наследования классов маршрутов. 

![Figure 5.2. Диаграмма наследования классов маршрутов](../en/images/routing/route_inheritance.png)

Как видите, все классы маршрутов наследуются от интерфейса `RouteInterface` (мы 
детально изучим этот интерфейс в разделе *Написание своего типа маршрута* позже
в этой главе). Класс `SimpleRouteStack` - родительский для класса `TreeRouteStack`, который 
наследует поведение *SimpleRouteStack* (объединение маршрутов в список с приоритетами) и
расширяет его (объединение маршрутов в поддеревья). Классы `Part` и `Chain` 
наследуются от класса `TreeRouteStack` и используются `TreeRouteStack` внутренне для построения
поддеревьев и цепей дочерних маршрутов. 

### SimpleRouteStack

Тип `SimpleRouteStack` позволяет объединить различные маршруты в список по степени важности.
Пример такого списка вы можете увидеть в стеке маршрутов в левой части рисунка 5.3.
Этот список содержит несколько маршрутов *Literal* и несколько маршрутов *Segment*.

При сопоставлении с  HTTP-запросом, `SimpleRouteStack` проходит через список
маршрутов и пробует сопоставить каждый маршрут по очереди. Каждый маршрут в списке имеет свой приоритет; 
маршруты с более высоким приоритетом обрабатываются первыми. Просмотр заканчивается, как только какой-либо
маршрут сопоставляется с HTTP-запросом. Если не удается сопоставить ни один маршрут, выдается ошибка "not found". 

![Рисунок 5.3. Пример SimpleRouteStack (слева) и TreeRouteStack (справа)](../en/images/routing/route_tree.png)

### TreeRouteStack

Класс `TreeRouteStack` расширяет `SimpleRouteStack` class. Это означает, что помимо возможности
объединения маршрутов в список с приоритетами, он также может вставить маршруты в поддеревья
и цепи. Пример этого класса представлен в правой части рисунка 5.3.
Список состоит из одного маршрута `Literal`, цепи маршрутов `Literal` и `Segment` и
поддерева, состоящего из двух ветвей: ветви, содержащий один маршрут `Segment` и
ветви, состоящей из маршрутов `Scheme`, `Hostname` и `Segment`. 

TreeRouteStack выполняет сопоставление запроса следующим образом. Он проходит по пунктам списка с приоритетами  (обозначены пунктирными линиями на рисунке 5.3), начиная с маршрутов с наивысшим приоритетом. 
Если какой-либо из пунктов - это маршрут `Chain` или `Part`, TreeRouteStack обрабатывает этот вложенный маршрут от родительского
маршрута к дочерним. Если удается сопоставить родительский маршрут, анализируются дочерние (обозначены сплошными линиями). Вложенный маршрут
совпадает, если совпадает хотя бы один маршрут на каждом уровне дерева (или цепи).

Каждый маршрут в дереве (или цепи) занимает часть URL (рисунок 5.4). Родительский маршрут сопоставляется с
первой частью URL, дочерний со следующей, и так до конца строки URL.

![Рисунок 5.4. Пример сопоставления вложенного маршрута](../en/images/routing/route_matching.png)

## Конфигурация маршрутизации

Как правило, вы не создаете описанные выше классы сами. Вместо этого вы сообщаете ZF3,
как это сделать.

Конфигурация маршрутизации для модуля хранится в файле конфигурации *module.config.php*:

{line-numbers=on, lang=php}
~~~
<?php
use Zend\Router\Http\TreeRouteStack;

return [
    //...
    'router' => [
        'router_class' => TreeRouteStack::class,
        'routes' => [	
            // Зарегистрируйте правила маршрутизации ...	
        ],
        'default_params' => [	
            // Укажите параметры по умолчанию для всех маршрутов ...	
        ]
    ],
];
~~~

В строке 6 у нас есть ключ *router*, под которым находится подключ *routes* (строка 8),
содержащий правила маршрутизации. 

Вы можете указать, какой класс маршрутов верхнего уровня использовать (`TreeRouteStack` или `SimpleRouteStack`) 
через параметр `router_class` (строка 7). Если такого параметра нет,
используется `TreeRouteStack`.

Вы также можете использовать опциональный ключ `default_params` (строка 11) , чтобы определить *значения по умолчанию* для параметров 
всех маршрутов сразу. Однако, как правило, этот ключ не используется, и умолчания определяются
на основе каждого маршрута. 

I> Мы покажем, как извлекать параметры из маршрута позже в этой главе. 

### Конфигурация для простых маршрутов

Типичный маршрут имеет *имя*, *тип* и *опции*: 
  
  * *Имя* используется для идентификации маршрута. 
  * *Тип* определяет полностью определенное имя типа маршрута (PHP-класс, реализующий
     алгоритм сопоставления). 
  * *Опции* - это массив, содержащий строку *route*, которую нужно сравнивать
    с URL, и несколько параметров, называемых *умолчаниями*.

Конфигурация для каждого маршрута под ключом `routes` может иметь следующий формат:

{line-numbers=off, lang=php}
~~~
'<route_name>' => [
    'type' => '<route_type_class>',
    'priority' => <priority>,
    'options' => [
        'route' => '<route>',
        'defaults' => ]
            //...
        ],
    ],  
]
~~~

В плейсхолдер `<route_name>` выше следует вписать имя маршрута. Имя маршрута должно быть в нижнем регистре,
например, "home" или "about". Ключ `type` устанавливает полностью определенное имя класса маршрута.

Опциональный ключ `priority` позволяет установить приоритет (должен быть значением типа integer) 
маршрута в списке по степени важности (маршруты с более высоким приоритетом обрабатываются первыми). Если вы
не будете его включать, маршруты будут проходиться в порядке LIFO [^lifo].

I> Маршруты с одинаковым приоритетом также будут проходиться в порядке LIFO. Поэтому для наибольшей эффективности
I> следует регистрировать маршруты, которые чаще будут совпадать, в конец, а наименее распространенные - в начало.

[^lifo]: LIFO (расшифровывается как Last In, First Out, «последним пришёл — первым ушёл») - способ организации элементов в стек,
         при котором самый верхний элемент, добавленный последним, выбирается в первую очередь.

Ключ `options` определяет массив опций маршрута. Мы обсудим опции в последующих
разделах этой главы.

### Конфигурация для вложенных маршрутов

Для организации маршрутов в поддерево, нужно добавить ключ `child_routes` к определению маршрута 
и добавить дочерние маршруты под этот ключ, как показано ниже:

{line-numbers=off, lang=php}
~~~
'<route_name>' => [
    'type' => '<route_type_class>',
    'priority' => <priority>,
    'options' => [
        //...
    ],
    'child_routes' => [
        // Добавьте дочерние маршруты.
        // ...
    ]	
],
~~~

Для организации маршрутов в цепь (вырожденное поддерево), нужно добавить ключ
`chain_routes` к конфигурации маршрутов:

{line-numbers=off, lang=php}
~~~
'<route_name>' => [
    'type' => '<route_type_class>',
    'priority' => <priority>,
    'options' => [
        //...
    ],
    'chain_routes' => [
        // Добавьте цепные маршруты.
        // ...
    ]	
],
~~~

T> Посмотрев на оба примера выше, вы не увидите явного использования типов `Part` и
T> `Chain`, потому что они (для вашего удобства) используются ZF3 автоматически при
T> встрече с ключами `child_routes` и `chain_routes` в конфигурации маршрутизации.

### Конфигурация маршрутизации по умолчанию в Zend Skeleton Application

Теперь, когда вы знаете, как настраивать маршруты и организовывать их в составные структуры, давайте
рассмотрим реальный пример. В чистом Zend Skeleton Application, конфигурация 
маршрутизации выглядит таким образом:

{line-numbers=on, lang=php}
~~~
<?php
use Zend\Router\Http\Literal;
use Zend\Router\Http\Segment;

return [
    'router' => [
        'routes' => [
            'home' => [
                'type' => Literal::class,
                'options' => [
                    'route'    => '/',
                    'defaults' => [
                        'controller' => Controller\IndexController::class,
                        'action'     => 'index',
                    ],
                ],
            ],
            'application' => [
                'type'    => Segment::class,
                'options' => [
                    'route'    => '/application[/:action]',
                    'defaults' => [
                        'controller'    => Controller\IndexController::class,
                        'action'        => 'index',
                    ],
                ],
            ],
        ],
    ],
    
    //...
];
~~~

В представленной конфигурации у нас есть два правила маршрутизации: 
сначала маршрут "home" (строка 8), а затем маршрут "application" (строка 18).

Маршрут "home" устанавливает соответствие между пустым путем URL и действием "index" контроллера `IndexController`. Например,
введите "http://localhost/" в браузере и вы увидите домашнюю страницу вашего сайта. Этот маршрут -
типа "Literal".

Маршрут "application" (типа "Segment") устанавливает соответствие между URL вида "http://localhost/application", 
"http://localhost/application/about", "http://localhost/application/news", и т.д. и соответствующим
действием контроллера `IndexController`. Имя действия определяется параметром "action", значение этого параметра по умолчанию - "index". 
То есть, если вы не уточните действие, запрос будет послан действию "index".

Эта конфигурация соответствует TreeRouteStack (см. рисунок 5.5):

![Figure 5.5. Стек маршрутов в скелетном приложении](../en/images/routing/skeleton_route_tree.png)

В следующих разделах мы приведем несколько примеров использования 
различных типов маршрутов.

## Тип маршрута Literal

При использовании типа *Literal* маршрут сопоставляется только тогда, когда
строка маршрута полностью совпадает с путем URL. Тип *Literal* обычно используется для URL, 
которые должны быть короткими и запоминающимися, вроде '/about' или '/news'. 

Ниже представлено определение маршрута *home*. Этот маршрут обычно сопоставляется
действию `IndexController` "index" и ведет на домашнюю страницу сайта:


{line-numbers=on, lang=php}
~~~
'home' => [
    'type' => Literal::class,
    'options' => [
        'route'    => '/',
        'defaults' => [
            'controller' => Controller\IndexController::class,
            'action'     => 'index',
        ],
    ],
],
~~~

В этом примере строка 2 указывает тип маршрута - *Literal*. Алгоритм 
сопоставления маршрута реализован в классе `Zend\Router\Http\Literal`.

Строка 4 определяет строку маршрута, которую надо сопоставить с путем URL (слеш означает пустую часть URL).
Так как тип маршрута - Literal, маршрут будет соответствовать только при полном совпадении пути.
Например, URL "http://localhost/" или "http://localhost" будет соответствовать строке '/'.

Строки 5-8 определяют умолчания, которые возвращаются маршрутизатором, если маршрут 
удалось сопоставить. Параметры `controller` и `action` определяют контроллер
и метод действия контроллера, который надо выполнить. При необходимости вы также можете
определить здесь и другие параметры.

В качестве другого примера типа маршрута *Literal*, добавим маршрут '/about' для страницы *About*, которую
мы создали ранее в разделе *Представления* главы [Модель-Представление-Контроллер](#mvc). Чтобы создать маршрут,
добавьте следующий код сразу после определения маршрута "home" в файл *module.config.php*:

{line-numbers=off, lang=php}
~~~
'about' => [
    'type' => Literal::class,
    'options' => [
        'route' => '/about',
        'defaults' => [
            'controller' => Controller\IndexController::class,
            'action'     => 'about',
        ],
    ],
],
~~~

Если вы теперь откроете URL "http://localhost/about" в вашем браузере, вы должны 
увидеть страницу *About*. 

## Тип маршрута Segment

Тип маршрута *Segment* позволяет сопоставлять строку маршрута с одним или
несколькими сегментами пути URL.

I> Если вы заглянете в файл *module.config.php*, вы заметите, что тип маршрута *Segment* 
I> используется внутри маршрута "application", чтобы автоматически устанавливать соответствие 
I> между действиями `IndexController` и URL сайта. Вы можете просто добавить метод действия в
I> класс `IndexController`, и он станет доступным для URL как "http://localhost/application/&lt;action&gt;".
I> Например, вы можете просмотреть страницу *About* вашего сайта с помощью следующего URL: 
I> "http://localhost/application/about".

Для демонстрации создания типа маршрута *Segment* давайте реализуем 
действие контроллера, которое будет генерировать простое изображение штрих-кода.
Штрих-коды широко используются в супермаркетах, чтобы оптически распознавать товары из 
вашей корзины. Штрих-коды могут быть различных типов и иметь различные маркировки.
Мы будем использовать тип маршрута *Segment* для установления соответствия действия с URL наподобие
"http://localhost/barcode/&lt;type&gt;/&lt;label&gt;". 

I> Чтобы иметь возможность использовать штрих-коды, вам нужно установить компонент `Zend\Barcode` через Composer,
I> прописав следующую команду:
I> 
I> `php composer.phar require zendframework/zend-barcode`

W> Обратите внимание, для работы изображений штрих-кодов нужно иметь установленное и включенное 
W> расширение PHP-движка GD[^gd]. В Linux Ubuntu его можно установить :
W> такой командой:
W>
W> `sudo apt-get install php-gd`
W>
W> После установки расширения перезапустите Apache для применения изменений.

[^gd]: Расширение PHP GD позволяет создавать файлы изображений разных форматов (таких как JPEG, PNG, GIF, и др.)

Для начала определим маршрут "barcode" в файле *module.config.php*:

{line-numbers=on, lang=php}
~~~
'barcode' => [
    'type' => Segment::class,
    'options' => [
        'route' => '/barcode[/:type/:label]',
        'constraints' => [     
            'type' => '[a-zA-Z][a-zA-Z0-9_-]*',
            'label' => '[a-zA-Z0-9_-]*'
        ],
        'defaults' => [
            'controller' => Controller\IndexController::class,
            'action' => 'barcode',
        ],
    ],
],
~~~

Сегменты строки маршрута (строка 4) могут быть либо константами, либо переменными. Вы можете
определить переменные, используя шаблоны. У нас есть три сегмента: `barcode`, `:type` и `:label`. 
Первый является константой, в то время как второй и третий - шаблоны (имя шаблона должно 
начинаться с двоеточия).

Как должен выглядеть шаблон вы можете определить в подключе `constraints` (строки 5-8).
Мы определяем регулярное выражение `[a-zA-Z][a-zA-Z0-9_-]*`, которое ставит нашему шаблону `:type` 
ограничения: он должен начинаться с буквы и опционально содержать несколько следующих символов:
букв, цифр, нижних подчеркиваний и знаков минуса.
Ограничения для шаблона `:label` почти такие же, за исключением того, что
этот сегмент может начинаться с любого разрешенного символа (буквы, цифры, нижнего подчеркивания или знака минуса).

Необязательные сегменты могут быть заключены в квадратные скобки. В нашем примере
оба сегмента, `:type` и `:label`, необязательны.

В строках 9-12 мы определяем параметры по умолчанию, которые будут возвращены маршрутизатором.
У `controller` и `action` эти параметры указывают, какие контроллер и метод действия вызывать
при совпадении маршрута.

Теперь добавим метод `barcodeAction()` в класс `IndexController`:

{line-numbers=on, lang=php}
~~~
// Добавляем псевдоним имени в начале файла
use Zend\Barcode\Barcode;

// ...

// Действие "barcode"
public function barcodeAction() 
{
    // Получаем параметры от маршрута.
    $type = $this->params()->fromRoute('type', 'code39');
    $label = $this->params()->fromRoute('label', 'HELLO-WORLD');
        
    // Устанавливаем опции штрих-кода.
    $barcodeOptions = ['text' => $label];        
    $rendererOptions = [];
        
    // Создаем объект штрих-кода.
    $barcode = Barcode::factory($type, 'image', 
                 $barcodeOptions, $rendererOptions);
        
    // Строка ниже выведет изображение штрих-кода в  
    // стандартный поток вывода.
    $barcode->render();

    // Возвращаем объект Response, чтобы отключить визуализацию стандартного представления. 
    return $this->getResponse();
}  
~~~

В строках 10-11 мы получаем от маршрута значения шаблонов `type` и `label`.
Мы делаем это с помощью метода `fromRoute()` плагина контроллера `Params`.
Аналогично методу`fromQuery()`, он принимает два аргумента: 
имя переменной и ее значение по умолчанию.

Для генерации изображения штрих-кода мы используем компонент `Zend\Barcode`.
В строке 14 мы определяем текст маркировки штрих-кода. В строках 18-19 мы
создаем объект `Barcode` с фабричным методом. Наконец, в строке 23 мы
выводим изображение, помещая его в поток вывода.

I> `Zend\Barcode` - это вспомогательный компонент, используемый для генерации
I> различных изображений штрих-кодов. Для дополнительной информации об этом компоненте, 
I> смотрите соответствующий раздел руководства Zend Framework.

В строке 26 мы возвращаем объект `Response`, чтобы пресечь визуализацию стандартного представления.

Теперь введите URL "http://localhost/barcode" в ваш браузер, чтобы увидеть
изображение штрих-кода (см. рисунок 5.6):

![Figure 5.6. Пример изображения штрих-кода](../en/images/routing/barcode.png)

Так как у нас в маршруте есть шаблоны, вы можете передать параметры type и label
изображения штрих-кода в URL. Ниже представлено несколько примеров URL (соответствующие
штрих-коды представлены на рисунке 5.7):

~~~
a. http://localhost/barcode/code39/HELLO-WORLD
b. http://localhost/barcode/leitcode/12345
c. http://localhost/barcode/identcode/98765453212
d. http://localhost/barcode/postnet/123456
e. http://localhost/barcode/planet/1234567890123
f. http://localhost/barcode/upca/12345678901
g. http://localhost/barcode/code128/ABCDEF
h. http://localhost/barcode/ean2/12
~~~

![Figure 5.7. Типы штрих-кодов](../en/images/routing/barcodes.png)

## Тип маршрута Regex

Тип маршрута *Regex* (от REGular EXpressions - регулярные выражения) полезен, если у вас есть URL,
которые могут быть сопоставлены с регулярным выражением.

Документация будет состоять из "статических страниц", сопоставленных с URL подобно */doc/&lt;page_name&gt;.html*.

I> Термином "статическая страница" мы обозначаем страницу, которая содержит, в основном, статический HTML-код
I> плюс несколько встроенных фрагментов PHP-кода. Для таких простых страниц не нужно создавать
I> отдельные действия контроллера. Все "статические" страницы могут обслуживаться одним единственным действием контроллера.

Давайте реализуем маршрут, который будет обслуживать "статические" страницы сайта. Поскольку такие страницы
весьма просты, вам, как правило, не придется добавлять для каждой страницы свой метод действия.  Все 
страницы будут управляться одним действием `IndexController::docAction()`.

Сперва добавим маршрут *Regex* с именем "doc" в файл *module.config.php*:

{line-numbers=on, lang=php}
~~~
'doc' => [
    'type' => Regex::class,
    'options' => [
        'regex'    => '/doc(?<page>\/[a-zA-Z0-9_\-]+)\.html',
        'defaults' => [
            'controller' => Controller\IndexController::class,
            'action'     => 'doc',
        ],
        'spec'=>'/doc/%page%.html'
    ],
],
~~~

Строка 2 определяет тип *Regex* для маршрута. В строке 4 имеется
регулярное выражение `/doc(?<page>\/[a-zA-Z0-9_\-]+)\.html`.
Оно будет сопоставлять URL подобно "/doc/contents.html", "/docs/introduction.html" и так далее.
Выражение содержит именованный захват [^захват] "page", который при установлении соответствия будет возвращен
маршрутизатором вместе с параметрами по умолчанию.

Строка 9 содержит опцию `spec`, которая используется для генерации маршрутом URL (мы обсудим генерацию маршрутом URL
позже в этой главе).

[^захват]:  В регулярных выражениях PCRE возможно дать имя подшаблону, 
            используя синтаксис `(?P<name>pattern)`. Этот подшаблон затем будет 
			индексирован в массиве *matches* по имени. 

I> Не забудьте добавить следующую строчку в начало файла `module.config.php`:
I>
I> `use Zend\Router\Http\Regex;`            
            
Затем добавьте такое действие в класс `IndexController`:

{line-numbers=on, lang=php}
~~~
public function docAction() 
{
    $pageTemplate = 'application/index/doc'.
          $this->params()->fromRoute('page', 'documentation.phtml');        
  
    $filePath = __DIR__.'/../../view/'.$pageTemplate.'.phtml';
    if(!file_exists($filePath) || !is_readable($filePath)) {
        $this->getResponse()->setStatusCode(404);
        return;
    }
	
    $viewModel = new ViewModel([
            'page'=>$pageTemplate
        ]);
    $viewModel->setTemplate($pageTemplate);
	
    return $viewModel;
}
~~~

В строках 3-4, мы извлекаем  из маршрута параметр `page` (помните именованный захват "page"
из нашего регулярного выражения?) и сохраняем его как переменную `$pageTemplate`.
Мы будем использовать эту переменную для определения имени шаблона представления, чтобы передать его
разрешателю представлений. Затем, в строках 6-10, мы проверяем, есть ли такой файл, и,
если его нет, возвращаем код состояния 404 "Not Found", который принуждает ZF3 отобразить
страницу ошибки. В строке 12 мы создаем контейнер для переменных `ViewModel`, а в строке 15
мы явно задаем имя шаблона представления для визуализации. 

Чтобы увидеть систему документации в действии, создайте пару "статических" файлов шаблона представления: 
страницу Table of Contents (Оглавление) (`contents.phtml`) и страницу Introduction (Введение) (`introduction.phtml`). 
Создайте подкаталог *doc* под каталогом *view/application/index* модуля `Application` и
поместите туда шаблон представления *contents.phtml*:

{line-numbers=off, lang=php}
~~~
<h1>Table of Contents</h1>

<ul>
    <li>
        <a href="<?= $this->url('doc', ['page'=>'introduction']); ?>">
	        Introduction
        </a>
    </li>  
</ul>
~~~

Выше представлен HTML-код для заголовка страницы "Table of Contents"
и список, содержащий единственный элемент "Introduction", ведущий к "статической" странице Introduction.
URL генерируется с помощью помощника видов `Url` (подробнее о помощнике `Url` смотрите в следующих
разделах этой главы).

Затем добавьте страницу *introduction.phtml* в тот же каталог *doc*:

{line-numbers=off, lang=php}
~~~
<h1>Introduction</h1>

<p>Some introductory materials.</p>
~~~

В этих строках мы определяем HTML-разметку для простой страницы Introduction.

Теперь при открытии в браузере URL "http://localhost/doc/contents.html",
вы увидите простую и удобную систему документации, которую вы можете расширить и
использовать для своего сайта (рисунок 5.8):

![Рисунок 5.8. "Статическая" страница](../en/images/routing/static_page.png)

Нажатие на ссылку *Introduction* направит вас на статическую страницу "Introduction".
Вы также можете добавить другие страницы в директорию *doc*, чтобы сделать их автоматически
доступными для пользователей сайта через наш маршрут типа *Regex*.

I> Недостаток такой системы документации в том, что она будет работать не очень хорошо, если вы
I> поместите вложенные страницы в подкаталоги под каталогом *doc*. Причина такой ограниченности в том, что 
I> маршрут *Regex* собирает URL. Вы не можете сгенерировать URL, содержащий слеши, так как эти
I> "небезопасные" символы будут автоматически закодированы. Мы обойдем эту проблему с помощью
I> нашего собственного типа маршрута, который мы создадим в конце этой главы.

## Другие типы маршрутов

Типы маршрутов *Hostname*, *Scheme*, и *Method* используется реже по сравнению
с типами, упомянутыми выше.

### Hostname

Тип *Hostname* может использоваться, например, при разработке системы управления
содержимым [^cms], которая должна обслуживать
одновременно несколько сайтов, каждый со своим поддоменом. В этом случае нужно определить 
маршрут *Hostname*, как родительский, и вложенные дочерние маршруты других типов внутри: 

[^cms]: Система управления содержимым (Content Management System или CMS) - это веб-сайт для совместного создания, 
        редактирования и публикации содержимого (блогов, страниц, документов, видео и др.) с использованием
		централизованного веб-интерфейса. Такие системы делают возможным выполнение повседневных задач сайта, вроде
		публикации контента, даже для тех, кто далек от программирования.

{line-numbers=on, lang=php}
~~~
'routename' => [
    'type' => Hostname::class,
    'options' => [
        'route' => ':subdomain.yourserver.com',
        'constraints' => [
            'subdomain' => '[a-zA-Z][a-zA-Z0-9_-]*'
        ], 
        'defaults' => [        
        ],
    ],
    'child_routes'=>[
        //...
    ],
],
~~~

В строке 1 примера выше мы определяем маршрут, который имеет 
тип *Hostname*. Опция `route` (строка 4) определяет
доменное имя для сопоставления. `:subdomain` - шаблон,
который может принимать различные значения поддомена. Ключ `constraints` определяет регулярное выражение,
с которым должен совпадать параметр этого поддомена. Маршрут *Hostname* будет 
разделять домены, так что каждый сайт будет вести себя по-разному, в зависимости от
возвращаемого параметра `subdomain`:

{line-numbers=off, lang=php}
~~~
// Пример действия, которое использует параметры, возвращаемые
// маршрутом Hostname.
public function someAction() 
{
    // Получение от маршрута параметра 'subdomain'.
    $subdomain = $this->params()->fromRoute('subdomain', null);
  
    // Использование различных алгоритмов в зависимости от поддомена.
    //...		

    // Рендеринг шаблона представления.
    return new ViewModel();
}
~~~

### Scheme

Тип маршрута *Scheme* полезен, если вам необходимо управлять протоколами 
HTTP и HTTPS [^https] разными способами. 

[^https]: Протокол HTTPS, как правило, используется для безопасных соединений. Например, страницы аккаунта 
          или страницы корзины. При использовании HTTPS данные запроса туннелируются через уровень защищённых cокетов 
		  (Secure Socket Layer или SSL) и недоступны третьей стороне.

Типичная конфигурация маршрута *Scheme* представлена ниже:

{line-numbers=on, lang=php}
~~~
'routename' => [
    'type' => Scheme::class,
    'options' => [
        'scheme' => 'https',
        'defaults' => [
            'https' => true,
        ],    
    ],
    'child_routes'=>[
        //...
    ],
],
~~~

В этом фрагменте мы определяем маршрут типа *Scheme*. Он принимает опцию `scheme`,
которая является схемой для сопоставления (`http` или `https`).
Если схема в HTTP-запросе URL точно такая же, как в опции `scheme`, маршрут считается
совпадающим с URL. Вы можете использовать ключ `defaults`, чтобы вернуть
некоторые параметры. В примере выше будет возвращен булевый параметр `https`.

### Method

Тип маршрута *Method* может быть использован, чтобы направить запросы *GET* и *POST*
разным действиям контроллера. Его типичная конфигурация представлена ниже:

{line-numbers=on, lang=php}
~~~
'routename' => [
    'type' => Method::class,
    'options' => [
        'verb' => 'post',
        'defaults' => [        
        ],
    ],
    'child_routes'=>[
        //...
    ],
],
~~~

Так, мы определяем маршрут типа *Method*. Он принимает опцию `verb` ,
которая может быть разделенным запятыми списком допустимых HTTP-глаголов (таких как *get*, *post*, *put*, и др.)

## Извлечение параметров из маршрута

При удачном сопоставлении, маршрутизатор (класс маршрута верхнего уровня) возвращает
некоторые параметры: "умолчания" (параметры, перечисленные в разделе `defaults` конфигурации
маршрутизации) и все шаблонные параметры, извлеченные из строки URL.

В контроллере вам часто придется извлекать эти параметры.
Мы уже делали это в примерах выше. В этом разделе мы подведем некоторые итоги.

Так, чтобы извлечь параметр из маршрута в методе действия контроллера, 
как правило, используется плагин контроллера `Params` и его метод `fromRoute()`,
который принимает два аргумента: имя нужного параметра и значение, которое нужно будет
вернуть, если этого параметра нет. 

Метод `fromRoute()` может также использоваться для извлечения всех параметров сразу в виде массива.
Это делается вызовом `fromRoute()` без передачи ему аргументов, как показано в примере ниже:

{line-numbers=off, lang=php}
~~~
// Пример действия.
public function someAction() 
{
    // Получаем один параметр 'id' от маршрута.
    $id = $this->params()->fromRoute('id', -1);
  
    // Получаем все параметры маршрута сразу в виде массива.
    $params = $this->params()->fromRoute();
  
    //...				
}
~~~

### Извлечение объектов RouteMatch и Router

При удачном сопоставлении класс маршрутизатора внутренне создает экземпляр класса `Zend\Router\RouteMatch`, 
предоставляя методы для извлечения имени соответствующего маршрута и полученных из него параметров. 
Полезные методы класса `RouteMatch` перечислены в таблице 5.3:

{title="Table 5.3. Zend\Router\RouteMatch class methods"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `getMatchedRouteName()`        | Получает имя соответствующего маршрута.                       |
|--------------------------------|---------------------------------------------------------------|
| `getParams()`                  | Получает все параметры.                                       |
|--------------------------------|---------------------------------------------------------------|
| `getParam($name, $default)`    | Получает определенный параметр.                               |
|--------------------------------|---------------------------------------------------------------|

I> В большинстве случаев будет достаточно использования плагина контроллера `Params`, но
I> вы также можете использовать для этой цели объект `RouteMatch`. 

Для получения объекта `RouteMatch` из метода действия контроллера, используйте следующий
код:

{line-numbers=on, lang=php}
~~~
// An example action.
public function someAction() 
{
    // Получает объект RouteMatch.
    $routeMatch = $this->getEvent()->getRouteMatch();
  
    // Получает имя соответствующего маршрута.
    $routeName = $routeMatch->getMatchedRouteName();
  
    // Получает все параметры маршрута в виде массива.
    $params = $routeMatch->getParams();
  
    //...				
}
~~~

В строке 5 этого фрагмента кода мы используем метод `getEvent()`базового класса `AbstractActionController` для
извлечения объекта `MvcEvent`, который представляет собой событие (В ZF3 жизненный цикл приложения состоит
из событий). Затем мы используем метод `getRouteMatch()` класса `MvcEvent` для извлечения объекта `RouteMatch`.

В строке 8 мы используем метод `getMatchedRouteName()` для извлечения имени маршрута, который соответствует
HTTP-запросу, а в строке 11 мы извлекаем все его параметры.

Класс `MvcEvent` также может использоваться для извлечения маршрутизатора (класса маршрута верхнего уровня). Это
можно сделать с помощью метода `getRouter()` класса `MvcEvent`, как показано ниже:

{line-numbers=off, lang=php}
~~~
// Вызовите внутри метода действия
// для извлечения RouteStackInterface для класса маршрутизатора.
$router = $this->getEvent()->getRouter();
~~~

Здесь мы используем метод `getRouter()`, который возвращает интерфейс `RouteStackInterface`.
Этот интерфейс является базовым для `SimpleRouteStack` и `TreeRouteStack` и предоставляет
методы для работы с маршрутами, содержащимися внутри стека маршрутов.

## Генерация URL из маршрута

Главная задача любого класса маршрута - определить, соответствует ли этот маршрут HTTP-запроса,
и при удачном сопоставлении вернуть набор параметров, по которым могут быть определены контроллер и действие.
В то же время, обратная задача позволяет генерировать URL с использованием этих параметров. Это может использоваться в 
методах действия контроллера для генерации URL: например, для перенаправления пользователя на другую
страницу. Также это можно использовать в шаблонах представления для генерации гиперссылок.

### Генерация URL в шаблонах представлений

Веб-страницы обычно содержат гиперссылки на другие страницы. Эти ссылки могут указывать как
на страницу вашего сайта, так и на другой сайт. Для определения гиперссылки используется HTML-тег `<a>`,
который имеет атрибут `href`, определяющий URL страницы, на которую надо перейти. Ниже представлен
образец гиперссылки, указывающей на внешнюю страницу:

`<a href="http://example.com/path/to/page">A link to another site page</a>`

При генерации гиперссылки на внутренний ресурс сайта, как правило, 
используется относительный URL (без имени хоста):

`<a href="/path/to/internal/page">A link to internal page</a>`

Чтобы сгенерировать URL в шаблонах представления (файлы *.phtml*), можно использовать класс помощника вида `Url`,
который принимает в качестве аргумента имя маршрута:

{line-numbers=on, lang=php}
~~~
<!-- Гиперссылка на страницу Home -->
<a href="<?= $this->url('home'); ?>">Home page</a>

<!-- Гиперссылка на страницу About  -->
<a href="<?= $this->url('about'); ?>">About page</a>
~~~

Здесь мы генерируем два относительных URL. В строке 2 мы вызываем помощник вида `Url` и передаем в
качестве параметра имя маршрута "home". В строке 5 мы передаем имя маршрута "about" в качестве аргумента
для помощника вида `Url`. 

I> В примере выше помощник вида `Url` внутренне использует объект `RouteMatch` и вызывает 
I> маршрут типа `Literal`, чтобы собрать строку URL с помощью имени маршрута.

После выполнения классом `PhpRenderer` кода шаблона представления, HTML-разметка будет выглядеть
следующим образом:

{line-numbers=off, lang=php}
~~~
<!-- Гиперссылка на страницу Home -->
<a href="/">Home page</a>

<!-- Гиперссылка на страницу About -->
<a href="/about">About page</a>
~~~

#### Передача параметров

Если среди параметров, используемых маршрутом, есть переменные, их следует передать помощнику вида `Url`
в качестве второго аргумента:

{line-numbers=on, lang=php}
~~~
<!-- Гиперссылка на страницу About -->
<a href="<?= $this->url('application', ['action' => 'about']); ?>" >
  About page 
</a>

<!-- Гиперссылка на изображение штрих-кода -->
<a href="<?= $this->url('application', ['action' => 'barcode',
  'type' => 'code39', 'text' => 'HELLO-WORLD']); ?>" >
  Barcode image </a>
~~~

В этом примере мы используем помощник вида `Url` для генерации двух
URL с помощью имени маршрута и его параметров. Мы передаем имя маршрута "application"
в качестве первого аргумента и массив параметров в качестве второго.

В строке 2 мы передаем параметр "action", чтобы сообщить классу маршрута типа
*Segment*, что ему нужно заменить соответствующий шаблон в строке маршрута 
на строку "about". 

После выполнения классом `PhpRenderer` кода шаблона представления, HTML-разметка будет 
выглядеть следующим образом:

{line-numbers=off, lang=php}
~~~
<!-- Гиперссылка на страницу About -->
<a href="/application/about" > About page </a>

<!-- Гиперссылка на изображение штрих-кода -->
<a href="/application/barcode/code39/HELLO-WORLD" > Barcode image </a>
~~~

В качестве другого примера, давайте сгенерируем URL для маршрута типа *Regex*
(который обслуживает "статические" страницы):

{line-numbers=off, lang=php}
~~~
<!-- Гиперссылка на страницу Introduction -->
<a href="<?= $this->url('doc', ['page'=>'introduction']); ?>">
 Introduction </a>			  
~~~

Таким образом, мы сгенерируем следующую HTML-разметку:

{line-numbers=off, lang=php}
~~~
<!-- Гиперссылка на страницу Introduction -->
<a href="/doc/introduction.html"> Introduction </a>
~~~

#### Генерация абсолютного URL

Если вам необходимо сгенерировать абсолютный URL (содержащий схему и имя хоста),
вы можете указать третий параметр для помощника вида `Url`. Третий параметр
должен быть массивом, содержащим одну или несколько опций. Чтобы собрать
URL, нужно передать опцию `force_canonical`, как показано в примере ниже:

{line-numbers=on, lang=php}
~~~
<!-- Гиперссылка на страницу Home -->
<a href="<?= $this->url('home', [], ['force_canonical' => true]); ?>" > 
  Home page </a>
  
<!-- Гиперссылка на страницу About -->
<a href="<?php echo $this->url('application', ['action' => 'about'],
  ['force_canonical' => true]); ?>" > About page </a>
~~~

В строке 2 данного примера мы передаем имя маршрута "home" в качестве
первого аргумента, пустой массив - в качестве второго и массив, содержащий
опцию `force_canonical` - в качестве третьего. В строках 6-7 мы также передаем
опцию `force_canonical` для генерации URL страницы About.

Получившаяся HTML-разметка будет выглядеть следующим образом:

{line-numbers=off, lang=php}
~~~
<!-- Гиперссылка на страницу Home -->
<a href="http://localhost/" > Home page </a>
  
<!-- Гиперссылка на страницу About -->
<a href="http://localhost/application/index/about" > About page </a>
~~~

#### Задание запроса (Query)

Если вы хотите, чтобы ваш URL имел часть запроса (query), вы можете указать опцию `query` в
качестве третьего аргумента для помощника вида `Url`. Например, предположим, что у вас
есть действие "search" в некотором контроллере (и маршрут, сопоставленный с этим действием),
и вы хотите передать ему строку запроса, а также количество результатов поиска на странице.
URL для этого действия будет выглядеть так: "http://localhost/search?q=topic&count=10".
Для генерации такого URL используйте следующий код:

{line-numbers=off, lang=php}
~~~
<a href="<?= $this->url('search', [], ['force_canonical' => true, 
         'query'=>['q'=>'topic', 'count'=>10]]); ?>" > 
  Search </a>
~~~

В этом коде мы задали опцию `option`, которая является массивом, содержащим пары *имя=>значение*
параметров запроса.

### Генерация URL в контроллерах

Вы можете генерировать URL в методах действия вашего контроллера, используя плагин 
`Url`. Чтобы сгенерировать URL, нужно вызвать метод `fromRoute()` данного плагина,
как показано в примере ниже:

{line-numbers=off, lang=php}
~~~
// Образец метода действия
public function someAction() 
{
    // Генерируем URL, указывающий на страницу Home ('/')
    $url1 = $this->url()->fromRoute('home');
  
    // Генерируем абсолютный URL, указывающий на страницу About
    // ('http://localhost/application/about')
    $url2 = $this->url()->fromRoute('application', 
              ['action'=>'about'], ['force_canonical'=>true]);
}
~~~

T> Аргументы, принимаемые плагином `Url`, а также их значение, идентичны аргументам помощника вида `Url`.
T> Таким образом, вы можете сгенерировать абсолютные или относительные URL так же, как делали это в шаблонах представлений.

### Кодирование URL

При генерации URL как через помощник вида `Url`, так и через плагин контроллера `Url`, следует
помнить, что URL могут содержать только "безопасные" символы из таблицы ASCII. Поэтому, если
вы передадите параметр содержащий небезопасные символы, эти символы будут заменены последовательностью
из знака процента и двух цифр.

Попробуем, например, сгенерировать URL для нашего маршрута типа *Regex* и передать ему
параметр "page" со значением "/chapter1/introduction". 

{line-numbers=off, lang=php}
~~~
<!-- Гиперссылка на страницу Introduction -->
<a href="<?= $this->url('doc', ['page'=>'chapter1/introduction']); ?>">
  Introduction </a>			  
~~~

Можно было бы предположить, что сгенерируется URL вида "/doc/chapter1/introduction.html". Но
из-за того, что слеш ('/') считается небезопасным символом, в целях безопасности он будет заменен 
символами "%2F", и в результате мы получим следующий HTML-код:

{line-numbers=off, lang=text}
~~~
<!-- Гиперссылка на страницу Introduction -->
<a href="/doc/chapter1%2Fintroduction.html"> Introduction </a>
~~~

К сожалению, эта гиперссылка бесполезна, так как она не соответствует
нашему маршруту типа *Regex*. 

## Написание собственного типа маршрута

Хотя ZF3 предоставляет вам множество типов маршрута, в некоторых ситуациях
вам необходимо будет написать свой собственный тип.

Одна из таких ситуаций - когда вам нужно определить правила установления соответствия URL
динамически. Обычно конфигурация маршрутизации хранится в файле конфигурации модуля, но в
некоторых системах управления содержимым документы будут храниться в базе данных. Для таких систем,
вам нужно будет разработать свой тип маршрута, который будет подключаться к БД и выполнять сопоставление
маршрута с данными, хранящимися в базе. Вы не можете хранить эту информацию в файле конфигурации, потому
что новые документы создаются администраторами системы, а не программистами.

### RouteInterface

Как мы знаем, каждый класс маршрута должен реализовывать интерфейс `Zend\Router\Http\RouteInterface`. 
Методы этого интерфейса представлены в таблице 5.4:

{title="Таблица 5.4. Методы RouteInterface"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `factory($options)`            | Статический метод для создания класса маршрута.               |
|--------------------------------|---------------------------------------------------------------|
| `match($request)`              | Метод, который выполняет сопоставление с данными HTTP-запроса. |
|--------------------------------|---------------------------------------------------------------|
| `assemble($params, $options)`  | Метод для генерации URL с помощью параметров маршрута.        |
|--------------------------------|---------------------------------------------------------------|
| `getAssembledParams()`         | Метод для извлечения параметров, которые были использованы для генерации URL. |
|--------------------------------|---------------------------------------------------------------|

Статический метод `factory()` используется маршрутизатором ZF3 (`TreeRouteStack` или `SimpleRouteStack`) 
для инстанцирования класса маршрута. Маршрутизатор передает массив `options` как аргумент для 
метода `factory()`.

Метод `match()` используется для сопоставления HTTP-запроса (или, если быть точнее, его URL)
с опциями, передаваемыми классу маршрута через `factory()`. Метод `match()` должен возвращать
либо экземпляр класса `RouteMatch` при успешном сопоставлении, либо `null` при неудаче.

Метод `assemble()` используется для генерации строки URL с помощью 
параметров маршрута и опций. Назначение метода помощника `getAssembledParams()` -
вернуть массив параметров, которые использовались при генерации URL. 

### Пользовательский класс маршрута

Для демонстрации создания пользовательского типа маршрута, давайте усовершенствуем
наш предыдущий подход к созданию простой системы документации с помощью типа *Regex*.
Недостаток типа *Regex* заключается в том, что вы не можете организовать иерархию
статических страниц, создав подкаталоги под каталогом *doc* (при генерации URL для такой
страницы разделитель директорий в виде слеша будет закодирован, что сделает гиперссылку
недоступной для использования).

Кроме того, класс, который мы создадим будет более мощным, потому что будет не только
распознавать URL, начинающиеся с "/doc" и заканчивающиеся на ".html". Вместо этого,
он будет распознавать общие URL, такие как /help" или "/support/chapter1/introduction".

Чего мы хотим добиться:

* Класс `StaticRoute` должно быть возможно вставить в стек маршрутов (либо в `SimpleRouteStack`, 
  либо в `TreeRouteStack`) и использовать вместе с другими типами маршрутов. 

* Класс маршрута должен распознавать общие URL, такие как "/help" или "/introduction".

* Класс маршрута должен сопоставлять URL со структурой каталогов. Пусть, например, есть
  URL - "/chapter1/introduction", тогда маршрут должен проверить, существует ли соответствующий 
  файл шаблона представления *&lt;base_dir&gt;/chapter1/introduction.phtml* и возможно ли его прочесть, 
  и если это так, сообщить о соответствии. Если файла не существует (или его не прочесть), должен
  возвращаться статус ошибки.
  
* Класс маршрута должен проверять URL на допустимость имен файлов, используя регулярное выражение.
  Например, имя файла "introduction" является допустимым, в то время как имя "*int$roduction" - нет.
  Если имя файла недопустимо, должен возвращаться статус ошибки.
  
* Маршрут должен уметь собирать строку URL с помощью имени и параметров.
  
Для начала создайте подкаталог *Route* под корневым каталогом модуля
и поместите туда файл *StaticRoute.php* (рисунок 5.9).

![Рисунок 5.9. Файл StaticRoute.php](../en/images/routing/static_route_php.png)

Вставьте приведенный ниже кусок кода в этот файл:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Route;

use Traversable;
use \Zend\Router\Exception;
use \Zend\Stdlib\ArrayUtils;
use \Zend\Stdlib\RequestInterface as Request;
use \Zend\Router\Http\RouteInterface;
use \Zend\Router\Http\RouteMatch;

// Пользовательский маршрут, обслуживающий "статические" веб-страницы.
class StaticRoute implements RouteInterface
{
    // Создаем новый маршрут с заданными опциями.
    public static function factory($options = []) 
    {
    }

    // Сопоставляем данный запрос.
    public function match(Request $request, $pathOffset = null) 
    {
    }

    // Составляем URL с помощью параметров маршрута.
    public function assemble(array $params = [], array $options = []) 
    {
    }

    // Получаем список параметров, использованных при составлении URL.
    public function getAssembledParams() 
    {    
    }
}
~~~

Как видите, мы разместили класс `StaticRoute` в 
пространстве имен `Application\Route` (строка 2). 

В строках 4-9 мы определяем несколько псевдонимов имен классов,
чтобы сделать эти имена короче.

В строках 12-33 мы определяем скелет класса `StaticRoute`. Класс `StaticRoute`
реализует интерфейс `RouteInterface` и определяет все методы, указанные
интерфейсом: `factory()`, `match()`, `assemble()` и `getAssembledParams()`.

Теперь давайте добавим несколько защищенных свойств и метод конструктора в
класс `StaticRoute`, как показано ниже:

{line-numbers=on, lang=php}
~~~
<?php
//...

class StaticRoute implements RouteInterface
{
    // Базовый каталог представления.
    protected $dirName;
    
    // Префикс пути для шаблонов представления.
    protected $templatePrefix;

    // Шаблон имени файла.
    protected $fileNamePattern = '/[a-zA-Z0-9_\-]+/';
    
    // Умолчания.
    protected $defaults;

    // Список собранных параметров.
    protected $assembledParams = [];
  
    // Конструктор.
    public function __construct($dirName, $templatePrefix, 
            $fileNamePattern, array $defaults = [])
    {
        $this->dirName = $dirName;
        $this->templatePrefix = $templatePrefix;
        $this->fileNamePattern = $fileNamePattern;
        $this->defaults = $defaults;
    }
  
    // ...
}
~~~

В строке 7 представленного фрагмента мы определяем свойство `$dirName`, которое
предназначено для хранения имени базового каталога, где будут располагаться
"статические" шаблоны представлений. В строке 10 мы определяем переменную класса
`$templatePrefix` для хранения префикса, который будет прибавляться ко всем
именам шаблонов представлений. Строка 13 содержит переменную `$fileNamePattern`,
которая будет использоваться для проверки имени файла. 

В строках 22-29 мы определяем метод конструктора, который вызывается при создании
экземпляра для инициализации защищенных свойств.

Далее, давайте реализуем метод `factory()` для созданного нами класса маршрута `StaticRoute`.
Метод `factory()` будет вызываться маршрутизатором для инстанцирования класса маршрута:

{line-numbers=on, lang=php}
~~~
<?php
//...

class StaticRoute implements RouteInterface
{
    //...
  
    // Создаем новый маршрут с заданными опциями.
    public static function factory($options = [])
    {
        if ($options instanceof Traversable) {
            $options = ArrayUtils::iteratorToArray($options);
        } elseif (!is_array($options)) {
            throw new Exception\InvalidArgumentException(__METHOD__ . 
                ' expects an array or Traversable set of options');
        }

        if (!isset($options['dir_name'])) {
            throw new Exception\InvalidArgumentException(
                'Missing "dir_name" in options array');
        }
	
        if (!isset($options['template_prefix'])) {
            throw new Exception\InvalidArgumentException(
                'Missing "template_prefix" in options array');
        }
	
        if (!isset($options['filename_pattern'])) {
            throw new Exception\InvalidArgumentException(
                'Missing "filename_pattern" in options array');
        }
			
        if (!isset($options['defaults'])) {
            $options['defaults'] = [];
        }

        return new static(
            $options['dir_name'], 
            $options['template_prefix'], 
            $options['filename_pattern'], 
            $options['defaults']);
        }  
}
~~~

В этом коде мы видим, что метод `factory()` принимает массив `options` 
в качестве аргумента (строка 9). Этот массив может содержать опции
для конфигурации класса маршрута. Для класса `StaticRoute` доступны
следующие опции:

* `dir_name` - базовый каталог, где хранятся все "статические" шаблоны представлений.
* `template_prefix` - префикс для всех имен шаблонов.
* `filename_pattern` -  регулярное выражение для проверки имен файлов.
* `defaults` - параметры, возвращаемые маршрутизатором по умолчанию.

После разбора опций, в строках 37-41 мы вызываем метод конструктора класса, чтобы
инстанцировать и вернуть объект `StaticRoute`.

Следующий метод, который мы добавим к классу маршрута `StaticRoute` - это метод `match()`:

{line-numbers=on, lang=php}
~~~
<?php
//...

class StaticRoute implements RouteInterface
{
    //...

    // Сопоставляем заданный запрос.
    public function match(Request $request, $pathOffset=null)
    {
        // Гарантируем, что этот тип маршрута используется в HTTP-запросе
        if (!method_exists($request, 'getUri')) {
            return null;
        }

    // Получаем URL и его путь.
    $uri  = $request->getUri();
    $path = $uri->getPath();
	
    if($pathOffset!=null) 
      $path = substr($path, $pathOffset);
	 
    // Получаем массив сегментов пути.
    $segments = explode('/', $path);
			
    // Сверяем каждый сегмент с допустимым шаблоном имени файла
    foreach ($segments as $segment) {            
      if(strlen($segment)==0)
        continue;
      if(!preg_match($this->fileNamePattern, $segment))
        return null;
    }
	
    // Проверяем, существует ли такой файл .phtml на диске    
    $fileName = $this->dirName . '/'. 
                $this->templatePrefix.$path.'.phtml';                
    if(!is_file($fileName) || !is_readable($fileName)) {
      return null;
    }
			
    $matchedLength = strlen($path); 
	
	// Подготавливаем объект RouteMatch.
    return new RouteMatch(array_merge(
              $this->defaults, 
              ['page'=>$this->templatePrefix.$path]
             ), 
             $matchedLength);
  }
}
~~~

Как мы видим, метод `match()` принимает два аргумента: объект
HTTP-запроса (экземпляр класса `Zend\Stdlib\Request`) и смещение
пути URL. Объект запроса используется для доступа к URL запроса (строка 17).
Параметр смещения пути - это неотрицательное число типа integer, которое
указывает часть URL, с которой сопоставляется маршрут (строка 21).

В строке 24 мы извлекаем сегменты URL. После этого мы проверяем, является ли
каждый сегмент допустимым именем файла (строки 27-32). Если сегмент не
является действительным именем файла, мы возвращаем `null` в качестве статуса ошибки.

В строке 35 мы вычисляем путь к шаблону представления, а в строках 37-39 проверяем,
действительно ли такой файл существует и доступен для чтения. Таким образом мы сопоставляем
URL со структурой каталогов.

В строках 44-48 мы подготавливаем и возвращаем объект `RouteMatch` с параметрами по умолчанию,
а также параметром "page" с именем шаблона представления для визуализации.

Чтобы завершить реализацию нашего класса `StaticRoute`, добавим методы `assemble()` и 
`getAssembledParams()`, которые будут использоваться для генерации URL с помощью параметров
маршрута. Код для этих методов представлен ниже:

{line-numbers=on, lang=php}
~~~
<?php
//...

class StaticRoute implements RouteInterface
{
    //...

    // Собирает URL с помощью параметров маршрута
    public function assemble(array $params = [], 
                           array $options = [])
    {
        $mergedParams = array_merge($this->defaults, $params);
        $this->assembledParams = [];
	
        if(!isset($params['page'])) {
            throw new Exception\InvalidArgumentException(__METHOD__ . 
               ' expects the "page" parameter');
        }
	
        $segments = explode('/', $params['page']);
        $url = '';
        foreach($segments as $segment) {
            if(strlen($segment)==0)
                 continue;
            $url .= '/' . rawurlencode($segment);
        }
	
        $this->assembledParams[] = 'page';
	
        return $url;
    }

    // Получаем список параметров, использованных при сборке URL.
    public function getAssembledParams()
    {
        return $this->assembledParams;
    }
}
~~~

В этом фрагменте мы определили метод `assemble()`, который принимает два аргумента:
массив `parameteres` и массив `options` (строка 9).
Метод строит URL путем кодирования сегментов и их объединения (строки 10-26).

Метод `getAssembledParams()` просто возвращает имена параметров,
которые мы использовали для генерации URL.

Итак, мы закончили класс маршрута `StaticRoute`. Чтобы теперь использовать пользовательский тип
маршрута, добавим следующую конфигурацию в файл конфигурации *module.config.php*:

{line-numbers=on, lang=php}
~~~
'static' => [
    'type' => StaticRoute::class,
    'options' => [
        'dir_name'         => __DIR__ . '/../view',
        'template_prefix'  => 'application/index/static',
        'filename_pattern' => '/[a-z0-9_\-]+/',
        'defaults' => [
            'controller' => Controller\IndexController::class,
            'action'     => 'static',
        ],                    
    ],
],
~~~

В строке 1 приведенной выше конфигурации, мы определяем правило маршрутизации "static".
Параметр `type` определяет полностью определенное имя класса `StaticRoute` (строка 2).
В массиве `options` мы определяем базовый каталог, где будут располагаться "статические" 
страницы (строка 4), а также определяем префикс шаблона (строка 5), шаблон имени файла (строка 6)
и массив `defaults`, содержащий имя контроллера и действие, которое будет обслуживать
все статические страницы.

I> Не забудьте вставить следующую строчку в начало класса `module.config.php`:
I>
I> `use Application\Route\StaticRoute;`

Последний шаг - создание метода действия в классе `IndexController`:

{line-numbers=on, lang=php}
~~~
public function staticAction() 
{
    // Получаем путь к шаблону представления от параметров маршрута
    $pageTemplate = $this->params()->fromRoute('page', null);
    if($pageTemplate==null) {
        $this->getResponse()->setStatusCode(404); 
        return;
    }
	
    // Визуализируем страницу
    $viewModel = new ViewModel([
            'page'=>$pageTemplate
        ]);
    $viewModel->setTemplate($pageTemplate);
    return $viewModel;
}
~~~

Действие выше почти идентично действию, которое мы использовали для маршрута *Regex*.
В строке 4 мы извлекаем из маршрута параметр `page` и сохраняем его, как переменную
`$pageTemplate`. В строке 11 мы создаем контейнер для переменных `ViewModel`, а в
строке 14 мы явно задаем имя шаблона представления для визуализации.

Чтобы увидеть систему в действии, давайте добавим пару "статических" страниц представления:
страницу Help (`help.phtml`) и страницу Introduction (`intro.phtml`).
Создадим подкаталог *static* под каталогом *view/application/index* модуля `Application`
и поместим туда шаблон представления *help.phtml*:

{line-numbers=off, lang=php}
~~~
<h1>Help</h1>

<p>
    See the help <a href="<?= $this->url('static', 
	   ['page'=>'/chapter1/intro']); ?>">introduction</a> here.
</p>
~~~

Затем создадим подкаталог *chapter1* в каталоге *static* и помещаем
туда следующий файл *chapter1/intro.phtml*:

{line-numbers=off, lang=php}
~~~
<h1>Introduction</h1>

<p>
   Напишите здесь введение.
</p>
~~~

В итоге, мы должны получить такую структуру каталогов (см. рисунок 5.10):

![Рисунок 5.10. Статические страницы](../en/images/routing/static_page_dir.png)

Наконец, откройте следующий URL в вашем браузере: *http://localhost/help*. Должна
появиться страница Help (см. рисунок 5.11). Если вы введете URL *http://localhost/chapter1/intro*
в свой браузер, вы должны будете увидеть страницу Introduction (рисунок 5.12).

![Figure 5.11. Страница Help](../en/images/routing/help_page.png)

![Figure 5.12. Страница Introduction](../en/images/routing/chapter1_intro.png)

Вы можете создавать статические страницы просто добавляя файлы phtml под каталог
*static*, и они автоматически станут доступны для пользователей сайта.

T> Если вы застряли, можете найти корректно работающую версию этого примера
T> внутри приложения *Hello World*.

## Выводы

В этой главе мы узнали о маршрутизации. Маршрутизация используется для установления
соответствия HTTP-запроса с методом действия контроллера. Существует несколько типов 
маршрутов (*Literal*, *Segment*, *Regex*, *Hostname*, *Scheme*, *Method* и т.д.).
Каждый тип маршрута использует разные части URL (а также, возможно, другие данные HTTP-запроса),
чтобы сравнить URL с указанным шаблоном маршрута. Мы также узнали, как написать пользовательский
класс маршрута, если возможностей стандартных типов недостаточно.

Главная задача класса маршрута - вернуть набор параметров, которые содержит сопоставленный маршрут,
по которым могут быть определены контроллер и действие. В то же время, обратная задача позволяет генерировать
URL с использованием этих параметров. Это широко используется в слое представления приложения для
генерации гиперссылок.

Типы маршрутов могут быть объединены либо во вложенное дерево с помощью маршрутизатора `TreeRouteStack`,
либо в цепь с помощью `SimpleRouteStack`. Эти два маршрутизатора позволяют определить
сколь угодно сложные правила.

Конфигурация маршрутизации хранится в файле конфигурации модуля под ключом `router`.
Каждый модуль выставляет свои правила маршрутизации, которые объединяются с конфигурацией
других модулей при запуске приложения.
