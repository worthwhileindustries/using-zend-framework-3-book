# Продвинутое использование форм {#advanced-forms}

В предыдущих главах вы узнали об основах использования форм: какие
существуют HTML-формы и как определять модели форм и их представление
в Zend Framework 3. В этой главе мы рассмотрим продвинутые темы, касающиеся
использования форм, такие как элементы форм безопасности (CAPTCHA и CSRF) и т.д. 

Компоненты ZF3, рассматриваемые в этой главе:

|--------------------------------|---------------------------------------------------------------|
| *Компонент*                    | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Captcha`                 | Реализует различные алгоритмы CAPTCHA.                        |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Form`                    | Содержит базовые классы моделей форм.                         |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Filter`                  | Содержит различные классы фильтров.                           |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Validator`               | Реализует различные классы валидаторов.                       |
|--------------------------------|---------------------------------------------------------------|
| `Zend\InputFilter`             | Реализует контейнер для фильтров/валидаторов.                 |
|--------------------------------|---------------------------------------------------------------|

## Элементы безопасности форм

Мы рассмотрим использование двух предоставляемых Zend Framework 3
элементов безопасности форм: `Captcha` и `Csrf` (оба класса принадлежат
пространству имен `Zend\Form\Element`). Добавление этих элементов на модель
формы (и их визуализация в шаблоне представления) сделает вашу форму устойчивой
к хакерским атакам.

### CAPTCHA

CAPTCHA (расшифровывается как "Completely Automated Public Turing test to 
tell Computers and Humans Apart" - "полностью автоматизированный публичный тест 
Тьюринга для различения компьютеров и людей") - это тест типа «вызов - ответ», 
используемый веб-сайтами, чтобы определить, кем является пользователь: человеком или роботом.

Существует несколько типов CAPTCHA. Самый распространенный требует от пользователя
ввести с клавиатуры буквы с искаженного изображения, показываемого на веб-странице
(см. рисунок 11.1).

![Рисунок 11.1. Примеры CAPTCHA](../en/images/forms_advanced/captcha_types.png)

Типичный тест CAPTCHA использует следующий алгоритм:

1. На стороне сервера генерируется некая скрытая последовательность символов (слово).
2. Секретное слово сохраняется в переменной сессии PHP.
3. На основе секретного слова генерируется искаженное изображение.
   Затем оно отображается пользователю сайта на веб-странице.
4. Пользователю предлагается ввести показанные на изображении символы.
5. Если введенные пользователем символы совпадают с секретным словом,
   сохраненным в сессии, тест считается пройденным.

Целью теста CAPTCHA является защита форм от заполнения и отправки 
автоматическим процессом (так называемым роботом). Обычно такие роботы
рассылают спам-сообщения на форумах, взламывают пароли на формах входа на сайт
или совершают какие-либо другие вредоносные действия.

I> Тест CAPTCHA позволяет надежно различать людей и роботов, потому что люди
I> легко могут распознать и воспроизвести символы с искаженного изображения,
I> в отличие от роботов, которые этого не умеют (на данном этапе эволюции
I> алгоритмов компьютерного зрения).

#### Типы CAPTCHA

В Zend Framework 3 доступно несколько типов CAPTCHA (все принадлежат
компоненту `Zend\Captcha`):

* *Dumb.* Это очень простой алгоритм CAPTCHA, который требует от пользователя 
  ввести буквы слова в обратном порядке. Мы не будем рассматривать этот тип
  детально, так как он предоставляет слишком низкий уровень защиты.
 
 * *Image.* Алгоритм CAPTCHA, искажающий изображение добавлением
   шума в виде точек и кривых линий (рисунок 11.1, а).
 
 * *Figlet.* Редкий тип CAPTCHA, использующий программу FIGlet вместо алгоритма 
   искажения изображения. FIGlet - это открытое программное обеспечение, генерирующее
   изображение CAPTCHA множества ASCII-букв (рисунок 11.1, б).
 
Компонент `Zend\Captcha` предоставляет единообразный интерфейс для всех типов 
CAPTCHA (интерфейс `AdapterInterface`). Базовый класс `AbstractAdapter` реализует
этот интерфейс, и все остальные алгоритмы CAPTCHA наследуются от абстрактного
класса адаптера [^адаптер]. Диаграмма наследования классов показана ниже на рисунке 11.2.
 
![Рисунок 11.2. Классы адаптеров CAPTCHA](../en/images/forms_advanced/captcha_adapters.png)

[^адаптер]: *Адаптер* - это шаблон проектирования, который преобразовывает интерфейс класса в 
            совместимый интерфейс, что позволяет двум (или нескольким) несовместимым интерфейсам 
			работать вместе. Как правило, у алгоритмов CAPTCHA различаются public-методы, но, так
			как они все реализуют интерфейс `AbstractAdapter`, их все можно использовать
			одним и тем же способом (вызывая методы, предоставляемые базовым интерфейсом)

Как видите из рисунка 11.2, существует еще один базовый класс для всех типов CAPTCHA,
который использует некое секретное слово из символов: класс `AbastractWord`. Этот
базовый класс предоставляет методы для генерации случайной последовательности символов
и для настройки опций генерации слов.
			
#### Элемент формы CAPTCHA и помощник вида

ZF3 предоставляет специальный класс элемента формы и класс помощника вида для использования полей CAPTCHA на формах.

Чтобы добавить поле CAPTCHA к модели формы, используйте класс `Captcha`, который принадлежит компоненту `Zend\Form`
и "живет" в пространстве имен `Zend\Form\Element`.

Класс элемента `Captcha` может быть использован с любым алгоритмом CAPTCHA (перечислены
в предыдущем разделе) из компонента `Zend\Captcha`. Для этой цели, класс элемента имеет
метод `setCaptcha()`, который принимает либо экземпляр класса, реализующего интерфейс
`Zend\Captcha\AdapterInterface`, либо массив, содержащий настройку CAPTCHA [^массив].
Методом `setCaptcha()` можно добавить к элементу желаемый тип CAPTCHA.

[^массив]: Во втором случае (описание в виде массива) алгоритм CAPTCHA будет
           автоматически инстанцирован и инициализирован классом фабрики `Zend\Captcha\Factory`.
		  
Элемент `Captcha` добавляется к модели формы обычным способом, через метод `add()`,
предоставляемый базовым классом `Zend\Form\Form`. Как обычно, вы можете передать методу
либо экземпляр класса `Zend\Form\Element\Captcha`, либо массив опций конфигурации для
конкретного алгоритма CAPTCHA (в этом случае элемент и его алгоритм CAPTCHA будут автоматически
инстанцированы и настроены классом фабрики).
		  
Пример кода ниже показывает, как использовать второй способ (передача конфигурации в виде массива).
Мы предпочитаем его, так как он требует меньше кода. Предполагается, что вы вызываете этот код
внутри protected-метода addElements()` модели формы:

{line-numbers=on, lang=php}
~~~
<?php
// Добавляем поле CAPTCHA к модели формы
$this->add([
  'type'  => 'captcha',
  'name' => 'captcha',
  'options' => [
    'label' => 'Human check',
    'captcha' => [
      'class' => '<captcha_class_name>', //
      // Здесь идут опции для конкретного класса ...
    ],
  ],
]);
~~~

В этом фрагменте мы вызываем метод `add()`, предоставляемый базовым классом `Form`,
и передаем ему описание элемента, который хотим добавить, в виде массива (строка 3):

 * Ключ массива `type` (строка 4), как и обычно, может быть либо полностью определенным именем класса
   элемента (`Zend\Form\Element\Captcha`), либо его псевдонимом ("captcha").
 * Ключ `name` (строка 5) - это значение атрибута "name" поля HTML-формы.
 * Ключ `options` содержии опции для присоединенного алгоритма CAPTCHA.
 * Ключ `class` (строка 9) может содержать либо полное имя класса CAPTCHA (например, `Zend\Captcha\Image`),
   либо его псевдоним (например, "Image"). Другие опции, специфичные для определенного адаптера, также
   могут быть добавлены к этому ключу. Немного позже мы покажем, как это сделать.

Для генерации HTML-разметки для элемента, можно использовать класс помощника вида `FormCaptcha`
(принадлежащий пространству имен `Zend\Form\View\Helper`). Однако, как вы могли узнать из предыдущей
главы, как правило, вместо этого используется общий помощник вида `FormElement`, как показано в коде ниже:
   
{line-numbers=off, lang=text}
~~~
<?= $this->formElement($form->get('captcha')); ?>
~~~

Предполагается, что вы вызываете помощник вида внутри шаблона представления.

Далее мы приведем два примера, показывающие, как использовать два разных типа CAPTCHA, 
предоставляемых ZF3: `Image` и `Figlet`. Мы покажем, как добавить поле CAPTCHA к форме
обратной связи, которую мы использовали в примерах предыдущих глав.

#### Пример 1: Добавление CAPTCHA типа Image к ContactForm

W> Для CAPTCHA типа Image требуется установленное PHP-расширение GD с поддержкой PNG 
W> и шрифтами FT. 

Чтобы добавить CAPTCHA `Image` к модели формы, вызовите метод формы
`add()` как показано ниже:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Form;
// ...

class ContactForm extends Form
{
    // ...    
    protected function addElements() 
    {
        // ...         
       
        // Add the CAPTCHA field
        $this->add([
            'type'  => 'captcha',
            'name' => 'captcha',
            'attributes' => [
            ],
            'options' => [
                'label' => 'Human check',
                'captcha' => [
                    'class' => 'Image',
                    'imgDir' => 'public/img/captcha',
                    'suffix' => '.png',
                    'imgUrl' => '/img/captcha/',
                    'imgAlt' => 'CAPTCHA Image',
                    'font'   => './data/font/thorne_shaded.ttf',
                    'fsize'  => 24,
                    'width'  => 350,
                    'height' => 100,
                    'expiration' => 600, 
                    'dotNoiseLevel' => 40,
                    'lineNoiseLevel' => 3
                ],
            ],
        ]);
    }
}
~~~

В этом фрагменте ключ массива конфигурации `captcha` (строка 20) содержит следующие
параметры для настройки алгоритма CAPTCHA `Image`, присоединенного к элементу формы:


 * параметр `class` (строка 21) должен быть либо полностью определенным именем класса 
   адаптера CAPTCHA (`\Zend\Captcha\Image`), либо его псевдоним (`Image`).
   
 * параметр `imgDir` parameter (line 22) должен быть путем к каталогу, куда нужно 
   сохранять сгенерированные искаженные изображения (в этом примере мы будем сохранять)
   изображения в каталог *APP_DIR/public/img/captcha*).
 
 * параметр `suffix` (строка 23) определяет расширение для сгенерированного файла
   изображения (в этом примере - ".png").
 
 * параметр `imgUrl` (строка 24) определяет базовую частью URL для открытия сгенерированных
   изображений CAPTCHA в веб-браузере. В этом примере посетители сайта смогут обратиться к
   изображениям CAPTCHA используя URL типа "http://localhost/img/captcha/&lt;ID&gt;", где ID - 
   уникальный идентификатор определенного изображения.
 
 * опциональный параметр `imgAlt` (строка 25) - это альтернативный текст, который показывается, если изображение
   CAPTCHA не может быть загружено браузером (атрибут "alt" тега `<img>).
 
 * параметр `font` (строка 26) - это путь к файлу шрифта. Вы можете скачать бесплатный шрифт TTF, 
   например, [отсюда](http://www.1001freefonts.com/). В этом примере мы используем шрифт *Thorne Shaded*, 
   который мы скачали и поместили в файл *APP_DIR/data/font/thorne_shaded.ttf*.
 
 * параметр `fsize` (строка 27) - положительное число типа integer, определяющее размер шрифта.
 
 * параметры `width` (строка 28) и `height` (строка 29) определяют соответственно ширину и высоту (в пикселях) 
   сгенерированного изображения.
 
 * параметр `expiration` (строка 30) определяет срок действия изображений CAPTCHA (в секундах). 
   Как только срок действия изображения истекает, оно удаляется с диска.
 
 * параметры `dotNoiseLevel` (строка 31) и `lineNoiseLevel` (строка 32) определяют
   опции генерации изображения (уровни точечного и линейного шумов соответственно).

Для визуализации поля CAPTCHA добавьте следующие строки в файл шаблона
представления *contact-us.phtml* :
   
{line-numbers=off, lang=php}
~~~
<div class="form-group">
  <?= $this->formLabel($form->get('captcha')); ?>
  <?= $this->formElement($form->get('captcha')); ?>
  <?= $this->formElementErrors($form->get('captcha')); ?>
  <p class="help-block">Введите буквы, которые вы видите на изображении выше.<p>
</div>
~~~

Теперь создадим каталог *APP_DIR/public/img/captcha*, который будет хранить сгенерированные
изображение CAPTCHA. Отрегулируем права доступа к каталогу, чтобы он был доступным для записи 
для веб-сервера Apache. В Linux Ubuntu это, как правило, совершается следующими командами оболочки 
(замените плейсхолдер `APP_DIR` именем каталога вашего веб-приложения):

`mkdir APP_DIR/public/img/captcha`

`chown -R www-data:www-data APP_DIR`

`chmod -R 775 APP_DIR`

Команда `mkdir` создает каталог, а команды `chown` и `chmod` соответственно назначают 
пользователя Apache владельцем каталога и позволяют веб-серверу записывать данные в каталог.

Если вы теперь откроете страницу "http://localhost/contactus" в своем браузере,
будет сгенерировано изображение CAPTCHA, основанное на случайной последовательности
букв и цифр, сохраненных в сессии. Вы должны будете увидеть что-то вроде рисунка 11.3.

![Рисунок 11.3. CAPTCHA типа Image](../en/images/forms_advanced/image_captcha_page.png)

Когда вы заполните поля формы и нажмете кнопку *Submit*, введенные в поле *Human check*
буквы будут переданы серверу как часть HTTP-запроса. Затем, при валидации формы, класс
`Zend\Form\Element\Captcha` сравнит отправленные буквы с теми, что хранятся в PHP-сессии.
Если буквы идентичны, форма считается действительной; иначе форма не проходит валидацию.

Как только визуализатор PHP обработает шаблон представления, он сгенерирует HTML-разметку
для элемента CAPTCHA как показано ниже:

{line-numbers=off, lang=text}
~~~
<div class="form-group">
  <label for="captcha">Human check</label>
  <img width="350" height="100" alt="CAPTCHA Image" 
       src="/img/captcha/df344b37500dcbb0c4d32f7351a65574.png">
  <input name="captcha[id]" type="hidden" 
         value="df344b37500dcbb0c4d32f7351a65574">
  <input name="captcha[input]" type="text">                              
  <p class="help-block">Введите буквы, которые вы видите на изображении выше.</p>
</div>
~~~

#### Пример 2: Добавление CAPTCHA типа FIGlet к ContactForm 

Для использования на форме элемента CAPTCHA типа FIGlet, замените определение
элемента формы из предыдущего примера следующим кодом:

{line-numbers=on, lang=php}
~~~
<?php
// Добавляем поле CAPTCHA
$this->add([
	'type'  => 'captcha',
	'name' => 'captcha',
	'attributes' => [                                                
	],
	'options' => [
		'label' => 'Human check',
		'captcha' => [
			'class' => 'Figlet',
			'wordLen' => 6,
			'expiration' => 600,                     
		],
	],
]);
~~~

В этом фрагменте ключ массива конфигурации `captcha` (строка 10) содержит следующие
параметры для настройки алгоритма CAPTCHA `Figlet`, присоединенного к элементу формы:

 * параметр `class` (строка 11) должен быть либо полностью определенным именем класса 
   адаптера CAPTCHA (`\Zend\Captcha\Figlet`), либо его псевдоним (`Figlet`).
   
 * параметр `wordLen` (строка 12) длину генерируемого секретного слова.
 
 * параметр `expiration` (строка 13) определяет срок действия CAPTCHA (в секундах).
   
Теперь откройте страницу "http://localhost/contactus" в своем браузере. Вы должны будете
увидеть страницу как на рисунке 11.4 ниже.
   
![Рисунок 11.4. CAPTCHA типа FIGlet](../en/images/forms_advanced/figlet_captcha_page.png)

Как только визуализатор PHP обработает шаблон представления, он сгенерирует HTML-разметку
для элемента CAPTCHA как показано ниже:

{line-numbers=off, lang=text}
~~~
<div class="form-group">
  <label for="captcha">Проверка пользователя</label>            
    <pre> 
 __   _    __   __   _    _      ___     _    _    __   __  
| || | ||  \ \\/ // | \  / ||   / _ \\  | || | ||  \ \\/ // 
| '--' ||   \ ` //  |  \/  ||  | / \ || | || | ||   \ ` //  
| .--. ||    | ||   | .  . ||  | \_/ || | \\_/ ||    | ||   
|_|| |_||    |_||   |_|\/|_||   \___//   \____//     |_||   
`-`  `-`     `-`'   `-`  `-`    `---`     `---`      `-`'   
                                                           
</pre>
<input name="captcha[id]" type="hidden" 
       value="b68b010eccc22e78969764461be62714">
<input name="captcha[input]" type="text">                              
<p class="help-block">Введите буквы, которые вы видите на изображении выше.</p>
</div>
~~~

### Предотвращение подделки межсайтовых запросов (CSRF)

Подделка межсайтовых запросов (Сross Site Request Forgery - CSRF) - тип хакерской атаки,
заставляющий браузер пользователя передать HTTP-запрос произвольному сайту. Через атаку
CSRF вредоносный скрипт может послать неавторизованные команды от доверенного пользователя.
Такая атака, как правило, совершается на страницы, содержащие формы для отправки каких-либо 
уязвимых данным (например, формы для перевода денег, корзины и т.д.)

Чтобы лучше понять, как работает эта атака, посмотрите на рисунок 11.5.

![Рисунок 11.5. Пример CSRF-атаки](../en/images/forms_advanced/csrf_scheme.png)

Рисунок 11.5 демонстрирует пример CSRF-атаки на веб-сайт платежного шлюза:

1. Вы заходите на свой аккаунт на сайте платежного шлюза *https://payment.com*. Заметьте,
   что в данном случае используется SSL-защищенное соединение (HTTPS), но оно не защищает
   от такого рода атак.
   
2. Как правило, вы устанавливаете флажок формы входа на сайт "Remember Me" (запомнить меня), чтобы
   избежать слишком частого ввода своих имени пользователя и пароля. Как только вы заходите на свой 
   аккаунт, ваш браузер сохраняет информацию о сессии в переменную cookie на вашем компьютере.
   
3. На сайте платежного шлюза вы используете платежную форму *https://payment.com/moneytransfer.php* для
   покупки товаров. Обратите внимание, что эта форма позже будет использована в качестве уязвимости, что
   позволит осуществить CSRF-атаку.
   
4. Затем вы используете этот же браузер, чтобы посетить какой-либо сайт. Предположим,
   это будет веб-сайт с классными картинками *http://coolpictures.com*. К сожалению,
   этот сайт заражен вредоносным скриптом, замаскированным под HTML-тег `<img src="image.php">`.
   Как только вы откроете HTML-страницу в своем браузере, она загрузит все свои изображения,
   тем самым выполним вредоносный скрипт *image.php*.
   
5. Вредоносный скрипт проверяет переменную cookie и, если таковая есть, он
   совершает захват сессии (session riding), что позволяет ему действовать
   от имени залогиненного пользователя. Теперь скрипт может отправлять данные
   платежной формы на сайт платежного шлюза.

I> Описанная выше CSRF-атака возможна в том случае, если веб-форма на сайте платежного 
I> шлюза не проверяет источник HTTP-запроса. Те, кто занимается поддержкой подобных сайтов,
I> должны уделять больше внимания созданию максимально безопасных форм.

Чтобы предотвратить CSRF-атаку на форму, необходимо требовать специальный токен формы. Эта процедура описана ниже:

To prevent CSRF attacks to a form, one has to require a special token with the form, as follows:

1. Для определенной формы генерируется случайная последовательность байт (токен)
   и сохраняется на стороне сервера в данных PHP-сессии.

2. К форме добавляется скрытое поле, его значение задается токеном.

3. Когда пользователь отправляет форму, скрытое значение, переданное в форме,
   сравнивается с токеном, сохраненном на стороне сервера. Если они совпадают,
   данные формы считаются безопасными.

I> Если вредоносный пользователь попробует атаковать сайт через отправку формы, 
I> он не сможет поместить нужный токен в форму перед отправкой, так как токен
I> не хранится в файлах cookie.

#### Пример: добавление к форме элемента CSRF

В Zend Framework 3, чтобы добавить CSRF-защиту к модели формы,
используется класс элемента формы `Zend\Form\Element\Csrf`.

I> У элемента `Csrf` нет визуального представления (вы не увидите его на экране).

Чтобы добавить элемент CSRF к модели формы, добавьте следующие строки в метод `addElements()`:

{line-numbers=on, lang=php}
~~~
// Добавляем поле CSRF
$this->add([
  'type'  => 'csrf',
  'name' => 'csrf',
  'options' => [                
    'csrf_options' => [
      'timeout' => 600
    ]
  ],
]);
~~~

В этом фрагменте мы используем метод `add()` класса `Form` (строка 2), которому передается
описание элемента CSRF в виде массива. Элемент будет автоматически инстанцирован и инициализирован
фабрикой.

В строке 3 мы указываем имя класса для элемента CSRF. Это может быть либо полностью определенное
имя класса (`Zend\Form\Element\Csrf`), либо псевдоним ("csrf").

В строке 4 мы задаем атрибут "name" для элемента. В этом примере мы используем имя "csrf",
но вы можете использовать любое другое имя по вашему выбору.

В строке 6, внутри массива `csrf_options`, мы указываем опции для класса `Zend\Form\Element\Csrf`.
Мы задаем значение опции `timeout`, равное 600 (строка 7), что значит, срок действия CSRF-проверки
закончится спустя 600 секунд (10 минут) после создания формы.

Для визуализации поля CSRF добавьте следующую строку в файл шаблона представления *.phtml*:

{line-numbers=off, lang=php}
~~~
<?= $this->formElement($form->get('csrf')); ?>
~~~

Как только визуализатор PHP обработает шаблон представления, он сгенерирует HTML-разметку
для поля CSRF как показано ниже:

{line-numbers=off, lang=text}
~~~
<input type="hidden" name="csrf" value="1bc42bd0da4800fb55d16e81136fe177"> 
~~~

T> Как видите из кода разметки выше, форма теперь содержит скрытое поле со случайно
T> сгенерированным токеном. Так как атакующий скрипт не знает этот токен, он не сможет
T> отправить его корректное значение, тем самым CSRF-атака будет предотвращена.

Q> **Что происходит при неудачной валидации элемента CSRF?**
Q>

Q> Если при валидации формы CSRF-проверка завершается неудачей, форма считается
Q> недействительной, и она будет снова показана пользователю для исправления ошибок,
Q> однако он не увидит сообщения об ошибке для элемента CSRF (мы не хотим, чтобы
Q> хакеры знали наверняка, что не так с формой). 

## Использование групп валидации

Иногда может быть полезно временно отключить валидацию некоторых элементов формы. Вы можете сделать это с помощью такой
особенности, как *группы валидации* (validation groups).

I> По умолчанию, все элементы формы проходят валидацию. Группа валидации позволяет отключить валидацию некоторых полей. 

Для примера, представим, что вам нужно реализовать форму под названием `PaymentForm`, которая позволяет выбирать метод оплаты из нескольких альтернатив 
(кредитная карта, банковский перевод и наличные). Если пользователь выбирает кредитную карту, вам также будет нужно дать ему возможность
ввести номер кредитной карты; если пользователь выбирает банковский перевод, вам будет нужно отобразить поле ввода номера банковского счета;
и наконец, в случае выбора наличных ничего показывать дополнительно не нужно.

T> Для данной формы вам понадобится динамически показывать и скрывать зависимые поля формы в браузере клиента с помощью JavaScript.

Как мы будем валидировать такую форму в действии контроллера? Проблема в том, что некоторые поля *зависят* от других полей. Поле `card_number` требуется 
только, когда в поле `payment_method` выбрана "кредитная карта", в противном случае оно опционально. То же можно сказать и про поле `bank_account` - оно требуется
только когда в поле `payment_method` выбран "банковский перевод". 

Мы можем элегантно справиться с данной проблемой с использованием группы валидации. Класс `Form` предоставляет метод `setValidationGroup()`,
который принимает список полей, которые нужно валидировать; все остальные поля подавляются и не проходят валидацию.

{line-numbers=off, lang=php}
~~~
// Сначала проверим только поле "payment_method"
$form->setValidationGroup(['payment_method']);
if ($form->isValid())
{
    $data = $form->getData();
    
    $paymentMethod = $data['payment_method'];
    
    // Затем проверим и зависимые поля
    if ($paymentMethod=='credit_card') {
        $form->setValidationGroup(['payment_method', 'card_number']);
    } else if ($paymentMethod=='bank_account') {
        $form->setValidationGroup(['payment_method', 'bank_account']);
    }
    
    if ($form->isValid()) {
        $data = $form->getData();
        
        // Сделаем что-нибудь с данными формы
        // ...
    }
}
~~~ 

T> Вы можете увидеть данный пример в действии в приложении *Form Demo*, которое поставляется с данной книгой. Просто введите 
T> "http://localhost/payment" URL в адресную строку браузера.

## Реализация многошаговых (Multi-Step) форм {#multi-step-forms}

В этом разделе мы приведем инструкции по реализации *многошаговой* формы с помощью ZF3. Многошаговая форма - это
форма, имеющая много полей, которая отображается в несколько шагов. Для хранения текущего шага и введенных
пользователем данных между запросами страниц, используются *сессии* PHP.

I> Возьмем в качестве примера регистрацию пользователя. Она может быть осуществлена в несколько шагов: на первом шаге
I> вы отображаете страницу, где пользователь вводит логин и пароль, на втором - страницу, где он может ввести личную
I> информацию, а на третьем - страницу для ввода платежной информации.
I>
I> Другой пример многошаговой формы - форма опроса. Такая форма будет отображать вопрос и несколько вариантов ответа на него.
I> Шагов у этой формы будет столько же, сколько вопросов будет содержать опрос.

В этом разделе мы реализует форму регистрации *User Registration*, позволяющую собрать информацию о регистрируемом пользователе.

T> Рабочий пример этой формы можно посмотреть в приложении *Form Demo*, которое идет вместе с этой книгой.

### Включение сессий

T> Если вы не знакомы с PHP-сессиями, пожалуйста, обратитесь к [Работа с сессиями](#session) перед прочтением этого раздела.

Поддержка сессий реализована в компоненте `Zend\Session`, так что вам нужно установить его, если вы еще этого не сделали.

Затем измените файл конфигурации *APP_DIR/config/global.php* следующим образом:

{line-numbers=off,lang=php}
~~~
<?php
use Zend\Session\Storage\SessionArrayStorage;
use Zend\Session\Validator\RemoteAddr;
use Zend\Session\Validator\HttpUserAgent;

return [
    // Настройка сессии.
    'session_config' => [
        // Срок действия cookie истечет через 1 час.
        'cookie_lifetime' => 60*60*1, 
        // Данные сессии хранятся на сервере до 30 дней.
        'gc_maxlifetime'     => 60*60*24*30,
    ],
    // Настройка менеджера сессии.
    'session_manager' => [
        // Валидаторы сессии (используются для безопасности).
        'validators' => [
            RemoteAddr::class,
            HttpUserAgent::class,
        ]
    ],
    // Настройка хранилища сессии.
    'session_storage' => [
        'type' => SessionArrayStorage::class
    ],
    
    // ...
];
~~~
 
Затем добавьте следующий фрагмент кода в *module.config.php* для регистрации контейнера сессии *UserRegistration*:
 
{line-numbers=off,lang=php}
~~~
<?php
return [
    // ...
    'session_containers' => [
        'UserRegistration'
    ],
];
~~~

Готово! Теперь мы можем использовать контейнер сессии в нашем коде. Далее мы реализуем
модель формы `RegistrationForm`.

### Добавление RegistrationForm

Модель формы `RegistrationForm` будет использоваться для сбора данных о пользователе (эл. адрес,
полное имя, персональная информация и платежная информация). Мы добавим элементы к этой форме в виде 
трех частей, что позволит использовать ее как многошаговую форму.

Чтобы добавить модель формы, создайте файл *RegistrationForm.php* в каталоге *Form*
под корневым каталогом модуля *Application*.

{line-numbers=off,lang=php}
~~~
<?php
namespace Application\Form;

use Zend\Form\Form;
use Zend\InputFilter\InputFilter;
use Application\Validator\PhoneValidator;

/**
 * Эта форма используется для сбора данных о регистрации пользователя. Она является многошаговой.
 * Форма определяет, какие создавать поля, в зависимости от аргумента $step, который вы передаете
 * ее конструктору.
 */
class RegistrationForm extends Form
{
    /**
     * Конструктор.     
     */
    public function __construct($step)
    {
        // Проверяем входные данные.
        if (!is_int($step) || $step<1 || $step>3)
            throw new \Exception('Step is invalid');
        
        // Определяем имя формы
        parent::__construct('registration-form');
     
        // Задаем метод POST для этой формы
        $this->setAttribute('method', 'post');
                
        $this->addElements($step);
        $this->addInputFilter($step); 
    }
    
    /**
     * Этот метод добавляет элементы к форме (поля ввода и кнопку отправки формы).
     */
    protected function addElements($step) 
    {
        if ($step==1) {
            
            // Добавляем поле "email"
            $this->add([           
                'type'  => 'text',
                'name' => 'email',
                'attributes' => [
                    'id' => 'email'
                ],
                'options' => [
                    'label' => 'Ваш E-mail',
                ],
            ]);
            
            // Добавляем поле "full_name"
            $this->add([           
                'type'  => 'text',
                'name' => 'full_name',
                'attributes' => [
                    'id' => 'full_name'
                ],
                'options' => [
                    'label' => 'Полное имя',
                ],
            ]);
            
            // Добавляем поле "password"
            $this->add([           
                'type'  => 'password',
                'name' => 'password',
                'attributes' => [
                    'id' => 'password'
                ],
                'options' => [
                    'label' => 'Пароль',
                ],
            ]);
            
            // Добавляем поле "confirm_password"
            $this->add([           
                'type'  => 'password',
                'name' => 'confirm_password',
                'attributes' => [
                    'id' => 'confirm_password'
                ],
                'options' => [
                    'label' => 'Подтвердите пароль',
                ],
            ]);           
            
        } else if ($step==2) {
            
            // Добавляем поле "phone"
            $this->add([
                'type'  => 'text',
                'name' => 'phone',
                'attributes' => [                
                    'id' => 'phone'
                ],
                'options' => [
                    'label' => 'Мобильный телефон',
                ],
            ]);

            // Добавляем поле "street_address"
            $this->add([
                'type'  => 'text',
                'name' => 'street_address',
                'attributes' => [                
                    'id' => 'street_address'
                ],
                'options' => [
                    'label' => 'Адрес',
                ],
            ]);
            
            // Добавляем поле "city"
            $this->add([
                'type'  => 'text',
                'name' => 'city',
                'attributes' => [                
                    'id' => 'city'
                ],
                'options' => [
                    'label' => 'Город',
                ],
            ]);
            
            // Добавляем поле "state"
            $this->add([
                'type'  => 'text',
                'name' => 'state',
                'attributes' => [                
                    'id' => 'state'
                ],
                'options' => [
                    'label' => 'Штат',
                ],
            ]);
            
            // Добавляем поле "post_code" 
            $this->add([
                'type'  => 'text',
                'name' => 'post_code',
                'attributes' => [                
                    'id' => 'post_code'
                ],
                'options' => [
                    'label' => 'Почтовый индекс',
                ],
            ]);
            
            // Добавляем поле "country"
            $this->add([            
                'type'  => 'select',
                'name' => 'country',
                'attributes' => [
                    'id' => 'country',                                
                ],                                    
                'options' => [                                
                    'label' => 'Страна',
                    'empty_option' => '-- Пожалуйста, выберите --',
                    'value_options' => [
                        'US' => 'United States',
                        'CA' => 'Canada',
                        'BR' => 'Brazil',
                        'GB' => 'Great Britain',
                        'FR' => 'France',
                        'IT' => 'Italy',
                        'DE' => 'Germany',
                        'RU' => 'Russia',
                        'IN' => 'India',
                        'CN' => 'China',
                        'AU' => 'Australia',
                        'JP' => 'Japan'
                    ],                
                ],
            ]);
            
            
        } else if ($step==3) {
            
            // Добавляем поле "billing_plan"
            $this->add([            
                'type'  => 'select',
                'name' => 'billing_plan',
                'attributes' => [
                    'id' => 'billing_plan',                                
                ],                                    
                'options' => [                                
                    'label' => 'Тарифный план',
                    'empty_option' => '-- Пожалуйста, выберите --',
                    'value_options' => [
                        'Free' => 'Free',
                        'Bronze' => 'Bronze',
                        'Silver' => 'Silver',
                        'Gold' => 'Gold',
                        'Platinum' => 'Platinum'
                    ],                
                ],
            ]);
            
            // Добавляем поле "payment_method"
            $this->add([            
                'type'  => 'select',
                'name' => 'payment_method',
                'attributes' => [
                    'id' => 'payment_method',                                
                ],                                    
                'options' => [                                
                    'label' => 'Способ оплаты',
                    'empty_option' => '-- Пожалуйста, выберите --',
                    'value_options' => [
                        'Visa' => 'Visa',
                        'MasterCard' => 'Master Card',
                        'PayPal' => 'PayPal'
                    ],                
                ],
            ]);
        }
        
        // Добавляем поле CSRF
        $this->add([
            'type'  => 'csrf',
            'name' => 'csrf',
            'attributes' => [],
            'options' => [                
                'csrf_options' => [
                     'timeout' => 600
                ]
            ],
        ]);
        
        // Добавляем кнопку отправки формы
        $this->add([
            'type'  => 'submit',
            'name' => 'submit',
            'attributes' => [                
                'value' => 'Следующий шаг',
                'id' => 'submitbutton',
            ],
        ]);        
    }
    
    /**
     * Этот метод создает фильтр входных данных (используется для фильтрации/валидации).
     */
    private function addInputFilter($step) 
    {
        $inputFilter = new InputFilter();        
        $this->setInputFilter($inputFilter);
        
        if ($step==1) {

            $inputFilter->add([
                    'name'     => 'email',
                    'required' => true,
                    'filters'  => [
                        ['name' => 'StringTrim'],                    
                    ],                
                    'validators' => [
                        [
                            'name' => 'EmailAddress',
                            'options' => [
                                'allow' => \Zend\Validator\Hostname::ALLOW_DNS,
                                'useMxCheck'    => false,                            
                            ],
                        ],
                    ],
                ]);
            
            $inputFilter->add([
                'name'     => 'full_name',
                'required' => true,
                'filters'  => [
                    ['name' => 'StringTrim'],
                    ['name' => 'StripTags'],
                    ['name' => 'StripNewlines'],
                ],                
                'validators' => [
                    [
                        'name'    => 'StringLength',
                        'options' => [
                            'min' => 1,
                            'max' => 128
                        ],
                    ],
                ],
            ]);
           
            // Добавляем вход для поля "password"
            $inputFilter->add([
                    'name'     => 'password',
                    'required' => true,
                    'filters'  => [                    
                    ],                
                    'validators' => [
                        [
                            'name'    => 'StringLength',
                            'options' => [
                                'min' => 6,
                                'max' => 64
                            ],
                        ],
                    ],
                ]);  

            // Добавляем вход для поля "confirm_password"
            $inputFilter->add([
                    'name'     => 'confirm_password',
                    'required' => true,
                    'filters'  => [
                    ],       
                    'validators' => [
                        [
                            'name'    => 'Identical',
                            'options' => [
                                'token' => 'password',                            
                            ],
                        ],
                    ],
                ]);
            
        } else if ($step==2) {
        
            $inputFilter->add([
                'name'     => 'phone',
                'required' => true,                
                'filters'  => [                    
                ],                
                'validators' => [
                    [
                        'name'    => 'StringLength',
                        'options' => [
                            'min' => 3,
                            'max' => 32
                        ],
                    ],
                    [
                        'name' => PhoneValidator::class,
                        'options' => [
                            'format' => PhoneValidator::PHONE_FORMAT_INTL
                        ]                        
                    ],
                ],
            ]);
            
            // Добавляем вход для поля "street_address"
            $inputFilter->add([
                    'name'     => 'street_address',
                    'required' => true,
                    'filters'  => [
                        ['name' => 'StringTrim'],
                    ],                
                    'validators' => [
                        ['name'=>'StringLength', 'options'=>['min'=>1, 'max'=>255]]
                    ],
                ]);

            // Добавляем вход для поля "city"
            $inputFilter->add([
                    'name'     => 'city',
                    'required' => true,
                    'filters'  => [
                        ['name' => 'StringTrim'],
                    ],                
                    'validators' => [
                        ['name'=>'StringLength', 'options'=>['min'=>1, 'max'=>255]]
                    ],
                ]);

            // Добавляем вход для поля "state"
            $inputFilter->add([
                    'name'     => 'state',
                    'required' => true,
                    'filters'  => [
                        ['name' => 'StringTrim'],
                    ],                
                    'validators' => [
                        ['name'=>'StringLength', 'options'=>['min'=>1, 'max'=>32]]
                    ],
                ]); 
            
            // Добавляем вход для поля "post_code"
            $inputFilter->add([
                    'name'     => 'post_code',
                    'required' => true,
                    'filters'  => [                                        
                    ],                
                    'validators' => [
                        ['name' => 'IsInt'],
                        ['name'=>'Between', 'options'=>['min'=>0, 'max'=>999999]]
                    ],
                ]);

            // Добавляем вход для поля "country"
            $inputFilter->add([
                    'name'     => 'country',
                    'required' => false,                
                    'filters'  => [
                        ['name' => 'Alpha'],
                        ['name' => 'StringTrim'],
                        ['name' => 'StringToUpper'],
                    ],                
                    'validators' => [
                        ['name'=>'StringLength', 'options'=>['min'=>2, 'max'=>2]]
                    ],
                ]);     
            
        } else if ($step==3) {
            
            // Добавляем вход для поля "billing_plan"
            $inputFilter->add([
                    'name'     => 'billing_plan',
                    'required' => true,                
                    'filters'  => [
                    ],                
                    'validators' => [
                        [
                            'name' => 'InArray', 
                            'options' => [
                                'haystack'=>[
                                    'Free', 
                                    'Bronze',
                                    'Silver',
                                    'Gold',
                                    'Platinum'
                                ]
                            ]
                        ]
                    ],
                ]);
            
            // Добавляем вход для поля "payment_method"
            $inputFilter->add([
                    'name'     => 'payment_method',
                    'required' => true,                
                    'filters'  => [
                    ],                
                    'validators' => [
                        [
                            'name' => 'InArray', 
                            'options' => [
                                'haystack'=>[
                                    'PayPal', 
                                    'Visa',
                                    'MasterCard',
                                ]
                            ]
                        ]
                    ],
                ]);
        }
    }
}
~~~

Как видите из этого фрагмента кода, `RegistrationForm` - это обычная модель формы, однако она принимает в своем
конструктора аргумент `$step`, позволяющий указать, какие элементы формы использовать на текущем шаге.

### Добавление RegistrationController

Далее, мы добавим класс контроллера `RegistrationController`. Для этого создадим файл *RegistrationController.php*
под каталогом *Controller* и добавим в него следующий код:

{line-numbers=off,lang=php}
~~~
<?php
namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;
use Application\Form\RegistrationForm;
use Zend\Session\Container;

/**
 * Это класс контроллера, отображающий страницу с формой регистрации пользователя.
 * Регистрация состоит из нескольких шагов, так что для каждого шага мы будем отображать 
 * разные элементы формы. Мы используем контейнер сессии для запоминания выбора пользователя 
 * на предыдущих шагах.
 */
class RegistrationController extends AbstractActionController 
{
    /**
     * Контейнер сессии.
     * @var Zend\Session\Container
     */
    private $sessionContainer;
    
    /**
     * Конструктор. Его целью является внедрение зависимостей в контроллер.
     */
    public function __construct($sessionContainer) 
    {
        $this->sessionContainer = $sessionContainer;
    }
    
    /**
     * Действие по умолчанию "index". Оно отображает
     * страницу регистрации.
     */
    public function indexAction() 
    {
        // Определяем текущий шаг.
        $step = 1;
        if (isset($this->sessionContainer->step)) {
            $step = $this->sessionContainer->step;            
        }
        
        // Проверка номера шага на корректность (от 1 до 3).
        if ($step<1 || $step>3)
            $step = 1;
        
        if ($step==1) {
            // Инициализируем выборы пользователя.
            $this->sessionContainer->userChoices = [];
        }
                       
        $form = new RegistrationForm($step);
        
        // Проверяем, отправил ли пользователь форму.
        if($this->getRequest()->isPost()) {
            
            // Заполняем форму POST-данными.
            $data = $this->params()->fromPost();            
            
            $form->setData($data);
            
            // Валидируем форму.
            if($form->isValid()) {
                
                // Получаем отфильтрованные и валидированные данные.
                $data = $form->getData();
                
                // Сохраняем выборы пользователя в сессии.
                $this->sessionContainer->userChoices["step$step"] = $data;
                
                // Увеличиваем шаг.
                $step ++;
                $this->sessionContainer->step = $step;
                
                // Если мы прошли все 3 шага, перенаправляем на страницу проверки данных Review.
                if ($step>3) {
                    return $this->redirect()->toRoute('registration', 
                                ['action'=>'review']);
                }
                
                // Переходим на следующий шаг.
                return $this->redirect()->toRoute('registration');
            }
        }
        
        $viewModel = new ViewModel([
            'form' => $form
        ]);
        $viewModel->setTemplate("application/registration/step$step");
        
        return $viewModel;
    }
    
    /**
     * Действие "review" отображает страницу, позволяющую проверить данные, введенные на 
     * предыдущих шагах.
     */
    public function reviewAction()
    {
        // Валидируем данные сессии.
        if(!isset($this->sessionContainer->step) || 
           $this->sessionContainer->step<=3 || 
           !isset($this->sessionContainer->userChoices)) {
            throw new \Exception('Извините, данные пока не доступны для проверки');
        }
        
        // Извлекаем из сессии выборы пользователя.
        $userChoices = $this->sessionContainer->userChoices;
        
        return new ViewModel([
            'userChoices' => $userChoices
        ]);
    }
}
~~~

Описанный выше класс имеет три метода:

  * Конструктор `__construct()` используется для внедрения зависимости - контейнера сессии - в контроллер.

  * Метод действия `indexAction()` извлекает из сессии текущий шаг и инициализирует модель формы.
    Если пользователь отправил форму, мы извлекаем из формы данные и сохраняем их в сессии, инкрементируя шаг.
	Если шаг больше 3, мы перенаправляем пользователя на страницу "Review".
    
  * Метод действия `reviewAction()` извлекает данные, введенные пользователем на всех трех шагах и передаете
    их представлению для визуализации.

#### Добавление RegistrationControllerFactory

После этого добавим фабрику для `RegistrationController`. Для этого добавьте файл *RegistrationControllerFactory.php*
в каталог *Controller/Form* под корневым каталогом модуля. Поместите в него следующий код:

{line-numbers=off,lang=php}
~~~
<?php
namespace Application\Controller\Factory;

use Interop\Container\ContainerInterface;
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Controller\RegistrationController;

/**
 * Это фабрика для RegistrationController. Ее целью является инстанцирование
 * контроллера и внедрение в него зависимостей.
 */
class RegistrationControllerFactory implements FactoryInterface
{
    public function __invoke(ContainerInterface $container, 
                       $requestedName, array $options = null)
    {
        $sessionContainer = $container->get('UserRegistration');
        
        // Инстанцируем контроллер и внедряем зависимости.
        return new RegistrationController($sessionContainer);
    }
}
~~~

T> Не забудьте зарегистрировать контроллер в файле *module.config.php* file!

### Добавление шаблонов представлений

Теперь давайте добавим шаблоны представлений для действий контроллера. У нас есть четыре шаблона представлений: 
*step1.phtml*, *step2.phtml*, *step3.phtml* и *review.phtml*. Первые три используются `indexAction()`, а последний
- `reviewAction()`.

Добавьте файл *step1.phtml* в каталог *application/registration* и поместите в него следующий код:

{line-numbers=off,lang=php}
~~~
<?php
$form->get('email')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'name@yourcompany.com'
    ]);

$form->get('full_name')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'John Doe'
    ]);

$form->get('password')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'Введите пароль (минимум 6 символов)'
    ]);

$form->get('confirm_password')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'Подтвердите пароль'
    ]);

$form->get('submit')->setAttributes(array('class'=>'btn btn-primary'));

$form->prepare();
?>

<h1>Регистрация пользователя - Шаг 1</h1>

<div class="row">
    <div class="col-md-6">
        <?= $this->form()->openTag($form); ?>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('email')); ?>
            <?= $this->formElement($form->get('email')); ?>
            <?= $this->formElementErrors($form->get('email')); ?>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('full_name')); ?>
            <?= $this->formElement($form->get('full_name')); ?>
            <?= $this->formElementErrors($form->get('full_name')); ?>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('password')); ?>
            <?= $this->formElement($form->get('password')); ?>
            <?= $this->formElementErrors($form->get('password')); ?>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('confirm_password')); ?>
            <?= $this->formElement($form->get('confirm_password')); ?>
            <?= $this->formElementErrors($form->get('confirm_password')); ?>
        </div>
        
        <div class="form-group">
        <?= $this->formElement($form->get('submit')); ?>
        </div>
        
        <?= $this->formElement($form->get('csrf')); ?>
        
        <?= $this->form()->closeTag(); ?>
    </div>    
</div>   
~~~
    
Затем добавьте файл *step2.phtml* в каталог *application/registration* и поместите в него следующий код:

{line-numbers=off,lang=php}
~~~
<?php
$form->get('phone')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'Номер телефона в международном формате'
    ]);

$form->get('street_address')->setAttributes([
    'class'=>'form-control', 
    ]);

$form->get('city')->setAttributes([
    'class'=>'form-control', 
    ]);

$form->get('state')->setAttributes([
    'class'=>'form-control',
    ]);

$form->get('post_code')->setAttributes([
    'class'=>'form-control', 
    ]);

$form->get('country')->setAttributes([
    'class'=>'form-control'
    ]);

$form->get('submit')->setAttributes(array('class'=>'btn btn-primary'));

$form->prepare();
?>

<h1>Регистрация пользователя - Шаг 2 - Персональная информация</h1>

<div class="row">
    <div class="col-md-6">
        <?= $this->form()->openTag($form); ?>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('phone')); ?>
            <?= $this->formElement($form->get('phone')); ?>
            <?= $this->formElementErrors($form->get('phone')); ?>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('street_address')); ?>
            <?= $this->formElement($form->get('street_address')); ?>
            <?= $this->formElementErrors($form->get('street_address')); ?>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('city')); ?>
            <?= $this->formElement($form->get('city')); ?>
            <?= $this->formElementErrors($form->get('city')); ?>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('state')); ?>
            <?= $this->formElement($form->get('state')); ?>
            <?= $this->formElementErrors($form->get('state')); ?>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('post_code')); ?>
            <?= $this->formElement($form->get('post_code')); ?>
            <?= $this->formElementErrors($form->get('post_code')); ?>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('country')); ?>
            <?= $this->formElement($form->get('country')); ?>
            <?= $this->formElementErrors($form->get('country')); ?>
        </div>
        
        <div class="form-group">
        <?= $this->formElement($form->get('submit')); ?>
        </div>
        
        <?= $this->formElement($form->get('csrf')); ?>
        
        <?= $this->form()->closeTag(); ?>
    </div>    
</div>   
~~~    

После этого добавьте файл *step3.phtml* в каталог *application/registration* и поместите в него следующий код:

{line-numbers=off,lang=php}
~~~
<?php
$form->get('billing_plan')->setAttributes([
    'class'=>'form-control', 
    ]);

$form->get('payment_method')->setAttributes([
    'class'=>'form-control', 
    ]);

$form->get('submit')->setAttributes(array('class'=>'btn btn-primary'));

$form->prepare();
?>

<h1>Регистрация пользователя - Шаг 3 - Платежная информация</h1>

<div class="row">
    <div class="col-md-6">
        <?= $this->form()->openTag($form); ?>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('billing_plan')); ?>
            <?= $this->formElement($form->get('billing_plan')); ?>
            <?= $this->formElementErrors($form->get('billing_plan')); ?>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('payment_method')); ?>
            <?= $this->formElement($form->get('payment_method')); ?>
            <?= $this->formElementErrors($form->get('payment_method')); ?>
        </div>
        
        <div class="form-group">
        <?= $this->formElement($form->get('submit')); ?>
        </div>
        
        <?= $this->formElement($form->get('csrf')); ?>
        
        <?= $this->form()->closeTag(); ?>
    </div>    
</div>   
~~~ 

И наконец, добавьте файл *review.phtml* в каталог *application/registration* и поместите в него следующий код:

{line-numbers=off,lang=php}
~~~
<h1>Регистрация пользователя - Проверка</h1>

<p>Спасибо! Теперь, пожалуйста, проверьте данные, которые вы ввели на предыдуших шагах.</p>

<pre>
<?php print_r($userChoices); ?>
</pre>
~~~    

### Добавление маршрута

Добавьте следующий маршрут в файл конфигурации *module.config.php*:

{line-numbers=off,lang=php}
~~~
'registration' => [
    'type'    => Segment::class,
    'options' => [
        'route'    => '/registration[/:action]',
        'constraints' => [
            'action' => '[a-zA-Z][a-zA-Z0-9_-]*'
        ],
        'defaults' => [
            'controller'    => Controller\RegistrationController::class,
            'action'        => 'index',
        ],
    ],
],
~~~

Отлично! Теперь все готово для того, чтобы увидеть результат!

### Результаты

Чтобы увидеть нашу многошаговую форму в действии введите URL "http://localhost/registration" в адресной
строке своего браузера. Появится страница *User Registration - Step 1* (см. рисунок 11.6):

![Рисунок 11.6. Регистрация пользователя - Шаг 1](../en/images/forms_advanced/registration_step1.png)

Как только пользователь введет свой адрес электронной почты, полное имя и пароль, и нажмет кнопку *Next*, он
перенаправляется на следующий шаг (см. рисунок 11.7):

![Рисунок 11.7. Регистрация пользователя - Шаг 2](../en/images/forms_advanced/registration_step2.png)

И последний шаг показан на рисунке 11.8 ниже:

![Рисунок 11.8. Регистрация пользователя - Шаг 3](../en/images/forms_advanced/registration_step3.png)
    
Нажатие *Next* приводит к отображению страницы проверки *Review*, позволяющей просмотреть введенные на предыдущих шагах данные:

![Рисунок 11.9. Регистрация пользователя - Страница проверки](../en/images/forms_advanced/registration_review.png)
  
T> Этот пример можно посмотреть в приложении *Form Demo*, которое идет вместе с этой книгой.
    
## Выводы

В этой главе мы обсудили некоторые расширенные возможности использования форм.

Zend Framework 3 предоставляет два класса, целью которых является повышение безопасности
форм: `Captcha` и `Csrf`. CAPTCHA - это тип теста вида "вызов-ответ", используемый для определения
того, является ли пользователь человеком. Элементы CAPTCHA используются на форме для предотвращения
отправки формы вредоносным автоматизированным процессом (роботом). Второй элемент, `Csrf`, используется
для предотвращения хакерских атак методом подделки межсайтовых запросов (Cross-Site Request Forgery - CSRF).

Кроме того, мы узнали, как реализовывать многошаговые формы с помощью сессий.
