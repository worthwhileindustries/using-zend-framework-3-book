# Cбор пользовательских данных с помощью форм {#forms}

В этой главе вы ознакомитесь с использованием веб-форм (forms) для сбора данных,
введенных пользователями веб-сайта. В Zend Framework 3 функции для
работы с формами, в основном, распределены по четырем компонентам: компоненту
`Zend\Form`, который позволяет строить формы и содержит помощники видов для
отображения элементов форм; и компонентам `Zend\Filter`, `Zend\Validator` и `Zend\InputFilter`,
используемых для фильтрации и валидации введенных данных. Также существует специальный компонент `Zend\Mvc\Form`,
предназначенный для интеграции форм с MVC-приложением.

|--------------------------------|---------------------------------------------------------------|
| *Компонент*                    | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Form`                    | Содержит базовые классы форм                                  |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Filter`                  | Содержит различные классы фильтров.                           |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Validator`               | Реализует различные классы валидаторов.                       |
|--------------------------------|---------------------------------------------------------------|
| `Zend\InputFilter`             | Реализует контейнер для фильтров/валидаторов                  |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Mvc\Form`                | Компонент для интеграции форм в MVC-приложение                |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Mail`                    | Содержит набор функций для отправки эл. почты                 |
|--------------------------------|---------------------------------------------------------------|

## Скачайте пример Form Demo с GitHub

Мы продемонстрируем использование форм в простом приложении *Form Demo*, которое
идет в комплекте с этой книгой. Этот пример является готовым веб-сайтом; вы можете
скачать его и посмотреть на формы в действии.

Чтобы скачать приложение *Form Demo*, зайдите на 
[эту страницу](https://github.com/olegkrivtsov/using-zf3-book-samples)
и нажмите кнопку *Clone or Download*, чтобы скачать код в виде ZIP-архива. 
После завершения загрузки распакуйте архив в выбранный вами каталог.

Затем перейдите в каталог `formdemo`, который содержит весь исходный код
веб-приложения *Form Demo*.:

{line-numbers=off,lang=text}
~~~
/using-zf3-book-samples
  /formdemo
  ...
~~~

T> Для установки нашего примера вы можете либо изменить ваш файл виртуального хоста по умолчанию,
T> либо создать новый. После изменения файла перезапустите HTTP-сервер Apache
T> и откройте веб-сайт в своем браузере. Дополнительную информацию о виртуальных
T> хостах Apache вы можете найти в [Приложении A. Настройка среды веб разработки](#devenv).

## Об HTML-формах

Функциональность форм, предоставляемая Zend Framework 3, внутренне использует HTML-формы. По этой причине
мы начнем с краткого введения в тему HTML-форм.

В HTML формы заключаются в теги `<form>` и `</form>`. Форма, как правило, состоит из 
полей (fields): поля ввода текста, флажки (checkboxes), переключатели (radio buttons), кнопки отправки формы (submit buttons), 
скрытые поля (hidden fields) и т.д. HTML имеет несколько тегов, предназначенных для определения полей форм:

* `<input>` - определяет поле ввода, куда пользователь может ввести какие-либо
   данные (внешний вид и поведение поля зависят от его типа);
* `<textarea>` - многострочная текстовая область, которая может содержать 
   неограниченное число символов;
* `<button>` - кликабельная кнопка[^button];
* `<select>` - выпадающий список;
* `<option>` - используется внутри элемента `<select>` для определения доступных 
   элементов в выпадающем списке.

[^button]: Поле `<button>` аналогично `<input type="button">`, однако оно предоставляет
           дополнительные возможности, например, определение иконки на кнопке.
		   
В таблице 7.1 вы можете посмотреть примеры определения полей HTML-форм. Рисунок 7.1 содержит
соответствующие визуализации полей (за исключением "скрытого" типа поля, у которого нет визуального представления).

![Рисунок 7.1. Стандартные поля HTML-форм](../en/images/forms/standard_form_fields.png)

{title="Таблица 7.1. Стандартные поля HTML-форм"}
|--------------------------------|---------------------------------------------------------------|
| *Поле*                         | *Определение*                                                 |
|--------------------------------|---------------------------------------------------------------|
| Поле ввода текста              | `<input type="text">`                                         |
|--------------------------------|---------------------------------------------------------------|
| Текстовая область              | `<textarea rows=4></textarea>`                                |
|--------------------------------|---------------------------------------------------------------|
| Пароль                         | `<input type="password">`                                     |
|--------------------------------|---------------------------------------------------------------|
| Кнопка                         | `<input type="button" value="Apply">` or                      |
|                                | `<button type="button">Apply</button>`                        |
|--------------------------------|---------------------------------------------------------------|
| Кнопка отправки формы          | `<input type="submit" value="Submit">`                        |
|--------------------------------|---------------------------------------------------------------|
| Изображение (графическая кнопка отправки)| `<input type="image" src="button.jpg">`             |
|--------------------------------|---------------------------------------------------------------|
| Кнопка сброса                  | `<input type="reset" value="Reset">`                          |
|--------------------------------|---------------------------------------------------------------|
| Флажок                         | `<input type="checkbox">Remember me</input>`                  |
|--------------------------------|---------------------------------------------------------------|
| Переключатель                  | `<input type="radio" value="Radio">Allow</input>`             |
|--------------------------------|---------------------------------------------------------------|
| Раскрывающийся список          | `<select><option>Enable</option><option>Disable</option></select>` |
|--------------------------------|---------------------------------------------------------------|
| Файл                           | `<input type="file">`                                         |
|--------------------------------|---------------------------------------------------------------|
| Скрытое поле                   | `<input type="hidden">`                                       |
|--------------------------------|---------------------------------------------------------------|

В HTML5 были представлены несколько новых типов полей форм (перечислены в таблице 7.2); рисунок 7.21
содержит соответствующие визуализации полей.

Поля HTML5 предоставляют более удобные способы для ввода наиболее часто используемых типов данных:
чисел, дат, электронных почт, URL и т.д. Кроме того, при отправке формы браузер проверяет, корректный ли
формат у введенных пользователем данных - и, если нет, браузер не допустит отправку формы и предложит
пользователю исправить ошибку ввода.

{title="Table 7.2. Поля HTML5-форм"}
|--------------------------------|---------------------------------------------------------------|
| *Поле*                         | *Определение*                                                 |
|--------------------------------|---------------------------------------------------------------|
| Выбор цвета                    | `<input type="color">`                                      |
|--------------------------------|---------------------------------------------------------------|
| Дата                           | `<input type="date">`                                       |
|--------------------------------|---------------------------------------------------------------|
| Дата/время (с временной зоной) | `<input type="datetime">`                                   |
|--------------------------------|---------------------------------------------------------------|
| Дата/время (без временной зоны)| `<input type="datetime-local">`                             |
|--------------------------------|---------------------------------------------------------------|
| Адрес эл. почты                | `<input type="email">`                                      |
|--------------------------------|---------------------------------------------------------------|
| Число                          | `<input type="number">`                                     |
|--------------------------------|---------------------------------------------------------------|
| Время                          | `<input type="time">`                                       |
|--------------------------------|---------------------------------------------------------------|
| Месяц                          | `<input type="month">`                                      |
|--------------------------------|---------------------------------------------------------------|
| Неделя                         | `<input type="week">`                                       |
|--------------------------------|---------------------------------------------------------------|
| URL                            | `<input type="url">`                                        |
|--------------------------------|---------------------------------------------------------------|
| Диапазон (ползунок)            | `<input type="range">`                                      |
|--------------------------------|---------------------------------------------------------------|
| Поле поиска                    | `<input type="search" name="googlesearch">`                 |
|--------------------------------|---------------------------------------------------------------|
| Номер телефона                 | `<input type="tel">`                                        |
|--------------------------------|---------------------------------------------------------------|

![Рисунок 7.2. Поля HTML5-форм](../en/images/forms/html5_form_fields.png)

### Наборы полей (fieldsets)

Вы можете группировать связанные поля форм с помощью тега `<fieldset>`, как показано
в примере ниже. Опциональный тег `<legend>` позволяет определить заголовок полученной формы.

{line-numbers=off, lang=html}
~~~
<fieldset>
  <legend>Выберите способ оплаты:</legend>
  <input type="radio" name="payment" value="paypal">PayPal</input>
  <input type="radio" name="payment" value="card">Credit Card</input>
</fieldset>
~~~

Эта HTML-разметка сгенерирует группу как на рисунке 7.3:

![Рисунок 7.3. Набор полей](../en/images/forms/fieldset.png)

### Пример: Форма обратной связи "Contact Us"

Образец типичной HTML-формы представлен ниже

{line-numbers=on, lang=html}
~~~
<form name="contact-form" action="/contactus" method="post"> 
  <label for="email">E-mail</label>
  <input name="email" type="text">                              
  <br>        
  <label for="subject">Subject</label>            
  <input name="subject" type="text">                              
  <br>                
  <label for="body">Message</label>            
  <textarea name="body" class="form-control" rows="6"></textarea>
  <br>              
  <input name="submit" type="submit" value="Submit">       
</form>
~~~

В примере выше у нас есть форма обратной связи, позволяющая пользователю
вводить свой адрес электронной почты, тему сообщения и текст, а затем
отправить их серверу. Определение формы начинается с тега `<form>` (строка 1).

Тег `<form>` содержит несколько важных атрибутов:

* Атрибут `name` указывает имя формы ("contact-form").
* Атрибут `action` определяет URL скрипта на стороне сервера, ответственного 
  за обработку отправленной формы ("/contactus").
* Атрибут `method` определяет метод (либо GET, либо POST), который будет использоваться для
  доставки данных формы. В этом примере мы используем (рекомендуемый) метод POST.

В строке 3 мы определяем поле ввода текста с помощью элемента `<input>` . Атрибут `name` указывает
имя поля ("email"). Атрибут `type` определяет назначение элемента (тип "text" означает, что поле ввода
предназначено для введения текста).

В строке 2 находится элемент `<label>`, представляющий собой метку для поля ввода
эл. почты (имя соответствующего поля ввода определяется атрибутом `for` элемента `<label>`).

В строках 5-6 аналогичным образом определены поле ввода "Subject" и его метка.

В строке 9 находится поле текстовой области, подходящее для ввода многострочного текста.
Высота текстовой области (6 строк) определяется атрибутом 'rows'.

В строке 11 - кнопка отправки формы (элемент ввода с типом "submit").
Атрибут `value` позволяет установить текст заголовка для кнопки ("Submit").
Нажав на эту кнопку, пользователь отправит данные формы серверу.

Элементы разрыва строки `<br>` используются в строках 4, 7 и 10, чтобы расположить
Элементы управления формы одну под другой (иначе они будут расположены в одну строку).

Чтобы посмотреть, как выглядит эта форма, поместите код ее HTML-разметки в файл `.html`
и откройте файл в браузере. Вы увидите визуализацию формы как на рисунке 7.4.

![Figure 7.4. Визуализация формы обратной связи](../en/images/forms/typical_form.png)

Если вы введете какие-либо данные в форму обратной связи и нажмете кнопку *Submit*, браузер
отправит HTTP-запрос URL, указанному вами в атрибуте формы `action`. HTTP-запрос будет
содержать введенные вами данные.

### Методы GET и POST

Для отправки данных форм серверу используются методы GET и POST, которые имеют
важные технические отличия.

При использовании метода POST для отправки формы, данные отправляются
в теле HTTP-запроса. Например, при нажатии кнопки *Submit* на форме обратной связи HTTP-запрос
будет выглядеть так:
  
{line-numbers=on, lang=text}
~~~
POST http://localhost/contactus HTTP/1.1
Host: localhost
Connection: keep-alive
Content-Length: 76
Accept: text/html,application/xhtml+xml,application/xml
Origin: null
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) 
Content-Type: application/x-www-form-urlencoded

email=name%40example.com&subject=Example+Subject&body=Hello%21&submit=Submit
~~~

Как видите, данные формы передаются в теле запроса (строка 10). Поля формы 
сцеплены в одну строку и затем URL-закодированы, чтобы заменить небезопасные
символы разрешенными из таблицы ASCII.

В случае отправки формы методом GET, HTTP-запрос будет выглядеть следующим образом:

{line-numbers=on, lang=text}
~~~
GET http://localhost/contactus?email=name%40example.com&subject=Example+Subject&body=Hello%21&submit=Submit HTTP/1.1
Host: localhost
Connection: keep-alive
Accept: text/html,application/xhtml+xml,application/xml
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) 
Accept-Encoding: gzip,deflate,sdch

~~~ 

В этом примере данные формы связаны, закодированы и отправлены как часть URL HTTP-запроса (строка 1),
что делает URL длинным и сложным для чтения. Так как данные формы отправляются внутри URL, их легко
могут увидеть посетители сайта.
 
В большинстве случаев вы будете использовать метод POST для отправки данных формы в теле запроса, потому
что пользователю нет необходимости видеть данные в адресной строке браузера (особенно при отправке паролей или
других уязвимых данных).

W> Заметим, что отправка данных формы с использованием метода POST не защищает
W> ваши уязвимые данные (такие как пароли, номера кредитных карт и т.д.) от кражи. Для их
W> защиты нужно направить HTTP-трафик через [SSL-туннель](https://ru.wikipedia.org/wiki/SSL) 
W> (SSL расшифровывается как Secure Sockets Layer - уровень защищённых cокетов). Защищенные SSL-соединения
W> используют схему *https://* в URL веб-страниц. Чтобы включить SSL для вашего HTTP-сервера Apache,
W> вам нужно будет получить SSL-сертификат от доверенного центра сертификации
W> (например, [VeriSign](http://www.verisign.com/)) и установить его на своем сервере.

## Стилизация HTML-форм с помощью Twitter Bootstrap

При разработке сайтов на базе ZF3 мы используем CSS-фреймворк Twitter Bootstrap, который предоставляет
стандартные CSS-правила для стилизации форм и полей форм. Чтобы применить CSS-правила к полю формы
(`<input>`, `<textarea>` и др.), нужно присвоить ему CSS-класс `.form-control`. Кроме того, при использовании
меток (labels) вместе с полями ввода, поместите пары "метка-поле ввода" внутрь элементов `<div>` с помощью CSS-класса `.form-group`.
Для кнопок отправки формы можно использовать класс `.btn` и класс темы (`.btn-default`, `.btn-primary` и т.п.)

Ниже представлен модифицированный пример формы обратной связи, который
использует стилизацию Bootstrap.

{line-numbers=off, lang=html}
~~~
<h1>Contact Us</h1>

<p>
    Пожалуйста, заполните следующую форму для связи с нами.
	Мы высоко ценим ваши отзывы.
</p>

<form name="contact-form" action="/contactus" method="post">        

  <div class="form-group">
    <label for="email">Your E-mail</label>
    <input name="email" type="text" class="form-control" 
           placeholder="name@example.com">
  </div>
        
  <div class="form-group">
    <label for="subject">Subject</label>            
    <input name="subject" type="text" class="form-control" 
           placeholder="Type subject here">                              
  </div>
        
  <div class="form-group">
    <label for="body">Message Body</label>            
    <textarea name="body" class="form-control" rows="6" 
              placeholder="Type message text here"></textarea>
  </div>
        
  <input name="submit" type="submit"
         class="btn btn-primary" value="Submit">
</form>
~~~

Визуализация формы показана на рисунке 7.5.

![Рисунок 7.5. Стилизованная форма обратной связи](../en/images/forms/styled_contact_form.png)

Так как Twitter Bootstrap разработан для поддержки мобильных телефонов, планшетов
и настольных компьютеров, он делает поля формы в ширину экрана. Это может сделать
форму слишком широкой и сложной для понимания. Чтобы ограничить ширину формы,
используйте предоставляемую Bootstrap сетку, как в примере ниже:

{line-numbers=off, lang=html}
~~~
<div class="row">
  <div class="col-md-6">
    <form>
      ...		
    </form>
  </div>    
</div>
~~~

В данной HTML-разметке мы помещаем форму в ячейку шириной в 6 столбцов, что делает
форму шириной в половину экрана.

## Установка компонентов ZF3 для работы с формами

Для использования форм в MVC-приложении, вам нужно установить 
как минимум компонент `Zend\Mvc\Form`, если вы еще этого не сделали:

~~~
php composer.phar require zendframework/zend-mvc-form
~~~

При установке компонента `Zend\Mvc\Form` также будут установлены и остальные компоненты, 
реализующие поддержку форм в ZF3: `Zend\Form`, `Zend\InputFilter`, `Zend\Filter`, `Zend\Validator`, 
и возможно какие-то еще.

## Извлечение данных формы в действии контроллера

Пользователь сайта обычно работает с формой в следующем порядке:

* Сперва выполняется действие контроллера, визуализируя веб-страницу,
  содержащую форму, которая предлагает пользователю ввести данные.
  Как только пользователь заполнит поля форм, он нажимает кнопку *Submit*,
  тем самым генерируя HTTP-запрос и отсылая данные серверу.
* Затем, в методе действия контроллера вы извлекаете отправленные
  данные из переменных POST и/или GET и отображаете страницу с результатами
  обработки формы.
  
Как правило, эти две веб-страницы обрабатываются *одним и тем же* действием контроллера.
 
В примере ниже мы покажем, как создать действие контроллера для отображения формы обратной
связи (feedback form) и извлечения данных, отправленных пользователем. Для начала добавьте шаблон представления
*contact-us.phtml* в каталог *application/index/* под каталогом модуля *view/* (см. рисунок 7.6).

![Рисунок 7.6. Создание файла contact-us.phtml](../en/images/forms/contactus_file.png)

Поместите код HTML-разметки формы обратной связи из предыдущего раздела в файл шаблона
представления.

Затем добавьте метод действия `contactUsAction()` в класс `IndexController`. В этом методе
мы хотим извлечь необработанные данные из формы обратной связи, отправленной пользователем.

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Controller;

// ...

class IndexController extends AbstractActionController 
{
    // Это действие отображает форму обратной связи
    public function contactUsAction() 
    {
        // Проверяем, отправил ли пользователь форму
        if($this->getRequest()->isPost()) {
      
	        // Извлекаем данные формы из переменных POST
	        $data = $this->params()->fromPost();     
	  
	        // ... Какие-то действия с данными ...
	        var_dump($data);	  
        } 
        
        // Передаем переменную формы представлению
        return new ViewModel([
            'form' => $form
        ]);
    }
}
~~~

В этом фрагменте мы определяем метод действия `contactUsAction()` в классе 
`IndexController` (строка 9).

Затем в строке 12 мы проверяем, является ли запрос POST-запросом (проверяем первую строку
HTTP-запроса). Как правило, формы используют метод POST для отправки данных формы. Поэтому
мы можем выявить, отправлена форма или нет, проверив первую строку HTTP-запроса.

{line-numbers=off, lang=php}
~~~
<?php
return [
    // ...
    'router' => [
       'routes' => [
            // Add the following routing rule for the "Contact Us" page 
            'contactus' => [
                'type' => Literal::class,
                'options' => [
                    'route'    => '/contactus',
                    'defaults' => [
                        'controller' => Controller\IndexController::class,
                        'action'     => 'contactUs',
                    ],
                ],
            ],
        ],
    ],  
    // ...
];

~~~

Теперь, набрав URL "http://localhost/contactus" в адресной строке браузера,
вы должны будете увидеть страницу как на рисунке 7.7. 

![Рисунок 7.7. Форма обратной связи](../en/images/forms/feedback_form.png)

Введите e-mail, тему и основной текст и нажмите кнопку отправки формы.
Данные будут отправлены серверу, а затем извлечены методом `IndexController::contactUsAction()`.

Ниже показан пример массива `$data` (выведенный на веб-страницу с помощью функции PHP `var_dump()`). Как видите,
массив содержит ключ для каждого поля формы, включая поле "submit".

{line-numbers=off, lang=php}
~~~
array (size=4)
    'email' => string 'name@example.com' (length=16)
    'subject' => string 'С Новым Годом!' (length=15)
    'body' => string 'Уважаемая служба поддержки, я хотел бы поблагодарить вас 
              за превосходное качество ваших услуг и поздравить вас 
              с Новым Годом!' (length=118)
    'submit' => string 'Submit' (length=6)
~~~

## Формы и шаблон «модель-представление-контроллер»

В предыдущем разделе мы рассмотрели очень простой случая использования формы: мы
подготовили шаблон представления с HTML-разметкой формы и действие контроллера, ответственное
за отображение формы и вывода на экран необработанных введенных пользователем данных. Однако,
использование необработанных данных в реальных приложениях имеет недостаток: мы не проверяем
отправленные пользователем данные на возможные ошибки и/или вредоносный код. Ниже мы обсудим,
как выполнять подобную валидацию.

При разработке сайта на базе ZF3, который использует шаблон «модель-представление-контроллер»,
(Model-View-Controller или MVC) функциональность формы обычно разделена на *модели форм*, ответственные 
за определение полей, фильтарацию и валидацию; и *представление формы*, которые обычно реализуется с 
помощью специальных помощников видов.

Набор функций для создания моделей форм, добавления правил валидации и использования помощников
видов схематически показан на рисунке 7.8. Как видите из рисунка, за основу взят набор функций
стандартных HTML-форм.

![Рисунок 7.8. Функциональность форм в ZF3](../en/images/forms/html_zf2_forms.png)

У подхода MVC к работе с формами есть следующие преимущества:

* Вы можете повторно использовать модель формы в различных действиях контроллера.
* Используя помощники видов, вы можете (частично) избежать скучной работы по подготовке
  HTML-разметки для визуализации формы и возможных ошибок валидации.
* Вы можете создавать одно или несколько визуальных представлений одной и той же формы.
* Инкапсулируя алгоритм валидации формы в один класс модели формы, у вас будет меньше мест
  в коде, где необходимо проверять введенные пользователями данных, что повышает безопасность
  сайта.
  
### Типичный процесс использования формы
  
Так, вы инстанцируете модель формы в методе действия контроллера, затем
извлекаете отправленные пользователем данные из PHP-переменных и передаете
их модели формы для валидации.
Помощники видов форм используются в шаблоне представления для генерации HTML-разметки формы.
Этот процесс изображен на рисунке 7.9.

![Figure 7.9. Работа с формой в MVC-приложении](../en/images/forms/forms_and_mvc.png)

Стрелки на рисунке 7.9 обозначают направления действий:

1. Первым делом внутри метода действия контроллера вы извлекаете данные, отправленные пользователем,
   из PHP-переменных GET и POST (и возможно других). Затем вы создаете экземпляр модели формы и 
   передаете ему отправленные пользователем данные. Работа модели формы заключается в проверке
   (валидации) данных на корректность, и, если что-то не так, создать сообщение (или сообщения)
   об ошибке для каждого недопустимого поля формы.
   
2. Затем вы передаете модель формы шаблону представления `.phtml` для визуализации (с помощью
   контейнера для переменных `ViewModel`). Шаблон представления затем сможет обращаться к модели формы
   и вызывать ее методы.
   
3. После этого шаблон представления использует модель формы и помощники видов, предоставляемые
   Zend Framework 3 для визуализации полей (и отображения возможных сообщений об ошибках валидации,
   созданных на этапе валидации). В результате создается HTML-разметка формы.

В последующих разделах мы обсудим эти шаги более детально.

## Модель формы

Модель формы - это обычно PHP-класс, который создает некоторое количество *полей*.
Базовым классом для всех моделей форм является класс `Form`, определенный в компоненте
`Zend\Form`.

Поля в модели формы могут быть сгруппированы в *наборы полей* (fieldsets). Более того,
модель формы сама может считаться набором полей. Этот факт отражен в наследовании
класса формы (рисунок 7.10).

![Рисунок 7.10. Наследование класса формы](../en/images/forms/form_inheritance.png)

Как видно из рисунка, класс `Form` расширяет класс `Fieldset`.
Класс `Fieldset` в свою очередь наследуется от класса `Element`, который представляет собой
одно поле формы и его атрибуты.

T> Это наследование на первый взгляд может показаться странным, но все станет логичным, если вы
T> вспомните, что класс `Form` наследует методы для добавления полей формы от класса `Fieldset`
T> и методы для задания атрибутов формы от класса `Element`.

Ниже предоставлен фрагмент класса модели для формы обратной связи из предыдущих примеров:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Form;

use Zend\Form\Form;

// Модель формы обратной связи
class ContactForm extends Form
{
    // Конструктор.   
    public function __construct()
    {
        // Определяем имя формы
        parent::__construct('contact-form');

        // Устанавливаем метод POST для этой формы
        $this->setAttribute('method', 'post');
  
        // (Опционально) задаем действие для этой формы
        $this->setAttribute('action', '/contactus');
  
        // Здесь создаем поля формы ...	
    }
}
~~~

Как вы видите, модели форм модуля сайта `Application` принадлежат 
(условно) пространству имен `Application\Form` (строка 2).

В строке 7 мы определяем класс модели формы `ContactForm`, который расширяет базовый класс `Form`.

В строке 10 мы определяем метод конструктора для этого класса. Так как мы наследуем нашу модель
формы от базового класса `Form`, нам надо вызвать конструктор родительского класса для его
инициализации (строка 13). Конструктор родительского класса принимает опциональный аргумент,
позволяющий ему задать имя формы ('contact-form').

Также мы задаем метод передачи данных (POST), используя метод `setAttribute()`, предоставляемый
базовым классом (строка 16). `setAttribute()` принимает два параметра: первый - это имя атрибута,
который нужно задать, а второй - значение атрибута.

Вы также можете задать атрибут формы "action" (строка 19) с помощью метода `setAttribute()`, аналогично
тому, как вы сделали это с атрибутом "name". Вообще говоря, как вы увидите позже, задание атрибута
"action" необязательно.

I> Задание атрибута "action" для формы опционально, так как пустое действие формы
I> заставляет браузер отправить данные формы на URL текущей страницы. 
I> В большинстве ситуаций этого достаточно, так как обычно используется
I> одно действие контроллера и для отображения формы, и для обработки
I> ее данных.

Поля форм, как правило, создаются внутри конструктора модели формы (смотрите строку 21).
В следующем разделе мы узнаем, какие имеются поля форм и как добавить их к модели формы.

## Элементы форм

В модели формы поле ввода, как правило, идет в паре с текстовой меткой (теги `<label>` и `<input>`
используются вместе). Такая пара также называется *элементом* модели формы.

Аналогично полю HTML-формы, элемент модели формы может содержать имя и другие (опциональные) 
атрибуты (например, "id", "class" и т.д.) Кроме того, вы можете задать элементу *опции*;
опции главным образом позволяют вам указывать текст и атрибуты для метки элемента.

Все элементы модели формы наследуются от базового класса `Element`, который также принадлежит
компоненту `Zend\Form`. Базовый класс `Element` реализует интерфейс `ElementInterface`.
Диаграмма наследования классов показана на рисунке 7.11

![Figure 7.11. Наследование классов элементов форм](../en/images/forms/form_element_inheritance.png)

Перечисленные в таблицах 7.3 - 7.7 классы элементов форм расширяют базовый класс `Element`.
Эти классы содержатся в пространстве имен `Zend\Form\Element`.

{title="Таблица 7.3. Элементы форм, совместимые HTML 4"}
|--------------------------------|---------------------------------------------------------------|
| *Имя класса*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `Button`                       | Кнопка.                                                       |
|--------------------------------|---------------------------------------------------------------|
| `Checkbox`                     | Флажок.                                                       |
|--------------------------------|---------------------------------------------------------------|
| `File`                         | Поле файла.                                                   |
|--------------------------------|---------------------------------------------------------------|
| `Hidden`                       | Скрытое поле.                                                 |
|--------------------------------|---------------------------------------------------------------|
| `Image`                        | Поле изображения.                                             |
|--------------------------------|---------------------------------------------------------------|
| `Password`                     | Поле пароля.                                                  |
|--------------------------------|---------------------------------------------------------------|
| `Radio`                        | Переключатель.                                                |
|--------------------------------|---------------------------------------------------------------|
| `Select`                       | Выпадающий список.                                            |
|--------------------------------|---------------------------------------------------------------|
| `Submit`                       | Кнопка отправки формы.                                        |
|--------------------------------|---------------------------------------------------------------|
| `Text`                         | Универсальное поле ввода текста.                              |
|--------------------------------|---------------------------------------------------------------|
| `Textarea`                     | Многострочная текстовая область.                              |
|--------------------------------|---------------------------------------------------------------|

{title="Таблица 7.4. Элементы форм, совместимые с HTML 5"}                                        
|--------------------------------|---------------------------------------------------------------|
| *Имя класса*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `Color`                        | Выбор цвета.                                                  |
|--------------------------------|---------------------------------------------------------------|
| `Date`                         | Выбор даты.                                                   |
|--------------------------------|---------------------------------------------------------------|
| `DateTime`                     | Дата/время (с временной зоной).                               |
|--------------------------------|---------------------------------------------------------------|
| `DateTimeLocal`                | Дата/время (без временной зоны).                              |
|--------------------------------|---------------------------------------------------------------|
| `Email`                        | Поле электронной почты.                                       |
|--------------------------------|---------------------------------------------------------------|
| `Month`                        | Поле ввода месяца.                                            |
|--------------------------------|---------------------------------------------------------------|
| `Number`                       | Поле ввода текста, принимающее числа.                         |
|--------------------------------|---------------------------------------------------------------|
| `Time`                         | Поле ввода текста для времени.                                |
|--------------------------------|---------------------------------------------------------------|
| `Url`                          | Поле ввода текста для URL.                                    |
|--------------------------------|---------------------------------------------------------------| 
| `Week`                         | Поле ввода текста для дней недели.                            |
|--------------------------------|---------------------------------------------------------------| 
| `Range`                        | Поле диапазона (ползунок).                                    |
|--------------------------------|---------------------------------------------------------------|

{title="Таблица 7.5. Составные поля"}                                                                                     
|--------------------------------|---------------------------------------------------------------|
| *Имя класса*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `MultiCheckbox`                | Группа связанных флажков.                                     |
|--------------------------------|---------------------------------------------------------------|
| `DateTimeSelect`               | Выбор даты и времени.                                         |
|--------------------------------|---------------------------------------------------------------|
| `DateSelect`                   | Выбор даты.                                                   |
|--------------------------------|---------------------------------------------------------------|
| `MonthSelect`                  | Выбор месяца.                                                 |
|--------------------------------|---------------------------------------------------------------|

{title="Таблица 7.6. Элементы форм безопасности"}
|--------------------------------|---------------------------------------------------------------|
| *Имя класса*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `Captcha`                      | Изображение для проверки того, является ли клиент человеком.  |
|--------------------------------|---------------------------------------------------------------|
| `Csrf`                         | Предотвращение межсайтовой подделки запроса.                  |
|--------------------------------|---------------------------------------------------------------|

{title="Таблица 7.7. Другие элементы форм"}                             
|--------------------------------|---------------------------------------------------------------|
| *Имя класса*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `Collection`                   | Коллекция элементов.                                          |
|--------------------------------|---------------------------------------------------------------|

Как видите, элементы форм, предоставляемые ZF3, имеют отображение на поля ввода
HTML4 и HTML5 (мы обсудили это в начале раздела).

Для вашего удобства ZF3 также предоставляет несколько "составных" полей. Поле `MultiCheckbox`,
например, составлено из группы типичных флажков, связанных друг с другом. Элементы `DateTimeSelect`,
`DateSelect` и `MonthSelect` аналогичны соответствующим HTML5-элементам, но имеют также поля выбора.
Преимущество таких элементов в том, что они поддерживаются всеми браузерами, в отличие от
соответствующих полей HTML5.

![Figure 7.12. Составные поля форм](../en/images/forms/compound_form_fields.png)

Помимо этого, ZF3 предоставляет поля форм "безопасноти" `Captcha` и `Csrf`, которые могут быть использовать
для повышения безопасности. Элемент `Captcha` - это графический элемент (изображение), который размещается
на форме для проверки, кем является пользователь сайта: человеком или роботом. Элемент `Csrf` не имеет
визуального представления и используется для предотвращения хакерских атак, связанных с межсайтовой подделкой 
запроса [^csrf].

[^csrf]: Межсайтовая подделка запроса (или CSRF - Cross-Site Request Forgery) - использование уязвимостей 
         веб-сайта, посредством которого неразрешенные команды передаются от доверенного пользователя.

Существует еще один особый элемент форм, называемый `Collection`. Этот элемент аналогичен набору полей,
так как позволяет вам сгруппировать связанные элементы форм. Однако, он предназначен для добавления
элементов форм динамически, привязывая массив объектов к форме.

### Добавление элементов к модели формы

Методы, наследуемые базовым классом `Form` от класса `Fieldset` используются для добавления
элементов (и наборов полей) к модели формы. Эти методы описаны в таблице 7.8.

{title="Таблица 7.8. Методы, предоставляемые классом Fieldset"}
|----------------------------------|---------------------------------------------------------------|
| *Имя метода*                     | *Описание*                                                    |
|----------------------------------|---------------------------------------------------------------|
| `add($elementOrFieldset, $flags)`| Присоединяет элемент (или набор полей).                       |
|----------------------------------|---------------------------------------------------------------|
| `has($elementOrFieldset)`        | Проверяет, присоединен ли определенный элемент                |
|----------------------------------|---------------------------------------------------------------|
| `get($elementOrFieldset)`        | Извлекает заданный по имени элемент (или набор полей)         |
|----------------------------------|---------------------------------------------------------------|
| `getElements()`                  | Извлекает все присоединенные элементы.                        |
|----------------------------------|---------------------------------------------------------------|
| `getFieldsets()`                 | Извлекает все присоединенные наборы полей.                    |
|----------------------------------|---------------------------------------------------------------|
| `count()`                        | Возвращает количество присоединенных элементов/наборов полей. |
|----------------------------------|---------------------------------------------------------------|
| `remove($elementOrFieldset)`     | Удаляет элемент (или набор полей).                            |
|----------------------------------|---------------------------------------------------------------|

В частности, нас интересует метод `add()`, используемый для добавления элемента
к форме. Этот метод принимает два аргумента: первый, `$elementOrFieldset`, - элемент,
который нужно добавить, а второй, `$flags`, - флаги (необязательны).

Параметр `$elementOrFieldset` может быть либо экземпляром класса, наследуемого от
`Element` (или `Fieldset`), либо массивом, описывающим элемент, который должен быть создан.

Опциональный аргумент `$flags` - это массив, который может содержать набор следующих ключей:
`name` (позволяет задать имя элемента) и `priority` (позволяет указать начинающийся с нуля индекс
в списке, куда нужно вставить элемент). Если не указан флаг приоритета, элемент будет вставлен в
конец списка элементов модели формы.

Ниже мы предоставим два примера кода, иллюстрирующие возможные способы добавления элементов
к форме.

### Метод 1: Передача экземпляра элемента

Следующий фрагмент кода создает экземпляр класса `Zend\Form\Element\Text` и добавляет элемент
к модели формы:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Form;

// Определяем псевдоним для имени класса
use Zend\Form\Form;
use Zend\Form\Element\Text;

// Модель формы обратного вызова
class ContactForm extends Form
{
    // Конструктор.   
    public function __construct()
    {
        // Создаем поля форм ...	
        $element = new Text(
                'subject',            // Имя элемента
                [                     // Массив опций
                 'label'=> 'Subject'  // Текстовая метка
                ]);
        $element->setAttribute('id', 'subject');

        // Добавляем поле "subject" к форме
        $this->add($element);
    }
}
~~~
Так, мы создали экземпляр класса `Zend\Form\Element\Text` (строка 15). Конструктор класса принимает
два параметра: имя элемента ("subject") и массив опций (в примере выше мы указали текстовую
метку "Subject").

Кроме этого, вы можете настроить элемент, используя методы, предоставляемые базовым классом `Element`.
Например, в строке 20, мы задали атрибут "id" с помощью метода `setAttribute()`. В таблице 7.9
представлены методы (самые важные) базового класса `Element`, которые могут быть использованы для
настройки элемента формы. 

{title="Таблица 7.9. Методы, предоставляемые классом Element"}
|----------------------------------|---------------------------------------------------------------|
| *Имя метода*                     | *Описание*                                                    |
|----------------------------------|---------------------------------------------------------------|
| `setName($name)`                 | Задает имя элемента.                                          |
|----------------------------------|---------------------------------------------------------------|
| `getName()`                      | Извлекает имя элемента.                                       |
|----------------------------------|---------------------------------------------------------------|
| `setOptions($options)`           | Задает опции.                                                 |
|----------------------------------|---------------------------------------------------------------|
| `getOptions($options)`           | Извлекает опции.                                              |
|----------------------------------|---------------------------------------------------------------|
| `getOption($option)`             | Извлекает заданную опцию.                                     |
|----------------------------------|---------------------------------------------------------------|
| `setAttribute($key, $value)`     | Устанавливает один атрибут элемента.                          |
|----------------------------------|---------------------------------------------------------------|
| `getAttribute($key)`             | Извлекает один атрибут элемента.                              |
|----------------------------------|---------------------------------------------------------------|
| `removeAttribute($key)`          | Удаляет атрибут.                                              |
|----------------------------------|---------------------------------------------------------------|
| `hasAttribute($key)`             | Проверяет, есть ли такой атрибут.                             |
|----------------------------------|---------------------------------------------------------------|
| `setAttributes($arrayOrTraversable)`| Устанавливает несколько атрибутов за раз.                  |
|----------------------------------|---------------------------------------------------------------|
| `getAttributes()`                | Извлекает все атрибуты разом.                                 |
|----------------------------------|---------------------------------------------------------------|
| `clearAttributes()`              | Удаляет все атрибуты разом.                                   |
|----------------------------------|---------------------------------------------------------------|
| `setValue()`                     | Задает значение элемента.                                     |
|----------------------------------|---------------------------------------------------------------|
| `getValue()`                     | Извлекает значение элемента.                                  |
|----------------------------------|---------------------------------------------------------------|
| `setLabel()`                     | Устанавливает метку, используемую для этого элемента.         |
|----------------------------------|---------------------------------------------------------------|
| `getLabel()`                     | Извлекает строку метки, используемой для этого элемента.      |
|----------------------------------|---------------------------------------------------------------|
| `setLabelAttributes()`           | Задает атрибуты для использования с меткой.                   |
|----------------------------------|---------------------------------------------------------------|
| `getLabelAttributes()`           | Получает атрибуты для использования с меткой.                 |
|----------------------------------|---------------------------------------------------------------|
| `setLabelOptions()`              | Задает опции для конкретной метки.                            |
|----------------------------------|---------------------------------------------------------------|
| `getLabelOptions()`              | Извлекает опции для конкретной метки.                         |
|----------------------------------|---------------------------------------------------------------|

### Метод 2: Использование описания в виде массива

Второй пример (эквивалентный первому), который показан ниже, показывает, как использовать
описание в виде массива для добавления элемента к форме. Этот метод более предпочтителен, так
как требует меньше кода.

I> При использовании описания в виде массива для добавления элемента к форме, элемент будет 
I> инстанцирован и настроен автоматически. Это выполняется внутренне с помощью
I> класса фабрики `Zend\Form\Factory` (показано на рисунке 7.13).

![Figure 7.13. Алгоритм метода add()](../en/images/forms/factory_graph.png)

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Form;

// Определяем псевдоним для имени класса
use Zend\Form\Form;

//Модель формы обратной связи
class ContactForm extends Form
{
    // Конструктор.   
    public function __construct()
    {
        // Добавляем поле "subject"
        $this->add([
            'type'  => 'text',        // Тип элемента
            'name' => 'subject',      // Имя поля
            'attributes' => [         // Массив атрибутов
                'id'  => 'subject',     
            ],
            'options' => [            // Массив опций
                'label' => 'Subject',  // Текстовая метка
            ],
        ]);    
    }
}
~~~

В строке 14 мы вызываем метод модели формы `add()`, чтобы добавить элемент к форме.
Мы передаем описание элемента методу `add()` в виде массива. Массив имеет следующие
ключи:

* ключ `type` (строка 15) определяет имя класса для инстанцирования элемента. Вы можете использовать
  как полностью определенное имя класса (например, `Text::class`), так и его псевдоним [^псевдоним] (например, "text").

* ключ `name` (строка 16) определяет имя поля ("subject").

* ключ `attributes` (строка 17) определяет список HTML-атрибутов для задания (в примере мы задаем атрибут "id").

* ключ `options` (строка 18) позволяет указать текстовую метку для элемента.
  
[^псевдоним]: Если вы не понимаете, откуда мы берем псевдонимы элементов, вам следует знать,
          что они определяются внутри класса `Zend\Form\FormElementManager`.
  
## Пример: Создание модели формы обратной связи

Теперь, когда мы знаем, как задавать имя формы, действие и атрибуты методов, а также как добавлять поля (элементы)
к форме, давайте создадим класс модели для формы обратной связи, которую мы использовали в предыдущих примерах.

Как мы знаем, классы моделей форм для модуля `Application` "живут"
в пространстве имен `Application\Form`. Таким образом, нам нужно
создать файл *ContactForm.php* в каталоге *Form* под корневым
каталогом модуля *Application* (рисунок 7.14).

![Figure 7.14. Каталог Form](../en/images/forms/form_dir.png)

В классе формы у нас будут два метода: 

* конструктор `__construct()` будет определять имя формы и метод (POST), а также 
  инициализировать форму, добавляя элементы;
* private-метод `addElements()` будет содержать код для
  добавления элементов формы и будет вызываться конструктором. 
  
I> Мы помещаем алгоритм создания поля в private-метод `addElements()`,
I> чтобы лучше структурировать код модели формы.

Код класса `ContactForm` представлен ниже:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Form;

use Zend\Form\Form;

/**
 * Эта форма используется для сбора данных обратной связи с пользователем:
 * электронной почты, темы и текста.
 */
class ContactForm extends Form
{
    // Конструктор.   
    public function __construct()
    {
        // Определяем имя формы
        parent::__construct('contact-form');

        // Задаем метод POST для этой формы
        $this->setAttribute('method', 'post');
        	
        // Добавляем элементы формы
        $this->addElements();    
    }
    
    // Этот метод добавляет элементы к форме (поля ввода и 
    // кнопку отправки формы).
    private function addElements() 
    {
        // Добавляем поле "email"
        $this->add([
	        'type'  => 'text',
            'name' => 'email',
            'attributes' => [                
                'id' => 'email'
            ],
            'options' => [
                'label' => 'Your E-mail',
            ],
        ]);
        
        // Добавляем поле "subject"
        $this->add([
            'type'  => 'text',
            'name' => 'subject',
            'attributes' => [
              'id' => 'subject'  
            ],
            'options' => [
                'label' => 'Subject',
            ],
        ]);
        
        // Добавляем поле "body"
        $this->add([
            'type'  => 'text',
            'name' => 'body',			
            'attributes' => [                
			  'id' => 'body'
            ],
            'options' => [
                'label' => 'Message Body',
            ],
        ]);
        
        // Добавляем кнопку отправки формы
        $this->add([
            'type'  => 'submit',
            'name' => 'submit',
            'attributes' => [                
                'value' => 'Submit',
            ],
        ]);
    }        
}
~~~

В строке 10 данного фрагмента мы определяем класс `ContactForm`, который расширяет базовый
класс `Form`.

В строках 13-23 находится метод конструктора. Он вызывает конструктор базового класса
(строка 16) и передает имя формы в качестве аргумента ("contact-form").
В строке 19 вызывается метод `setAttribute()` базового класса, позволяющий задать
имя метода для формы (в нашем случае метод POST).

В строке 22 вызывается private-метод `addElements()`, который, собственно, и добавляет
элементы к форме. Код `addElements()` находится в строках 27-73.
Чтобы добавить элементы к форме, мы вызываем метод `add()` базового класса. Этот метод
принимает один аргумент -- массив, содержащий конфигурацию элемента. Мы добавляем четыре
поля: `email`, `subject`, `body` и `submit`.

На рисунке 7.15 вы видите схематическое графическое представление созданной нами модели
формы.

![Рисунок 7.15. Модель формы обратной связи и ее элементы](../en/images/forms/form_model.png)

## Добавление правил валидации формы

Валидация формы - это процедура фильтрации и проверки данных, передаваемых серверу при
отправке формы. Например, для нашей формы обратной связи мы хотим сделать следующие проверки:

* Мы хотим проверить, что присутствуют поля адреса электронной почты, темы сообщения и основного текста
  (так как эти поля *обязательны*).
* Мы хотим убедиться, что пользователь ввел действительный адрес электронной почты (*name@example.com*).
* Пользователи могут добавлять пробелы в начало и/или конец адреса электронной почты, так что мы
  хотим отфильтровывать подобные символы (удалить начальные и конечные пробелы функцией trim).
* Было бы полезно проверить минимальную и максимальную разрешенную длину темы сообщения и основного текста.
* Для темы сообщения мы хотели бы отфильтровать символы перевода строки и HTML-теги [^html] (функция strip_tags).
* Мы также хотим убрать HTML-теги из основного текста. 

[^html]: Злоумышленники могут вставлять HTML-код в сообщение. Если вы откроете такой код в браузере,
         вы можете увидеть нежелательное содержимое. Чтобы этого избежать, нужно заменить HTML-теги
		 в теме сообщения и тексте.

Требования выше называются *правилами валидации*. Эти правила могут быть разделены на
две категории: фильтры и валидаторы.

*Фильтры* изменяют введенные пользователем данные, чтобы исправить возможные ошибки
или обеспечить соответствие данных определенному формату. Фильтры, как правило, применяются
первыми, а валидаторы - последними.

*Валидаторы* проверяют, допустимы ли данные. Если все введенные данные корректны,
форма считается действительной, и данные могут безопасно использоваться уровнем бизнес-логики.
Если какое-то поле недействительно, валидатор устанавливает флаг ошибки. В этом случае, форма, как
правило, снова показывается пользователю, и тому предлагается исправить ошибки ввода и переслать
форму на сервер.

Q> **Что произойдет, если я не добавлю правило валидации для определенного поля формы?**
Q> 
Q> Если вы не добавите правило валидации, отправленное пользователем значение не
Q> будет проверено, тем самым оставив дыру в безопасности вашего сайта. Рекомендуется
Q> всегда добавлять правило валидации для каждого поля формы, заполняемого пользователем, 
Q> а также добавлять столько проверок каждому полю, сколько нужно для поддержания безопасности сайта.

### Фильтр входных данных (Input filter)

В ZF3 правила валидации хранятся с помощью класса `InputFilter`. Этот класс определяется
в компоненте `Zend\InputFilter`. Фильтр входных данных - это контейнер для так называемых *входов* (inputs).
Как правило, вы добавляете входы для каждого поля модели.

I> Входы могут состоять из фильтров и/или валидаторов и некоторой дополнительной информации.
I> Например, в них может содержаться флаг, указывающий на то, обязательно ли это поле, или его значение
I> может отсутствовать в HTTP-запросе. 

Аналогично добавлению полей модели формы, существует два способа добавить входы в фильтр:
либо через передачу экземпляра класса ввода в качестве аргумента его метода `add()`, либо через передачу
описания в виде массива [^фабрикавхода]. В следующем разделе мы опишем второй способ (он более предпочтителен,
так как требует меньшего количества кода).

[^фабрикавхода]: Во втором случае (описание в виде массива) вход будет автоматически создан
                 с помощью класса `Zend\InputFilter\Factory`.

### Добавление входов в фильтр

Чтобы добавить вход в фильтр, используйте метод `add(), который принимает описание входа в виде
массива следующим образом:

{line-numbers=on, lang=php}
~~~
[
    'name'     => '<name>',
    'type'     => '<type>',
    'required' => <required>,
    'filters'  => [
        // Добавьте конфигурацию фильтров ...
    ],                
    'validators' => [
        // Добавьте конфигурацию валидаторов ...
    ]
]
~~~

Этот массив содержит следующие ключи:

* Ключ `name` определяет имя входа. Оно должно совпадать с именем поля модели формы.
  В противном случае, правило валидации не будет применяться к полю.
  
* Ключ `type` (строка 3) определяет имя класса входа. Этот ключ опционален.
  По умолчанию (когда этот ключ пропущен) используется класс `Zend\InputFilter\Input`.
  Доступные классы входов показаны на рисунке 7.16.: класс `Input` предназначен для
  использования с обычными скалярными значениями, `ArrayInput` используется для
  фильтрации/валидации значений массива, а `FileInput` - для проверки загружаемых файлов.
  
* Ключ `required` (строка 4) сообщает, является поле формы обязательным или опциональным.
  В первом случае пользователь должен будет его заполнить, иначе появится сообщение об
  ошибке валидации.
  
* Ключи `filters` (строка 5) и `validators` (строка 8) могут содержать конфигурацию для
  одного или нескольких (или нуля) фильтров и/или валидаторов поля модели формы. 

![Рисунок 7.16. Наследование классов входов](../en/images/forms/input_inheritance.png)

#### Настройка фильтра

Типичная конфигурация фильтра представлена ниже:

{line-numbers=on, lang=php}
~~~
[
    'name' => '<filter_name>',  
    'priority' => <priority>,
    'options' => [
        // Здесь идут опции фильтра ...
    ]
],                    
~~~

Ключ `name` (строка 2) - это имя фильтра. Это может быть либо полностью определенное имя
класса фильтра (например, `StringTrim::class`) либо псевдоним (например, `StringTrim`).

Опциональный ключ `priority` (строка 3) определяет приоритет в списке фильтров. Это должно
быть число типа integer. Фильтры с наивысшем приоритетом будут применены первыми. По умолчанию
присваивается константа `FilterChain::DEFAULT_PRIORITY` (со значением 1000).

Массив `options` (строка 4), индивидуальный для каждого фильтра, может содержать параметры для настройки.

#### Настройка валидатора

Типичная конфигурация валидатора представлена ниже:
  
{line-numbers=on, lang=php}
~~~
[
    'name' => '<validator_name>',
    'break_chain_on_failure' => <flag>,
    'options' => [
        // Здесь идут опции валидатора ...
    ]
],                    
~~~
  
Ключ `name` (строка 2) - это имя валидатора. Это может быть либо полностью определенное имя
класса валидатора (например, ``EmailAddress::class`) либо псевдоним (например, `EmailAddress`).

Опциональный ключ `break_chain_on_failure` (строка 3) определяет поведение в случае неудачной проверки.
При значении `true`, последующие валидаторы в списке не будут выполняться; в противном случае каждый
валидатор в списке будет выполняться вне зависимости от результата других валидаторов.

Массив `options` (строка 4), индивидуальный для каждого валидатора, может содержать параметры для настройки.
  
#### Добавления фильтра входных данных на модель формы

Как только вы создали и заполнили фильтр входных данных, нужно добавить
его к модели формы. Базовый класс `Form` для этой цели содержит метод
`setInputFilter()` (см. таблицу 7.10).

{title="Таблица 7.10. Методы, предоставляемые базовом классом Form"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `setInputFilter($inputFilter)` | Добавляет фильтр входных данных к форме.                      |
|--------------------------------|---------------------------------------------------------------|
| `getInputFilter()`             | Извлекает фильтр входных данных, присоединенный к форме.      |
|--------------------------------|---------------------------------------------------------------|
  
### Создание фильтра входных данных для формы обратной связи

Теперь, когда у вас есть общее представление о том, как определять фильтр входных данных
и заполнять его фильтрами и валидаторами для каждого поля формы, давайте дополним нашего
класс модели формы `ContactForm`. В фрагменте кода ниже мы добавим метод `addInputFilter()`,
который определяет правила фильтрации/валидации, хранит их в фильтре входных данных и добавляет
фильтр к модели формы:


{line-numbers=on, lang=php}
~~~
<?php
// ...
use Zend\InputFilter\InputFilter;

class ContactForm extends Form
{
    public function __construct()
    {
        // ... вызовите этот мето для добавления правил валидации
        $this->addInputFilter();
    }
    
    // ...
    
    // Этот метод создает фильтр входных данных (используемый для фильтрации/валидации).
    private function addInputFilter() 
    {
        $inputFilter = new InputFilter();        
        $this->setInputFilter($inputFilter);
        
        $inputFilter->add([
            'name'     => 'email',
            'required' => true,
            'filters'  => [
                ['name' => 'StringTrim'],                    
            ],                
            'validators' => [
                [
                    'name' => 'EmailAddress',
                    'options' => [
                        'allow' => \Zend\Validator\Hostname::ALLOW_DNS,
                        'useMxCheck' => false,                            
                    ], 
                ],
            ],
        ]);
        
        $inputFilter->add([
            'name'     => 'subject',
            'required' => true,
            'filters'  => [
                ['name' => 'StringTrim'],
                ['name' => 'StripTags'],
                ['name' => 'StripNewlines'],
            ],                
            'validators' => [
                [
                    'name' => 'StringLength',
                    'options' => [
                        'min' => 1,
                        'max' => 128
                    ],
                ],
            ],
        ]);
    
        $inputFilter->add([
            'name'     => 'body',
            'required' => true,
            'filters'  => [                    
                ['name' => 'StripTags'],
            ],                
            'validators' => [
                [
                    'name' => 'StringLength',
                    'options' => [
                        'min' => 1,
                        'max' => 4096
                    ],
                ],
            ],
        ]);                
    }  
}
~~~

В этом фрагменте первым делом мы объявляем псевдоним для класса `Zend\InputFilter\InputFilter` (строка 3).

В конструкторе модели формы (строка 10), мы вызываем метод `addInputFilter()`, который определяется
в строках 16-76.

Задача метода `addInputFilter()` - создать контейнер `InputFilter (строка 18), присоединить его к
модели формы (строка 19) и затем добавить правила фильтрации/валидации (строки 21-75). Для добавления
фильтра входных данных к модели формы мы используем метод `setInputFilter()`, предоставляемый базовым
классом `Form`. Чтобы добавить правила фильтрации/валидации в фильтр, используется метод `add()` класса
`InputFilter`, принимающий описание входа, который нужно создать, в виде массива.

Мы добавляем три входа (по одному для каждого поля нашей модели формы, кроме кнопки отправки формы):

* Для поля `email` мы устанавливает флаг `required` на значение `true`, чтобы сделать заполнение
  этого поля обязательным. Мы используем фильтр StringTrim`, чтобы убрать пробелы из начала и конца
  адреса электронной почты; и валидатор `EmailAddress` для проверки введенного пользователем адреса
  на корректность. Мы настраиваем валидатор `EmailAddress` так, чтобы разрешать использованием доменных
  имен в качестве адресов эл. почты (флаг `\Zend\Validator\Hostname::ALLOW_DNS`) и отключаем проверку
  MX-записи (устанавливаем опцию `useMxCheck` на `false`).

* Поле `subject` мы аналогичным образом делаем обязательным, а затем используем фильтр `StringTrim`
  для удаления пробелов из начала и конца. Кроме этого мы используем фильтры `StripNewlines`
  и `StripTags`, чтобы  отфильтровать соответственно символы перевода строки и HTML-теги.
  Используя валидатор `StringLength` мы ограничиваем длину строки темы - от 1 до 128 символов.

* Поле `body` мы также делаем обязательным, и используем фильтр `StripTags`, чтобы убрать HTML-теги
  из основного текста. Помимо этого, мы с помощью валидатора `StringLength` ограничиваем текст 
  электронного сообщения - от 1 до 4096 символов.

На рисунке 7.17 представлено схематическое графическое представление созданного нами фильтра
входных данных.
  
![Рисунок 7.17. Фильтр входных данных для ContactForm](../en/images/forms/input_filter.png)
  
T> Выше мы вкратце описали, как создавать фильтр входных данных для модели формы. 
T> За более детальной информацией об упомянутых выше (и других) фильтрах и валидаторах, а также
T> за примерами их использования, обратитесь к главам [Преобразование данных с помощью фильтров](#filters) и 
[Проверка входных данных с помощью валидаторов](#validators).

## Использование формы в действии контроллера

Когда класс модели формы будет готов, вы наконец сможете использовать форму
в методе действия контроллера.

Как вы уже, возможно, знаете, то, как пользователь работает с формой - это, как правило,
итеративный процесс (схематически изображен на рисунке 7.18):

![Рисунок 7.18. Типичный процесс использования формы](../en/images/forms/form_workflow.png)

 * Сперва вы отображаете форму и ее поля на веб-странице, предлагая пользователю ввести данные.
   Как только пользователь заполнит поля, он нажмет на кнопку *Submit*, отправив данные серверу.
 * Затем ваш контроллер извлекает эти данные и запрашивает их валидацию у модели формы. Если были
   какие-либо ошибки ввода, форма отображается снова, предлагая пользователю их исправить. Если данные
   корректны, вы обрабатывается данные с помощью уровня бизнес-логики и (обычно) перенаправляете пользователя
   на другую веб-страницу.
   
Базовый класс `Form` предоставляет для этих целей несколько методов (см. таблицу 7.11).

{title="Таблица 7.11.Методы, предоставляемые базовым классом Form"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода *                  | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `setData($data)`               | Задает данные формы для валидации.                            |
|--------------------------------|---------------------------------------------------------------|
| `getData($flag)`               | Извлекает валидированные данные.                              |
|--------------------------------|---------------------------------------------------------------|
| `isValid()`                    | Валидирует форму.                                             |
|--------------------------------|---------------------------------------------------------------|
| `hasValidated()`               | Проверяет, была ли форма валидирована.                        |
|--------------------------------|---------------------------------------------------------------|
| `getMessages($elementName = null)`| Возвращает список сообщений о неудачных валидациях, если   |
|                                | такие есть, для одного элемента или для всех элементов формы. |
|--------------------------------|---------------------------------------------------------------|

Таким образом, общий процесс использования формы таков:
  
* Проверяем, были ли отправлены данные формы, и, если нет, отображаем форму на веб-странице.

* Если данные были отправлены пользователем, необработанные данные извлекаются из
  переменных `POST` и/или `GET` в виде массива.

* Данные присваиваются полям модели формы с использованием метода `setData()`.

* Выполняются фильтрация и валидация с использованием метода `isValid()`
  (это приводит к выполнению фильтра входных данных, присоединенного к форме).
  Если определенное поле (или поля) недействительно(ы), форма отображается снова,
  и пользователю предлагается исправить данные.

* Как только данные прошли фильтрацию и валидацию, они извлекаются из модели
  формы методом `getData()` и передаются другим моделям либо используются любым другим способом.

Пример кода ниже показывает, как реализовать этот процесс в методе действия контроллера:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Controller;

use Application\Form\ContactForm;
// ...

class IndexController extends AbstractActionController 
{
    // Это действие отображает форму обратной связи
    public function contactUsAction() 
    {
        // Создаем форму
        $form = new ContactForm();
        
        // Проверяем, отправил ли пользователь форму
        if($this->getRequest()->isPost()) 
        {
            // Заполняем форму POST-данными
            $data = $this->params()->fromPost();            
            $form->setData($data);
            
            // Валидируем форму
            if($form->isValid()) {
                
                // Получаем фильтрованные и валидированные данные
                $data = $form->getData();
                
                // ... Какие-то действия с валидированными данными ...
		
                // Перенаправление на страницу "Спасибо"
                return $this->redirect()->toRoute('application', ['action'=>'thankYou']);
            }            
        } 
        
        // Передаем переменную формы представлению
        return new ViewModel([
           'form' => $form
        ]);
    }
}
~~~

В этом фрагменте мы определяем метод действия `contactUsAction()` в классе `IndexController` (строка 10).
В методе действия мы создаем экземпляр класса `ContactForm` (строка 13).

Затем в строке 16 мы проверяем, является ли запрос POST-запросом (проверяя первую строку HTTP-запроса).

В строке 19 мы извлекаем необработанные данные, отправленные пользователем. Все переменные POST
извлекаются с помощью плагина контроллера `Params`. Данные возвращаются в форме массива и сохраняются
в переменную `$data`.

Данные, отправленные пользователем, могут содержать ошибки и должны пройти фильтрацию и валидацию перед
дальнейшим использованием. Для этого в строке 20 мы задаем эти данные модели с помощью метода `setData()` базового
класса `Form`. Мы затем валидируем данные формы методом `isValid()` (строка 23), который возвращает значение `true`
при успешной валидации. Если валидация проходит успешно, мы извлекаем валидированные данные с помощью метода `getData()`
(строка 26) и затем можем передать их уровню бизнес-логики.

После использования валидированных данных мы перенаправляем веб-пользователю на страницу *Thank You* (строка 31).
Перенаправление осуществляется с помощью плагина контроллера `Redirect`. Метод этого плагина `toRoute()` принимает
два параметра: первый параметр - имя маршрута ("application"), а второй - массив параметров, которые нужно передать
маршрутизатору. Эти параметры определяют страницу, куда перенаправляется пользователь.

I> Мы подготовим действие контроллера и шаблон представления для страницы благодарности
I> немного позже.

В строке 37 мы передаем модель формы шаблону представлению через переменную `$form`. Шаблон представления
будет обращаться к этой переменной и использовать ее для визуализации формы (и возможных ошибок валидации).

### Передача модели данных формы

В качестве реального примера использования валидированных данных формы обратной связи, в этом
примере мы создадим простой класс модели `MailSender` [^сервис], которая может быть использована
для отправки электронного сообщения на адрес электронной почты. Когда пользователь отправит форму,
мы проведем валидацию данных формы, а затем передадим валидированные данные модели `MailSender` и
потребуем отправить сообщение электронной почты получателю.

[^service]: С точки зрения DDD, `MailSender` можно отнести к моделям сервисов, так как ее задачей
            является управление данными, а не их хранение.

T> Этот раздел по большей части предназначен для начинающих. Вы можете пропустить его и
T> сразу перейти к следующему разделу *Представление формы*.
       
Модель `MailSender` будет внутренне использовать компонент `Zend\Mail`. Этот компонент, предоставляемый
Zend Framework 3, предназначен для обеспечения разработчика удобной функциональностью для составления
почтовых сообщений (класс `Zend\Mail\Message`) и несколькими классами, реализующими доступные методы
передачи (в этом примере мы будем использовать класс `Mail\Transport\Sendmail`, который использует программу
*sendmail* для доставки электронной почты).


I> Установите компонент `Zend\Mail` с помощью Composer'a, прописав следующую команду:
I> 
I> `php composer.phar require zendframework\zend-mail`

I> Программа [sendmail](http://www.sendmail.com/sm/open_source/) - распространяемый бесплатно вместе с исходными кодами
I> агент передачи почты для операционных систем Linux/Unix. Он принимает сообщения, передаваемые ему PHP-скриптом, решает, 
I> какой метод доставки использовать, в зависимости от заголовка сообщения, и затем передает сообщение через протокол
I> SMTP на почтовый сервер (например, Google Mail) для доставки получателю.

Начнем с создания файла *MailSender.php* под каталогом *Service* под корневым каталогом 
модуля (см. рисунок 7.19).

![Создание 7.19. Создание файла MailSender.php](../en/images/forms/mailsender.png)

Ниже представлен код, который нужно поместить в файл *MailSender.php*:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Service;

use Zend\Mail;
use Zend\Mail\Message;
use Zend\Mail\Transport\Sendmail;

// Этот класс используется для доставки электронного письма получателю.
class MailSender 
{
    // Отправляет эл. сообщение.
    public function sendMail($sender, $recipient, $subject, $text) 
    {
        $result = false;
        try {
        
            // Создаем эл. сообщение
            $mail = new Message();
            $mail->setFrom($sender);
            $mail->addTo($recipient);
            $mail->setSubject($subject);
            $mail->setBody($text);
	  
            // Посылаем эл. сообщение
            $transport = new Sendmail('-f'.$sender);
            $transport->send($mail);
            $result = true;
        } catch(\Exception $e) {
            $result = false;
        }
        
        // Возвращаем статус 
        return $result;
    }
}
~~~

В этом фрагменте мы определяем пространство имен `Application\Service` (строка 12), так как класс
`MailSender` можно отнести к моделям сервисов (его задачей является управление данными, а не их хранение).

В строках 4-6 мы объявляем псевдонимы для классов `Mail`, `Message` и `Transport\Sendmail`, предоставляемых
компонентом `Zend\Mail`.

В строках 9-35 мы определяем класс `MailSender`. У него есть один единственный метод `sendMail()` (строка 12),
который принимает четыре аргумента: адрес электронной почты отправителя, адрес электронной почты получателя,
тема сообщения и, наконец, основной текст сообщения.

В строке 18 мы создаем экземпляр класса `Message`. Мы используем методы этого класса, чтобы составить
сообщение (задать его тему, текст и т.д.) в строках 19-22.

В строке 25 мы создаем экземпляр класса `Sendmail`, который использует программу *sendmail* для передачи
сообщения почтовому серверу (см. строки 25-26). Так как классы, предоставляемые компонентом `Zend\Mail` могут
выбрасывать исключение при ошибке, мы заключим этот фрагмент кода в блок обработки исключений try-catch

Метод `sendMail()` вернет значение `true`, если сообщение было успешно отправлено; в противном случае он вернет
`false` (строка 33).

I> Настройка почтовой системы для веб-сервера - это довольно сложная задача. Она, как правило,
I> требует установки sendmail и настройки записи MX DNS сервера для использования определенного 
I> почтового сервера (либо локального, например, [Posftix](http://www.postfix.org/), 
I> либо удаленного вроде Google Mail). 
I> Из-за сложности этой темы, мы не обсуждаем ее в данной книге. Вы можете 
I> найти дополнительную информацию о настройки почты для вашей конкретной системы в Интернете.

Теперь зарегистрируем сервис `MailSender` в файле `module.config.php` следующим образом:

{line-numbers=off, lang=php}
~~~
return [
    //...
    'service_manager' => [
        'factories' => [
            Service\MailSender::class => InvokableFactory::class,
        ],
    ],
    
    //...
];
~~~

Далее вы сможете инстанцировать модель `MailSender` в методе `IndexController::contactUsAction()` и передать ей
валидированные данные формы.

I> Так как мы используем сервис `MailSender` в нашем контроллере, этот сервис является *зависимостью* для контроллера.
I> Таким образом, нам необходимо будет создать фабрику для контроллера и *внедрить* зависимость  в конструктор контроллера.
I> Кажется сложным на первый взгляд, но когда вы улучшите свои навыки, то поймете, что это довольно просто и
I> значительно улучшает структуру вашего кода.

Давайте создадим фабрику для `IndexController` (поместим ее в подкаталог `Factory` под каталогом `Controller`).
Как видите, вся работа класса фабрики заключается в создании контроллера и передаче ему зависимости.

{line-numbers=off, lang=php}
~~~
<?php
namespace Application\Controller\Factory;

use Interop\Container\ContainerInterface;
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\MailSender;
use Application\Controller\IndexController;

class IndexControllerFactory
{
    public function __invoke(ContainerInterface $container, 
                             $requestedName, array $options = null)
    {
        $mailSender = $container->get(MailSender::class);
        
        // Instantiate the controller and inject dependencies
        return new IndexController($mailSender);
    }
}
~~~

Изменим файл `module.config.php`, чтобы он использовал только что созданную нами фабрику:

{line-numbers=off, lang=php}
~~~
return [
    //...
    'controllers' => [
        'factories' => [
            Controller\IndexController::class => Controller\Factory\IndexControllerFactory::class,
        ],
    ],
    
    //...
];
~~~

Затем добавим к контроллеру конструктор, а также методы `contactUsAction()`, `thankYouAction()` и`sendErrorAction()`.

{line-numbers=on, lang=php}
~~~
<?php
// ...
use Application\Service\MailSender;

class IndexController extends AbstractActionController 
{
    private $mailSender;
    
    public function __construct($mailSender) 
    {
        $this->mailSender = $mailSender;
    }
    
    public function contactUsAction() 
    {
        // Создаем форму обратной связи
        $form = new ContactForm();
        
        // Проверяем, отправил ли пользователь форму
        if($this->getRequest()->isPost()) {
            
            // Заполняем форму POST-данными
            $data = $this->params()->fromPost();            
            
            $form->setData($data);
            
            // Валидируем форму
            if($form->isValid()) {
                    
                // Получаем фильтрованные и валидированные данные
                $data = $form->getData();
                $email = $data['email'];
                $subject = $data['subject'];
                $body = $data['body'];
                    
                // Отправляем эл. почту
                if(!$this->mailSender->sendMail('no-reply@example.com', $email, 
                            $subject, $body)) {
                    // В случае ошибки перенаправляем на страницу "Ошибка отправки электронной почты"
                    return $this->redirect()->toRoute('application', 
                            ['action'=>'sendError']);
                }
                    
                // Перенаправляем на страницу "Спасибо"
                return $this->redirect()->toRoute('application', 
                            ['action'=>'thankYou']);
            }            
        } 
        
        // Передаем переменную формы представлению
        return new ViewModel([
            'form' => $form
        ]);
    }
    
    // Это действие отображает страницу благодарности. Пользователь перенаправляется на эту
    // страницу при успешной отправке письма.
    public function thankYouAction() 
    {
        return new ViewModel();
    }
    
    // Это действие отображает страницу ошибки. Пользователь перенаправляется на эту
    // страницу в случае ошибки при отправке письма.
    public function sendErrorAction() 
    {
        return new ViewModel();
    }
}
~~~

Как вы видите из фрагмента кода выше, мы делаем следующее:

* В строке 3 мы определяем псевдоним для класса `Application\Service\MailSender`.
  Это позволит ссылаться на класс модели по его короткому имени.
  
* В строках 32-34, после валидации формы, мы извлекаем валидированные значениями
  полей в PHP-переменные `$email`, `$subject` и `$body`.

* В строке 37 мы вызываем метод `sendMail()` сервиса `MailSender` и передаем ему
  четыре параметра: адрес отправителя (в примере мы используем "no-reply@example.com", но
  вы можете заменить его своим); адрес электронной почты получателя, тему электронного
  сообщение и его основной текст.

* Если письмо было успешно отправлено (если метод `sendMail() вернул значение `true`), мы
  перенаправляем пользователя на страницу *Thank You* (строка 45). В случае ошибки (если
  метод `sendMail() вернул значение `false`) пользователь перенаправляется на страницу
  *Send Error* (строка 40).
  
* В строках 58-61 находится метод `thankYouAction()`, отображающий страницу благодарности.
  Эта страница показывается при успешной отправке письма.
  
* В строках 65-68 находится метод `sendErrorAction()`, отображающий страницу ошибки отправки письма.
  Эта страница показывается при неудачной отправке.
  
## Представление формы

Когда действие контроллера будет готово, вам останется только подготовить файл
шаблона представления `.phtml` для отображения формы на веб-страницы. В шаблоне 
представления необходимо определить разметку, используя HTML-теги `<form>`, `<label>`, 
`<input>` и, возможно, некоторые другие.

Кроме того, вам нужно будет отображать сообщения об ошибке при неудачной валидации
формы. Так как это весьма скучная работа, Zend Framework 3 предоставляет специальные
помощники видов, предназначенные для визуализации формы.

T> Для простых форм (которые не показывают сообщения об ошибках), можно использовать необработанные
T> HTML-теги для визуализации форм и игнорировать помощники видов форм, предоставляемые ZF3.
T> Однако, использование помощников видов форм при визуализации сложных форм, которые могут
T> отображать ошибки валидации и/или динамически добавлять поля .

### Подготовка модели формы к визуализации

Перед визуализацией необходимо вызвать метод `prepare()` для экземпляра модели формы. Если вы
забудете это сделать, могут возникнуть нежелательные эффекты.

{title="Таблица 7.12 Методы, предоставляемые базовым классом Form"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `prepare()`                    | Удостоверяется, что форма готова к использованию.             |
|--------------------------------|---------------------------------------------------------------|

Метод `prepare()` осуществляет следующую подготовку модели формы:
  
  * Он вызывает фильтр входных данных, присоединенный к модели формы,
    чтобы удостовериться, что сообщения об ошибках валидации доступны.
  * Он подготавливает любые элементы и/или наборы полей, требующие подготовки [^обертка].

[^обертка]: Как правило, в результате, имена полей обертывается именем формы/набором полей
            (например, имя поля "email" станет "contact-form[email]"), что технически
			приводит к более удобной группировке полей в теле HTTP-запроса.

## Стандартные помощники видов форм

Стандартные помощники видов форм, предоставляемые ZF3, показаны  ниже в таблицах 7.13 - 7.16.
Эти классы содержатся в пространстве имен `Zend\Form\View\Helper`. Как видно из раблиц, помощники
видов можно разделить на следующие категории:

* *Общие помощники видов форм.* Эти классы предназначены для визуализации 
  формы целиком (помощник `Form`) или одного ее элемента (помощник `FormElement`), 
  а также возможных ошибок валидации (помощник `FormElementErrors`).

* *Помощники видов для визуализации HTML-полей определенных типов.* Эти помощники позволяют 
  генерировать HTML-разметку для конкретных полей форм (например, `FormButton`, `FormRadio` и т.д.) 
  и текстовую метку (`FormLabel`).
  
* *Помощники видов для визуализации полей форм, введенных в HTML5.* Аналогичнв
  помощникам из предыдущей категории, но предназначены для визуализации HTML-5
  полей (например, `FormDate`, `FormUrl` и т.д.)
   
* *Другие помощники видов.* В эту категорию мы поместим классы помощников видов, предназначенные
  для визуализации полей, предоставляемых ZF3 (`FormMultiCheckbox`, `FormCaptcha` и др.)

{title="Таблица 7.13. Помощники видов, предназначенные для работы с формами"}
|----------------------------------|---------------------------------------------------------------|
| *Имя метода*                     | *Описание*                                                    |
|----------------------------------|---------------------------------------------------------------|
| *Общие помощники*                |                                                               |
|----------------------------------|---------------------------------------------------------------|
| `Form`                           | Визуализирует форму целиком и все ее элементы.                |
|----------------------------------|---------------------------------------------------------------|
| `FormElement`                    | Визуализирует один элемент формы.                             |
|----------------------------------|---------------------------------------------------------------|
| `FormElementErrors`              | Визуализирует ошибки валидации для элемента формы.            |
|----------------------------------|---------------------------------------------------------------|
| `FormRow`                        | Визуализирует метку, поле и ошибки валидации                  |
|----------------------------------|---------------------------------------------------------------|

{title="Таблица 7.14. Помощники HTML4-полей"}                 
|----------------------------------|---------------------------------------------------------------|
| *Имя метода*                     | *Описание*                                                    |                                               
|----------------------------------|---------------------------------------------------------------|
| `FormButton`                     | Визуализирует поле формы `<button>`.                          |
|----------------------------------|---------------------------------------------------------------|
| `FormCheckbox`                   | Визуализирует поле `<input type="checkbox">` field.           |
|----------------------------------|---------------------------------------------------------------|
| `FormFile`                       | Визуализирует поле формы `<input type="file">`.               |
|----------------------------------|---------------------------------------------------------------|
| `FormHidden`                     | Визуализирует поле формы `<input type="hidden">`.             |
|----------------------------------|---------------------------------------------------------------|
| `FormInput`                      | Визуализирует поле формы `<input>`.                           |
|----------------------------------|---------------------------------------------------------------|
| `FormImage`                      | Визуализирует поле формы `<input type="image">`.              |
|----------------------------------|---------------------------------------------------------------|
| `FormLabel`                      | Визуализирует тег `<label>`.                                  |
|----------------------------------|---------------------------------------------------------------|
| `FormPassword`                   | Визуализирует поле формы `<input type="password">`.           |
|----------------------------------|---------------------------------------------------------------|
| `FormRadio`                      | Визуализирует поле формы `<input type="radio">`.              |
|----------------------------------|---------------------------------------------------------------| 
| `FormReset`                      | Визуализирует поле формы `<input type="reset">`.              |
|----------------------------------|---------------------------------------------------------------|
| `FormSelect`                     | Визуализирует выпадающее поле `<select>`.                     |
|----------------------------------|---------------------------------------------------------------|
| `FormSubmit`                     | Визуализирует поле формы `<input type="submit">`.             |
|----------------------------------|---------------------------------------------------------------|
| `FormText`                       | Визуализирует поле формы `<input type="text">`.               |
|----------------------------------|---------------------------------------------------------------|
| `FormTextarea`                   | Визуализирует многострочное текстовое поле `<textarea>`.      |
|----------------------------------|---------------------------------------------------------------|


{title="Таблица 7.15. Помощники HTML5-полей"}                 
|----------------------------------|---------------------------------------------------------------|
| *Имя метода*                     | *Описание*                                                    |                                                         |
|----------------------------------|---------------------------------------------------------------|
| `FormColor`                      | Визуализирует HTML5-поле формы `<input type="color">`.        |
|----------------------------------|---------------------------------------------------------------|
| `FormDate`                       | Визуализирует HTML5-поле формы `<input type="date">`.         |
|----------------------------------|---------------------------------------------------------------|
| `FormDateTime`                   | Визуализирует HTML5-поле формы `<input type="date">`.         |
|----------------------------------|---------------------------------------------------------------|
| `FormDateTimeLocal`              | Визуализирует HTML5-поле формы `<input type="datetime-local">`. |
|----------------------------------|---------------------------------------------------------------|
| `FormEmail`                      | Визуализирует HTML5-поле формы `<input type="email">`.        |
|----------------------------------|---------------------------------------------------------------|
| `FormMonth`                      | Визуализирует HTML5-поле формы `<input type="month">`.        |
|----------------------------------|---------------------------------------------------------------|
| `FormNumber`                     | Визуализирует HTML5-поле формы `<input type="number">`.       |
|----------------------------------|---------------------------------------------------------------|
| `FormRange`                      | Визуализирует HTML5-поле формы `<input type="range">`.        |
|----------------------------------|---------------------------------------------------------------|
| `FormTel`                        | Визуализирует HTML5-поле формы `<input type="tel">`.          |
|----------------------------------|---------------------------------------------------------------|
| `FormTime`                       | Визуализирует HTML5-поле формы `<input type="time">`.         |
|----------------------------------|---------------------------------------------------------------|
| `FormUrl`                        | Визуализирует HTML5-поле формы `<input type="url">`.          |
|----------------------------------|---------------------------------------------------------------|
| `FormWeek`                       | Визуализирует HTML5-поле формы `<input type="week">`.         |
|----------------------------------|---------------------------------------------------------------|

{title="Таблица 7.16. Другие помощники"}                 
|----------------------------------|---------------------------------------------------------------|
| *Имя метода*                     | *Описание*                                                    |
|----------------------------------|---------------------------------------------------------------|
| `FormCaptcha`                    | Визуализирует поле безопасности CAPTCHA.                      |
|----------------------------------|---------------------------------------------------------------|
| `FormDateSelect`                 | Визуализирует поле выбора даты.                               |
|----------------------------------|---------------------------------------------------------------|
| `FormDateTimeSelect`             | Визуализирует поле выбора даты и времени.                     |
|----------------------------------|---------------------------------------------------------------|
| `FormMonthSelect`                | Визуализирует поле выбора месяца.                             |
|----------------------------------|---------------------------------------------------------------|
| `FormMultiCheckbox`              | Визуализирует поле нескольких флажков.                        |
|----------------------------------|---------------------------------------------------------------|
| `FormCollection`                 | Визуализирует коллекцию элементов.                            |
|----------------------------------|---------------------------------------------------------------|

В следующих разделах мы опишем несколько наиболее часто используемых помощников видов, а также
представим примеры их использования.

### Визуализация элемента формы

Поле формы можно визуализировать с помощью помощника вида `FormElement`. Он задуман быть
максимально гибким и распознавать как можно больше типов полей. Так, с его помощью вы можете 
создавать HTML-разметку для текстовых полей, кнопок, выпадающих списков и т.д.


Методы, предоставляемые этим помощником, перечислены в таблице 7.17. 

{title="Метод 7.17. Методы, предоставляемые помощником вида FormElement"}
|----------------------------------|---------------------------------------------------------------|
| *Имя метода*                     | *Описание*                                                    |
|----------------------------------|---------------------------------------------------------------|
| `render($element)`               | Магический PHP-метод, который визуализирует заданное поле формы. |
|----------------------------------|---------------------------------------------------------------|
| `__invoke($element)`             | Магический PHP-метод, который визуализирует заданное поле формы |
|                                  | (тот же эффект, что и от `render()`).                       |
|----------------------------------|---------------------------------------------------------------|

Как видите, существуют два метода, делающие одно и то же:

  * Метод `render()` создает HTML-разметку для поля формы.
    Он принимает один аргумент -- экземпляр элемента, который нужно визуализировать. Вы
    можете извлечь элемент формы с помощью метода модели формы `get()` (см. пример ниже).
  * Метод `__invoke()` - это удобная обертка, в этом случае требуется писать меньше кода.

{line-numbers=off, lang=php}
~~~
<?php 
// Мы полагаем, что модель формы хранится в переменной $form.
// Визуализируем поле эл. почты с помощью метода render().
echo $this->formElement()->render($form->get('email')); ?>

// То же самое, но с помощью __invoke
echo $this->formElement($form->get('email')); 
~~~

После выполнения фрагмента выше, сгенерируется следующий HTML-код:

{line-numbers=off, lang=html}
~~~
<input type="text" name="email" id="email" value="">
~~~

T> Как правило, нет необходимости вызывать помощники видов для определенных
T> полей HTML (или HTML5) (например, `FormText` `FormSubmit` и др.)
T> Вместо этого можно использовать общий помощник вида `FormElement`, который
T> автоматически определяет тип поля и создает нужный HTML-код.

### Визуализация ошибок валидации элемента

Класс помощника вида `FormElementErrors` позволяет создать HTML-разметку для 
ошибок валидации полей (если они есть). Если для определенного элемента нет ошибок
валидации, помощник не создаст выходных данных.

Пример использования помощника вида `FormElementErrors` представлен ниже:

{line-numbers=off, lang=php}
~~~
<?php 
// Мы полагаем, что модель формы хранится в переменной $form.
// Визуализируем ошибки валидации для поля эл. почты.
echo $this->formElementErrors($form->get('email')); 
~~~

Если ошибки валидации были, этот код сгенерирует неупорядоченный список ошибок, используя
HTML-тег <`ul`>. Этот список будет содержать столько элементов, сколько ошибок у определенного 
поля. Пример такого списка для поля эл. почты нашей формы обратной связи показан ниже:

{line-numbers=off, lang=html}
~~~
<ul>
  <li>&#039;hostname&#039; is not a valid hostname for the email address</li>
  <li>The input does not match the expected structure for a DNS hostname</li>
  <li>The input appears to be a local network name but local network names are not allowed</li>
</ul> 
~~~

### Визуализация метки элемента

Помощник `FormLabel` позволяет визуализировать текстовую метку для элемента:

{line-numbers=off, lang=php}
~~~
<?php 
// Мы полагаем, что модель формы хранится в переменной $form.
// Визуализируем текстовую метку для поля эл. почты.
echo $this->formLabel($form->get('email')); 
~~~

После выполнения фрагмента выше, сгенерируется следующий HTML-код:

{line-numbers=off, lang=html}
~~~
<label for="email">Your E-mail</label>
~~~

### Визуализация строки формы

Помощник вида `FormRow` предназначен для упрощения визуализации поля формы,
его метки и ошибок валидации. С помощью этого класса можно визуализировать
эти элементы одним действием. Этот помощник гибко настраиваемый, так что вы можете
применить другое оформление для строки формы. Методы этого помощника вида перечислены
в таблице 7.18.

{title="Таблица 7.18. Методы, предоставляемые помощником вида FormRow"}
|----------------------------------------|---------------------------------------------------------|
| *Имя метода*                           | *Описание*                                              |
|----------------------------------------|---------------------------------------------------------|
| `render($element)`                     | Визуализирует строку формы.                             |
|----------------------------------------|---------------------------------------------------------|
| `__invoke($element, $labelPosition, $renderErrors, $partial)` | Визуализирует строку формы (обертка). |
|----------------------------------------|---------------------------------------------------------|
| `setInputErrorClass($inputErrorClass)` | Задает SSS-класс ошибки входных данных.                 |
|----------------------------------------|---------------------------------------------------------|
| `setLabelAttributes($labelAttributes)` | Задает атрибуты метки.                                  |
|----------------------------------------|---------------------------------------------------------|
| `setLabelPosition($labelPosition)`     | Задает позицию метки. (перед или после поля).           |
|----------------------------------------|---------------------------------------------------------|
| `setRenderErrors($renderErrors)`       | Устанавливает, визуализируются ли ошибки этим помощником. |
|----------------------------------------|---------------------------------------------------------|
| `setPartial($partial)`                 | Задает частичный скрипт вида, используемый для визуализации строки. |
|----------------------------------------|---------------------------------------------------------|

Пример использования помощника вида `FormRow` представлен ниже:

{line-numbers=off, lang=php}
~~~
<?php 
// Мы полагаем, что модель формы хранится в переменной $form.
// Визуализируем поле эл. почты, его метку и (возможно) ошибки валидации.
echo $this->formRow($form->get('email')); 
~~~

После выполнения фрагмента выше, сгенерируется следующий HTML-код:

{line-numbers=off, lang=html}
~~~
<label for="email">Your E-mail</label>
<input type="text" name="email" id="email">
<ul>
  <li>&#039;hostname&#039; is not a valid hostname for the email address</li>
  <li>The input does not match the expected structure for a DNS hostname</li>
  <li>The input appears to be a local network name but local network names 
      are not allowed</li>
</ul> 
~~~

### Визуализация формы целиком

Помощник вида `Form` позволяет визуализировать открывающий тег `<form>` и его атрибуты; 
и закрывающий тег `</form>`. Но его главная цель - это визуализация целой формы и всех
ее полей одной строчкой кода. Public-методы помощника вида `Form` резюмированы в таблице 7.19. 

{title="Table 7.19. Методы, предоставляемы помощником вида Form"}
|----------------------------------|---------------------------------------------------------------|
| *Имя метода*                     | *Описание*                                                    |
|----------------------------------|---------------------------------------------------------------|
| `render($form)`                  | Визуализация целой формы и всех ее полей.                     |
|----------------------------------|---------------------------------------------------------------|
| `__invoke($form)`                | Магический PHP-метод, который визуализирует целую форму и все |
|                                  | ее элементы (тот же эффект, что и от `render()`).             |
|----------------------------------|---------------------------------------------------------------|
| `openTag($form)`                 | Визуализирует открывающий тег `<form>`.                       |
|----------------------------------|---------------------------------------------------------------|
| `closeTag()`                     | Визуализирует закрывающий тег `</form>` tag.                  |
|----------------------------------|---------------------------------------------------------------|

Вы можете визуализировать форму целиком с помощью метода `render()` следующим образом:

{line-numbers=off, lang=php}
~~~
// Мы полагаем, что модель формы хранится в переменной $form.

// Визуализируем форму целиком
echo $this->form()->render($form);
~~~

Того же результата можно достичь магическим методом `__invoke` (см. пример ниже):

{line-numbers=off, lang=php}
~~~
// То же самое, но с помощью `__invoke`
echo $this->form($form);
~~~

## Пример: создание шаблона представления для формы обратной связи

Теперь мы можем определить представление для нашей формы обратной связи.
Если помните, ранее мы добавили шаблон представления *contact-us.phtml* в
каталог *application/index/* под каталогом модуля *view/*. Замените код
в этом файле на следующий:

{line-numbers=on, lang=php}
~~~
<?php
$form = $this->form;
$form->prepare();
?>

<?= $this->form()->openTag($form); ?>
	
<?= $this->formLabel($form->get('email')); ?>
<?= $this->formElement($form->get('email')); ?>
<?= $this->formElementErrors($form->get('email')); ?>                  
	
<?= $this->formLabel($form->get('subject')); ?>
<?= $this->formElement($form->get('subject')); ?>
<?= $this->formElementErrors($form->get('subject')); ?>
   
<?= $this->formLabel($form->get('body')); ?>
<?= $this->formElement($form->get('body')); ?>
<?= $this->formElementErrors($form->get('body')); ?>                  
	
<?= $this->formElement($form->get('submit')); ?>
	
<?= $this->form()->closeTag(); ?>
~~~

Как видите из фрагмента выше, для визуализации формы мы делаем следующее:

* В строке 2 мы обращаемся к переменной $form, переданной от действия контроллера. 

* В строке 3 мы вызываем метод `prepare()` для подготовки формы к 
  визуализации. Обратите внимание, что вызов этого метода крайне важен. Если вы забудете
  это сделать, могут возникнуть нежелательные проблемы с визуализацией.

* В строке 6 мы вызываем метод `openTag()` помощника вида `Form`. Его задача - визуализировать
  открывающий тег `<form>` и его атрибуты. Этот метод принимает один аргумент -- экземпляр
  модели формы. Закрывающий тег `</form>` визуализируется в строке 22 с помощью метода
  `closeTag()`.
  
* В строках 8-10 мы визуализируем метку моля электронной почты, само поле текста и возможные
  ошибки валидации с помощью помощников видов `FormLabel`, `FormElement` и `FormElementErrors`.
  Эти помощники принимают в качестве единственного аргумента экземпляр элемента модели формы,
  который мы получаем методом `get()`, предоставляемым базовым классом `Form`.
  
* В строках 12-24 мы аналогичным образом визуализируем поле темы письма, его метку и ошибки валидации.

* Наконец, в строке 16-18 мы визуализируем метку, поле и ошибки валидации для поля области основного текста.

* В строке 20 мы визуализируем кнопку отправки формы.
  
После исполнения этого кода визуализатором шаблона представления , мы получим следующий HTML-код: 

{line-numbers=off, lang=html}
~~~
<form action="/contact" method="post" name="contact-form">
  <label for="email">Your E-mail</label>
  <input type="text" name="email" id="email" value="">
        
  <label for="subject">Subject</label>
  <input name="subject" type="text" id="subject" value="">

  <label for="body">Message Body</label>
  <textarea name="body" id="body"></textarea>
       
  <input name="submit" type="submit" value="Submit">
</form>
~~~

I> Во фрагменте выше мы в основном использовали помощники видов `FormElement`, `FormElementErrors`
I> и `FormLabel`. Вы можете использовать общие помощники `FormRow` или `Form`, если
I> хотите писать меньше кода, но это может привести к снижению возможностей управления оформлением формы.

Если определенные поля имеют ошибки валидации, эти ошибки будут выведены
под полем в виде неупорядоченного HTML-списка `<ul>`.
Например, если вы введете "123@hostname" в поле формы электронной почты,
вы получите следующие ошибки валидации:

{line-numbers=off, lang=html}
~~~
<label for="email">Your E-mail</label>
<input type="text" name="email" value="123@hostname">
<ul>
  <li>&#039;hostname&#039; is not a valid hostname for the email address</li>
  <li>The input does not match the expected structure for a DNS hostname</li>
  <li>The input appears to be a local network name but local network names 
      are not allowed</li>
</ul> 
~~~

### Применение CSS-стилей Bootstrap к форме

Созданной выше HTML-разметке не хватает стилизации CSS. Мы хотим добиться
привлекательного, профессионально выглядящего внешнего вида формы с помощью
CSS-классов Twitter Bootstrap. Для добавления стилизации Bootstrap к форме,
нужно изменить код в файле *.phtml*, чтобы он выглядел как показано ниже:

{line-numbers=on, lang=php}
~~~
<?php
$form = $this->form;
$form->prepare();

$form->get('email')->setAttributes([
  'class'=>'form-control', 
  'placeholder'=>'name@example.com'
  ]);
  
$form->get('subject')->setAttributes([
  'class'=>'form-control', 
  'placeholder'=>'Type subject here'
  ]);
  
$form->get('body')->setAttributes([
  'class'=>'form-control', 
  'rows'=>6, 
  'placeholder'=>'Type message text here'
  ]);
  
$form->get('submit')->setAttributes(['class'=>'btn btn-primary']);
?>

<h1>Contact Us</h1>

<p>
  Пожалуйста, заполните следующую форму для связи с нами. 
  Мы высоко ценим ваши отзывы.
</p>

<div class="row">
  <div class="col-md-6">
    <?= $this->form()->openTag($form); ?>
        
    <div class="form-group">
      <?= $this->formLabel($form->get('email')); ?>
      <?= $this->formElement($form->get('email')); ?>
      <?= $this->formElementErrors($form->get('email')); ?>
    </div>
        
    <div class="form-group">
      <?= $this->formLabel($form->get('subject')); ?>
      <?= $this->formElement($form->get('subject')); ?>
      <?= $this->formElementErrors($form->get('subject')); ?>
    </div>
        
    <div class="form-group">
      <?= $this->formLabel($form->get('body')); ?>
      <?= $this->formElement($form->get('body')); ?>
      <?= $this->formElementErrors($form->get('body')); ?>
    </div>
        
    <?= $this->formElement($form->get('submit')); ?>
        
    <?= $this->form()->closeTag(); ?>
  </div>    
</div>
~~~

В этом фрагменте мы добавили CSS-класс `.form-control` к каждому полю ввода в форме.
Мы сделали это методом `setAttribute()` (см. строки 5, 10 и 15).
С помощью данного метода мы также добавили атрибут "placeholder" для определения
привлекательного текста плейсхолдера, когда поле пусто. Для поля "body" мы добавили
атрибут "rows", определяющий высоту поля (6 строк).

Для кнопки формы *Submit* мы используем CSS-классы `.btn` и `.btn-primary` 
(см. строку 21).

Мы помещаем пары «метка-ввод» в элементы `<div>` с помощью CSS-класса `.form-group` 
(строки 35, 41, 47).

Мы также помещаем форму в ячейку сетки шириной в 6 столбцов, что делает форму шириной 
в половину экрана.

T> Иногда невозможно использовать стили Twitter Bootstrap со стандартными помощниками вида ZF3 для рендеринга форм.
T> Например, стандартные помощники вида `FormCheckbox` и `FormRadio` не могут быть использованы со стилями
T> Bootstrap. К счастью, существует сторонний модуль [neilime/zf2-twb-bundle](https://github.com/neilime/zf2-twb-bundle)
T> , который вы можете установить с помощью Composer (не смущайтесь имени модуля - он вполне поддерживает ZF3). Данный модуль предоставляет удобные помощники вида для рендеринга форм ZF3
T> и применения к ним стилей Bootstrap. Он работает прозрачно, так что когда вы установили модуль, стандартные помощники вида ZF3 для рендеринга форм
T> заменяются на помощники, предоставляемые модулем, то есть вам не придется менять код своих шаблонов представлений.

### Стилизация списка ошибок валидации

По умолчанию, сообщения об ошибках на вашей форме выглядят как типичный неупорядоченный
список (`<ul>`). Чтобы придать им приятный внешний вид, мы добавим пару CSS-правил в файл
*style.css* в каталоге *APP_DIR/public*:

{line-numbers=off, lang=css}
~~~
form ul {
  list-style-type: none;
  padding: 0px;
  margin: 0px 5px;
}

form ul li {    
  color: red;        
}
~~~

С помощью этих CSS-правил из списка убираются маркеры, а сообщения об ошибках валидации
показываются красным.

### Добавление страниц "Thank You" и "Error Sending Email"

И наконец, последнее, что мы сделаем - подготовим шаблоны представления для
страниц благодарности и ошибки отправки письма ("Thank You" и "Error Sending Email").

Добавим шаблон представления *thank-you.phtml* в каталог *application/index/* под
каталогом модуля *view/* и поместим следующую HTML-разметку в файл шаблона представления:

{line-numbers=off, lang=html}
~~~
<h1>Спасибо!</h1>

<p>
  <div class="alert alert-success">
    Мы ответим на указанный вами адрес электронной почты.
  </div>
</p>
~~~

Затем добавим файл шаблона представления *send-error.phtml*. 
HTML-разметка для страницы ошибки отправки письма представлены ниже:

{line-numbers=off, lang=html}
~~~
<h1>Ошибка отправки письма!</h1>

<p>
  <div class="alert alert-warning">
    Возникла непредвиденная ошибка при попытке отправки
    вашего сообщения. Пожалуйста, повторите попытку позже.
  </div>
</p>
~~~

### Результат

Поздравляем! Теперь при открытии в браузере URL "http://localhost/contactus",
вы должны увидеть страницу как на рисунке 7.20.

{width=80%}
![Рисунок 7.20. Форма обратной связи](../en/images/forms/contact_form.png)

Если вы введете недействительные данные в форму и нажмете на кнопку отправки,
вы должны будете увидеть ошибки валидации (рисунок 7.21).

![Рисунок 7.21. Ошибки валидации формы](../en/images/forms/validation_errors_page.png)

Ввод корректного e-mail'a, темы и текста сообщения и отправка формы
приведет к отправке сообщения и отображения страницы *Thank You* (см. рисунок 7.22).

![Рисунок 7.22. Страница благодарности](../en/images/forms/thank_you_page.png)

При ошибке отправке вы увидите страницу *Error Sending Email* (см. рисунок 7.23):

![Рисунок 7.23. Страница ошибки отправки письма](../en/images/forms/send_error_page.png)

T> Форму *Contact Us* можно увидеть в действии в примере *Form Demo*, который
T> идет в комплекте с этой книгой.

## Выводы

Формы - это способ сбора введенных пользователем на веб-страницах данных. Форма
обычно состоит из элементов (пары «поле ввода + метка»). Элементы могут быть
сгруппированы в наборы полей.

На сайтах на базе MVC функциональность форм разделена на модели форм, ответственные
за определение элементов и валидацию, и представление форм, реализованные с
помощью специальных помощников видов.

Чтобы создать модель формы, нужно написать класс, наследующийся от базового класса
`Form`. Модель формы инициализируется путем добавления ее элементов с помощью методов
базового класса.

Чтобы отправить данные формы на сервер, пользователь нажимает кнопку *Submit* (кнопка отправки
формы), и затем данные отправляются в качестве части HTTP-запроса. После того, как пользователь
отправил форму, вы можете извлечь данные формы в контроллере и обратиться к модели формы для их
валидации.

Для проверки и фильтрации введенных пользователем данных, применяются фильтры и валидаторы.
Используйте класс `InputFiler`, который является контейнером для правил валидации.

При наличии ошибок ввода данных, нужно снова отобразить форму, предложив пользователю
их исправить. Если данные корректны, они обрабатываются уровнем бизнес-логики.

