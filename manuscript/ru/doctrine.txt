# Управление базой данных с помощью ORM Doctrine {#doctrine}

Doctrine - это PHP-библиотека с открытым исходным кодом, предоставляющая удобные методы для 
управления базой данных объектно-ориентированным способом. Для работы с реляционными БД Doctrine
предоставляет компонент, который называется Object
Relational Mapper - ORM. С помощью ORM таблице базы данных ставится в соответствие PHP-класс
(с точки зрения DDD - предметно-ориентированного проектирования - он также называется классом
*сущности*), а строке этой таблицы - экземпляр класса сущности. Если вы еще не знакомы с 
Doctrine, рекомендуем также обратиться к [Приложению Г. Введение в Doctrine](#doctrine-intro)
за вводной информацией об архитектуре этой библиотеки.

I> Doctrine не является частью Zend Framework 3, это сторонняя библиотека. Мы рассматриваем ее
I> в этой книге, потому что она предоставляет легкий способ добавления поддержки базы данных
I> в веб-приложение на базе ZF3.

Компоненты, рассматриваемые в данной главе:

|--------------------------------|---------------------------------------------------------------|
| *Компонент*                    | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `Doctrine\ORM`                 | Реализует Object-Relational Mapper.                           |
|--------------------------------|---------------------------------------------------------------|
| `DoctrineORMModule`            | Простая интеграция между Doctrine ORM и ZF3.                  |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Paginator`               | Поддержка пагинации.                                          |
|--------------------------------|---------------------------------------------------------------|

## Загрузка примера Blog с GitHub

Для демонстрации использования ORM Doctrine в этой главе мы создадим веб-сайт в виде блога *Blog*,
который делает следующее:

  * Хранит посты блога в базе данных и предоставляет пользовательский интерфейс для доступа к
    этим постам и управления ими. 
  * Предполагается, что автор постов у блога один, а комментарии могут добавляться несколькими
    читателями.
  * Сайт содержит две страницы: *Home* и *Admin*. Первая отображает список недавно добавленных постов,
    а вторая позволяет их добавлять, изменять, просматривать и удалять.
 
Скриншоты с примерами такого сайта показаны ниже на рисунках 12.1 и 12.2:
 
![Рисунок 12.1. Главная страница блога](../en/images/doctrine/blog_home_page.png)  

![Рисунок 12.2. Страница администратора](../en/images/doctrine/blog_admin_page.png) 

Чтобы скачать приложение *Blog* перейдите на [эту страницу](https://github.com/olegkrivtsov/using-zf3-book-samples)
и нажмите кнопку *Clone or Download*, чтобы скачать код в виде ZIP-архива. 
По завершении загрузки, распакуйте архив в какой-нибудь каталог.

Затем перейдите к каталогу `blog`, содержащему исходный код
веб-приложения *Blog*:

{line-numbers=off,lang=text}
~~~
/using-zf3-book-samples
    /blog
    ...
~~~

Вы можете установить пример сайта *Blog* на свой компьютер. Для этого нужно
либо изменить файл виртуального хоста Apache по умолчанию, либо создать
новый. После изменения файла, перезапустите HTTP-сервер Apache и откройте
сайт в своем браузере.

T> Для детальных инструкций по установке, обратитесь к файлу *README.md*, расположенному в директории *blog*.

I> Для работы данного примера нужно создать базу данных MySQL. Инструкции о том, 
как это сделать, приведены в следующем разделе.

## Создание простой базы данных MySQL

Для работы блога нам нужна база данных. В этой книге мы используем систему управления базами
данных MySQL, которая очень проста в установке и администрировании.

T> За инструкциями по установке сервера и клиента MySQL для различных ОС обратитесь к
   [Приложению А. Настройка среды веб-разработки](#devenv).

После установки MySQL наберите следующую команду в командной оболочке для входа в консольный
клиент MySQL.
   
`mysql -u root -p`

При запросе пароля, введите пароль пользователя *root* (вы указали его в процессе установки
MySQL-сервера). При успешной авторизации вы увидите следующее сообщение:

{line-numbers=off,lang=text}
~~~
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 4
Server version: 5.7.13-0ubuntu0.16.04.2 (Ubuntu)

Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql>
~~~

Теперь вы можете набирать команды клиента MySQL (`show databases`, `show tables` и др.) или
SQL-запросы (например, `SELECT` или `INSERT`) в командной строке и видеть их результат.

I> Для выхода из командной строки MySQL, наберите `quit`и нажмите Enter.

### Создание новой базы данных

Теперь двайте создадим базу данных и назовем ее `blog`. Для этого наберите следующий оператор SQL
и нажмите Enter:

{line-numbers=off,lang=text}
~~~
CREATE DATABASE blog;
~~~

Ожидаемый результат этой команды такой:

`Query OK, 1 row affected (0.01 sec)`

T> Команды MySQL нечувствительны к регистру, так что с тем же результатом можно было набрать `create database blog;`.
   Мы рекомендуем использовать верхний регистр для SQL-запросов, так как это является стандартом оформления.

Далее, создадим пользователя с именем `blog` и зададим ему все привилегии для доступа к базе данных
`blog` и внесения изменений в нее и все ее таблицы: 
   
{line-numbers=off,lang=text}
~~~
GRANT ALL PRIVILEGES ON blog.* TO blog@localhost IDENTIFIED BY '<passwd>';
~~~

В команде выше замените плейсхолдер паролем для пользователя `blog`. Этот пароль должен
отличаться от пароля для пользователя *root*.

I> Мы создаем нового пользователя `blog`, так как для веб-приложения не рекомендуется входить
I> в базу данных под пользователем `root`. Пользователь *root* имеет неограниченные права, и
I> было бы просто небезопасно предоставлять приложению возможность совершать любые действия. 
I> У пользователя `blog` будут права только на изменение базы данных `blog`, чего в нашем случае достаточно. 

Созданную базу данных можно проверить, набрав следующую команду и нажав Enter:

`show databases;`

Вы должны будете увидеть такой результат (обратите внимание на строку `blog` в списке баз данных):

{line-numbers=off,lang=text}
~~~
+--------------------+
| Database           |
+--------------------+
| information_schema |
| blog               |
| mysql              |
| performance_schema |
+--------------------+
~~~

### Создание таблиц

Далее, мы создадим три таблицы, типичные для любого простого блога: таблицу `post`, содержащую
посты, таблицу `comment`, содержащую комментарии к ним и таблицу `tag`, содержащую теги (тег является
своего рода ключом, описывающим пост блога).

Кроме этого, мы создадим вспомогательную четвертую таблицу `post_tag`, которая будет использоваться
для создания отношения «многие-ко-многим» между таблицами `post` и `tag`.

Сделаем базу данных `blog` текущей, набрав из командной строки MySQL следующее:

`use blog;`

Чтобы создать таблицу `post`, наберите следующий оператор SQL:

{line-numbers=off,lang=text}
~~~
CREATE TABLE `post` (     
  `id` int(11) PRIMARY KEY AUTO_INCREMENT,
  `title` text NOT NULL,    
  `content` text NOT NULL,           
  `status` int(11) NOT NULL, 
  `date_created` datetime NOT NULL
);
~~~

I> Клиент MySQL позволяет легко вводить многострочные команды. Для перевода каретки на новую строку
I> просто нажмите Enter. Команда считается введенной при встрече с символом «точка с запятой» (;).

Ожидаемый результат этой команды:

`Query OK, 0 rows affected (0.22 sec)`

Теперь создадим таблицу `comment` следующим образом:

{line-numbers=off,lang=text}
~~~
CREATE TABLE `comment` (     
  `id` int(11) PRIMARY KEY AUTO_INCREMENT,
  `post_id` int(11) NOT NULL,  
  `content` text NOT NULL,                
  `author` varchar(128) NOT NULL,   
  `date_created` datetime NOT NULL 
);
~~~

После этого создадим таблицу `tag`:

{line-numbers=off,lang=text}
~~~
CREATE TABLE `tag` (     
  `id` int(11) PRIMARY KEY AUTO_INCREMENT,
  `name` VARCHAR(128)                     
);
~~~

И наконец, создадим таблицу `post_tag`:

{line-numbers=off,lang=text}
~~~
CREATE TABLE `post_tag` (     
  `id` int(11) PRIMARY KEY AUTO_INCREMENT,
  `post_id` int(11) NOT NULL,
  `tag_id` int(11) NOT NULL
);
~~~

Давайте заполним созданные нами таблицы примерами данных:

{line-numbers=off, lang=text}
~~~
INSERT INTO tag(`name`) VALUES('ZF3');
INSERT INTO tag(`name`) VALUES('book');
INSERT INTO tag(`name`) VALUES('magento');
INSERT INTO tag(`name`) VALUES('bootstrap');

INSERT INTO post(`title`, `content`, `status`, `date_created`) VALUES(
   'A Free Book about Zend Framework',
   'I''m pleased to announce that now you can read my new book "Using Zend Framework 3" absolutely for free! Moreover, the book is an open-source project hosted on GitHub, so you are encouraged to contribute.', 
   2, '2016-08-09 18:49');

INSERT INTO post(`title`, `content`, `status`, `date_created`) VALUES(
   'Getting Started with Magento Extension Development - Book Review',
   'Recently, I needed some good resource to start learning Magento e-Commerce system for one of my current web projects. For this project, I was required to write an extension module that would implement a customer-specific payment method.', 
   2, '2016-08-10 18:51');

INSERT INTO post(`title`, `content`, `status`, `date_created`) VALUES(
   'Twitter Bootstrap - Making a Professionaly Looking Site',
   'Twitter Bootstrap (shortly, Bootstrap) is a popular CSS framework allowing to make your website professionally looking and visually appealing, even if you don''t have advanced designer skills.', 
   2, '2016-08-11 13:01');

INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(1, 1);
INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(1, 2);
INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(2, 2);
INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(2, 3);
INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(3, 4);

INSERT INTO comment(`post_id`, `content`, `author`, `date_created`) VALUES(
    1, 'Excellent post!', 'Oleg Krivtsov', '2016-08-09 19:20');
~~~

I> При необходимости базу данных вместе со всеми ее таблицами и данными легко можно удалить, набрав 
I> следующую команду из консоли MySQL:
I>
I> `DROP DATABASE blog;`

Рисунок 12.3 графически иллюстрирует сущности нашей базы данных и отношения между ними.

![Рисунок 12.3. Графическое представление схемы базы данных](../en/images/doctrine/database_schema.png)

Как видите из рисунка, таблицы `post` и `comment` имеют связь *один-ко-многим*, так как у одного
поста может быть несколько комментариев. Это также называется отношением «один-ко-многим».

Таблицы `post` и `tag` имеют связь *многие-ко-многим*. У одного поста может быть много тегов,
а один тег, в свою очередь, может принадлежать нескольким постам. Отношение «многие-ко-многим»,
как правило, реализуется через вспомогательную таблицу (в нашем случае это таблица `post_tag`).

### Импорт готовой схемы базы данных 

В предыдущем разделе мы показали, как создать схему базы данных, которая используется в 
приложении *Blog*. В реальной жизни вы, как правило, не будете набирать все эти операторы
SQL в командную строку MySQL. Вместо этого можно просто записать операторы `CREATE TABLE`
в файл и сохранить его на диск. Затем вы можете просто импортировать этот файл, и у вас
будет готовая схема.

Для вашего удобства, готовая схема для примера *Blog* находится в файле *APP_DIR/data/schema.mysql.sql*.
Это обычный текстовый файл, содержащий операторы SQL. Для его импорта перейдите в каталог *APP_DIR/data/* 
и наберите в командной оболочке следующую команду (не в командной строке MySQL):

`mysql -u root -p blog < schema.mysql.sql`

При запросе пароля, наберите пароль пользователя root и нажмите Enter.

После этого войдите в клиент MySQL и наберите следующие команды:

{line-numbers=off,lang=text}
~~~
use blog;

show tables;
~~~

Вы должны будете увидеть список созданных таблиц, подобный этому:

{line-numbers=off,lang=text}
~~~
+----------------+
| Tables_in_blog |
+----------------+
| comment        |
| post           |
| post_tag       |
| tag            |
+----------------+
4 rows in set (0.00 sec)
~~~

T> Кроме того, рассмотрите использование *миграций базы данных* для инициализации схемы базы данных.
T> Обратитесь к главе [Миграции баз данных](#migrations) за дополнительной информацией о миграциях.  

## Интеграция ORM Doctrine и Zend Framework 3

Для легкой интеграции с Zend Framework 3, Doctrine предоставляет два следующих компонента
(которые, на самом деле, являются модулями ZF3):

  * [DoctrineModule](https://github.com/doctrine/DoctrineORMModule) - это модуль ZF3, который 
    предоставляет необходимую для компонента ORM базовую функциональность Doctrine;

  * [DoctrineORMModule](https://github.com/doctrine/DoctrineORMModule) предназначен для интеграции
    объектно-реляционного преобразователя (ORM) Doctrine и Zend Framework 3.

Оба этих компонента распространяются в качестве пакета, устанавливаемого Composer'ом и зарегистрированного
в каталоге [Packagist.org](https://packagist.org/). Этот способ похож на тот, что использует Zend Framework 3
для установки своих компонентов.
    
Так как пакеты Composer могут зависеть друг от друга, достаточно объявить зависимость только от *DoctrineORMModule*.
Этот пакет зависит от *DoctrineModule* и некоторых других компонентов Doctrine (*Doctrine\\ORM*, *Doctrine\\DBAL*, 
*Doctrine\\Common*, *Doctrine\\Annotations* и др.). Таким образом, при установке этого компонента, Composer
автоматически установит другие необходимые компоненты.
	
### Установка компонентов Doctrine с помощью Composer
	
Для того чтобы установить необходимые компоненты Doctrine, сперва мы *добавим зависимость* в файл *composer.json*,
находящийся в корневом каталоге веб-приложения (в данной книге это, как правило, каталог *APP_DIR*).

Чтобы добавить зависимость, наберите в командной оболочке следующие команды (замените плейсхолдер
*APP_DIR* именем каталога вашего приложения):

`cd APP_DIR`

`php composer.phar require doctrine/doctrine-orm-module`

Команда `cd` используется для того, чтобы сделать *APP_DIR* текущим рабочим каталогом. 

Команда `require` указывает Composer'у добавить пакет `doctrine/doctrine-orm-module` в
качестве зависимости к вашему веб-приложению и скачать и установить эту зависимость. 

Как только вы запустите приведенные выше команды, Composer сперва изменит файл *composer.json*,
а затем создаст такую строку под ключом `require`:

{line-numbers=off,lang=json}
~~~
{
    ...  
    "require": {    
        "doctrine/doctrine-orm-module": "^1.0.9",    
        ...
    },
    ...  
}
~~~

После этого Composer попытается определить местонахождение пакетов зависимостей, загрузить их
на локальную машину и установить файлы в каталог *APP_DIR/vendor*.

Composer выведет в консоль информацию о процессе установки. Как можно видеть из этих строк,
при установке компонента `DoctrineORMModule` Composer автоматически устанавливает `DoctrineModule`
и все необходимые компоненты Doctrine (*Doctrine\\DBAL*, *Doctrine\\ORM*, и др.)

I> В качестве бонуса, в конце установки Composer "предложит" вам установить несколько дополнительных
I> пакетов, которые могут быть вам полезны (`doctrine/migrations`, `doctrine/data-fixtures`, и др.) Если
I> хотите, можете также добавить эти зависимости с помощью команды Composer'а `require`.

После завершения установки, файлы Doctrine можно найти в каталоге *APP_DIR/vendor*
(см. рисунок 12.4 ниже).
  
![Рисунок 12.4. Файлы Doctrine, установленные в каталог поставщика](../en/images/doctrine/installed_doctrine_files.png)

T> Используйте команду `php composer.phar require` при первой установке Doctrine. После того, как файлы
T> *composer.json* (и *composer.lock*) будут изменены Composer'ом, вы сможете установить (или обновить)
T> все зависимости обычным путем, командами `php composer.phar install` или `php composer.phar update`
T> соответственно.

### Загрузка модулей интеграции Doctrine при запуске приложения

После того, как вы установили *DoctrineORMModule* и все его зависимости, нужно
добавить следующие строки в файл *APP_DIR/config/modules.config.php* для включения модулей:

{line-numbers=on,lang=php}
~~~
<?php
return [
    // Добавляем модули интеграции Doctrine.
    'DoctrineModule',
    'DoctrineORMModule',      
    //...
);
~~~

Этот код сообщает ZF3, что при старте приложения нужно загружать модули DoctrineModule* и *DoctrineORMModule*.
  
### Обзор конфигурации Doctrine
   
Чтобы использовать Doctrine в своем веб-приложении, нужно также предоставить ее конфигурацию.
Конфигурация указывают Doctrine, какие присутствуют базы данных, как к ним подключиться (какие использовать
драйвер БД, хост, имя пользователя и пароль), где искать классы сущностей и как извлекать
их аннотации (метаданные), как хранить кэшированные данные (в файловой системе или использовать
расширение для кэширование) и т.д. Цель этого раздела - дать вам общее представление о том,
как выглядит настройка Doctrine.
   
Настройка Doctrine по умолчанию распложена в файле конфигурации *module.config.php* модулями
*DoctrineORMModule*. Как может выглядеть "дерево" конфигурации Doctrine можно посмотреть ниже
на рисунке 12.5 [^конфигурация_doctrine]. Также для этого вы можете обратиться к самому файлу
*module.config.php*.

![Рисунок 12.5. Графическое представление "дерева" настройки Doctrine](../en/images/doctrine/doctrine_config_tree.png)	

[^конфигурация_doctrine]: Дерево на рисунке 12.5 может отличаться от того, которое получилось в 
                          вашем приложении, так как некоторые ключи были опущены для простоты.							

Как можете видеть из рисунка 12.5, существует ключ верхнего уровня с именем `doctrine`. Под этим
ключом находится большое количество подключей, содержащих следующие настройки:					
					
  * ключ `connection` содержит список всех баз данных, к которым может подключиться веб-приложение.
    Для каждого соединения он также содержит параметры: имя класса драйвера, хост, имя пользователя, 
	пароль и имя БД. 
	
I> По умолчанию, там находится только одно соединение - `orm_default`, и, если потребуется, вы можете добавить
   другие.
 
  * ключ `configuration` содержит такие настройки ORM, как настройка кэширования и местонахождения 
    автосгенерированных классов классов сущностей для каждого доступного соединения.
  
  * ключ `driver` содержит информацию о том, где находятся классы сущностей для каждого
    доступного соединения.

  * ключ `entitymanager` содержит настройки, используемые для инстанцирования менеджера 
    сущностей для каждого доступного соединения.
  
  * ключ `eventmanager` содержит настройки менеджера событий Doctrine для каждого
    доступного соединения.
  
I> Doctrine использует свою собственную реализацию менеджера событий. Если хотите, можете создать класс
I> обработчика событий и его реакции. Однако, подобные продвинутые темы в этой книге мы рассматривать не будем.
  
  * ключ `migrations_configuration` содержит настройки для миграций баз данных. Миграции БД
    используются для инициализации и обновления схемы базы данных стандартным и непротиворечивым способом. 
  		
### Переопределение настройки Doctrine по умолчанию
   
Как вы уже знаете из главы [Как работает веб-сайт](#operation), конфигурация веб-приложения на базе ZF3, как правило,
делится на две категории: настройка на уровне приложения и настройка на уровне модуля.
   
  * Для хранения настроек Doctrine на уровне приложения, обычно используются файлы конфигурации *APP_DIR/config/autoload/global.php* 
    или *APP_DIR/config/autoload/local.php*. Первый хорошо подходит для хранения настроек, не зависимых
	от конкретной среды, а второй - наоборот, для хранения настроек, зависимых от среды (например, параметры
	подключения к базе данных).
	
  * Для хранения настроек Doctrine для определенного модуля, используется файл конфигурации *module.config.php*,
    находящийся внутри каталога *config* этого модуля. Это подходит, например, для хранения настроек 
	местонахождения сущности.
	
Когда сайт на базе ZF3 загружает свои настройки, он объединяет все конфигурации в один большой массив,
тем самым формируя окончательное "дерево" конфигурации Doctrine.
	
I> Добавляя свою настройку Doctrine на уровне приложения, вы расширяете и/или перезаписываете
I> дерево настроек по умолчанию, предоставляемых *DoctrineORMModule*.

## Указание параметров подключения к базе данных

Ниже мы представим содержимое файла *autoload/local.php* веб-приложения *Blog*.
Этот файл конфигурации содержит настройки подключения к базе данных на уровне
приложения для MySQL-БД `blog`, которую мы создали ранее в этой главе:

I> Это соединение используется всеми модулями приложения. Если вы хотите создать соединение
I> для определенного модуля, вместо этого стоит использовать файл *module.config.php*.

{line-numbers=on,lang=php}
~~~
<?php
use Doctrine\DBAL\Driver\PDOMySql\Driver as PDOMySqlDriver;

return [
    'doctrine' => [
        'connection' => [
            'orm_default' => [
                'driverClass' => PDOMySqlDriver::class,
                'params' => [
                    'host'     => '127.0.0.1',                    
                    'user'     => 'blog',
                    'password' => '<password>',
                    'dbname'   => 'blog',
                ]
            ],            
        ],        
    ],
];
~~~

В этом фрагменте находятся ключ `doctrine` и подключ `connection`. Подключ `connection` в свою
очередь содержит подключ `orm_default`, который является соединением по умолчанию.

  * Ключ `driverClass` предоставляет имя класса для использования в качестве драйвера БД. Так
    как мы используем базу данных MySQL, мы указываем имя класса `Doctrine\DBAL\Driver\PDOMySql\Driver`. 

T> Для справки в таблице 12.1 приведены несколько других часто используемых драйверов.
   Каждый класс драйвера поддерживает свой набор параметров, поэтому, пожалуйста, обратитесь
   к коду конкретного драйвера (и соответствующей документации) за дополнительной информацией.

  * Ключ `params` содержит параметры соединения:

    * `host` может быть либо доменным именем, либо IP-адресом сервера БД;
    * `user` - имя пользователя MySQL с правами доступа к базе данных;
    * `password` - секретное слово для имени пользователя;
    * `dbname`  - имя базы данных.

{title="Таблица 12.1. Классы часто используемых драйверов БД"}
|------------------------------------|----------------------------------------------------|
| *Драйвер*                          | *Описание*                                         |
|------------------------------------|----------------------------------------------------|
| `Doctrine\DBAL\Driver\PDOSqlite\Driver` | Драйвер SQLite, использующий PHP-расширение PDO. |
|------------------------------------|----------------------------------------------------|
| `Doctrine\DBAL\Driver\PDOMySql\Driver`  | Драйвер MySQL, использующий PHP-расширение PDO. |
|------------------------------------|----------------------------------------------------|
| `Doctrine\DBAL\Driver\PDOOracle\Driver` | Драйвер Oracle, использующий PHP-расширение PDO. |
|------------------------------------|----------------------------------------------------|
| `Doctrine\DBAL\Driver\PDOPgSql\Driver`  | Драйвер PostgreSQL, использующий PHP-расширение PDO. |
|------------------------------------|----------------------------------------------------|
| `Doctrine\DBAL\Driver\PDOSqlsrv\Driver` | Драйвер MS SQL Server, использующий PHP-расширение PDO. |
|------------------------------------|----------------------------------------------------|

I> Так как файл *autoload/local.php* содержит параметры для определенной среды, 
I> в системе контроля версий вы храните его "шаблон распространения" *local.php.dist*.
I> Затем каждый разработчик из вашей команды переименовывает файл *local.php.dist* в *local.php*
I> и вводит собственный пароль вместо плейсхолдера. Файл *local.php* не стоит хранить под
I> контролем версий, так как вы можете не хотеть, чтобы другие люди в вашей команде (или
I> другие люди с доступом к вашему репозиторию кода) видели ваш пароль.  

Q> **Что если мне нужно несколько соединений с БД?**
Q>
Q> Вы легко можете добавить соединения, вставив другие ключи под ключом `orm_default`. Предположим,
Q> например что у вас есть другая база данных, предназначенная для тестирования. Чтобы оповестить
Q> Doctrine об этой базе данных, нужно создать подключ `orm_test` под ключом `orm_default` и
Q> заполнить его параметрами подключения.

## О сущностях Doctrine

*Сущность (entity)* - это PHP-класс, предназначенный для хранения данных. Ниже приведены 
несколько примеров наиболее часто используемых сущностей:

  * Сущность `User` предназначена для хранения информации о посетителе сайта. Она может
    содержать такие свойства, как логин, пароль, имя, фамилию и др.
	 
  * Сущность `License` предназначена для хранения информации о лицензии программного обеспечения. Она
    может содержать такие данные, как уникальный ключ лицензии, ссылку на пользователя, который приобрел 
	лицензию, дату создания лицензии и др.
	
  * Сущность `Payment` может содержать свойства, связанные с приобретением неких товаров. Такими свойствами
    являются: ID транзакции, сумма покупки, валюта и др.	 

I> С точки зрения DDD, сущности - это тип моделей, предназначенных для хранения данных.
   За дополнительными примерами сущностей и других типов моделей обратитесь к главе [Модель-Представление-Контроллер](#mvc).

В ORM Doctrine классу сущности ставится в соответствие определенная таблица базы данных. Например, сущности
`User` обычно ставится в соответствие таблица `user` (имя таблицы, если нужно, может быть произвольным).
   
Для нашего приложения *Blog* мы создадим три класса сущностей:  
   
  * Сущность `Post` будет содержать данные, связанные с определенным постом блога. Ее свойства
    будут точно такими же, какие мы использовали при определении таблицы `post` в схеме базы данных
	`blog`. Этот класс сущности также будет геттеры и сеттеры для получения/задания данных.
	
  * По аналогии, сущность `Comment` будет содержать данные, связанные с комментариями к посту блога.
  
  * и сущность `Tag` будет содержать данные, связанные с тегами.
  
### Аннотации

*Аннотация* - это особый тип PHP-комментария, который предобрабатывается ORM Doctrine.
Другие словами, аннотации - это метаданные, добавленные к классу сущности, которые могут
быть прочитаны ORM Doctrine во время выполнения. Аннотации предоставляют подробную информацию
о сущности. Они описывают сущность и сообщают ORM Doctrine, каким образом установить 
соответствие между ней и таблицей базы данных.

Аннотация Docblock - это комментарий в стиле языка C++, начинающийся со слеша (/) и двух
звездочек (*). Эти "начальные" символы необходимы, иначе Doctrine не сможет распознать
аннотацию. Пример аннотации показан ниже:
 
{line-numbers=off,lang=php}
~~~
/**
 * Это аннотация DocBlock.
 */
~~~

Doctrine читает doc-блоки с помощью компонента `Doctrine\Annotations`.

T> Возможно, вы уже сталкивались с Dockblock-аннотациями, если вы используете такие инструменты
T> генерации документации, как [phpDocumentor](http://www.phpdoc.org/) или [Doxygen](http://www.stack.nl/~dimitri/doxygen/).
T> В этих инструментах аннотации выполняют ту же функцию: описывают PHP-класс, а также его свойства
T> и методы. Затем инструмент проходит по коду и автоматически составляет HTML-документацию, полностью
T> основанную на анализе кода и аннотаций.

Ниже, в качестве примера мы приведем базовый пример класса сущности Doctrine. Как видите, класс и его
свойства помечены аннотациями Dockblock с помощью специальных *тегов* (тег начинается с символа '@').

{line-numbers=on,lang=php}
~~~
<?php
namespace Application\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity
 * @ORM\Table(name="post")
 */
class Post 
{
    /**
     * @ORM\Id
     * @ORM\GeneratedValue
     * @ORM\Column(name="id")   
     */
    protected $id;

    /** 
     * @ORM\Column(name="title")  
     */
    protected $title;

    /** 
     * @ORM\Column(name="content")  
     */
    protected $content;

    /** 
     * @ORM\Column(name="status")  
     */
    protected $status;

    /**
     * @ORM\Column(name="date_created")  
     */
    protected $dateCreated;   
}
~~~

Рассмотрим фрагмент кода выше:

В строке 2 мы объявили пространство имен `Application\Entity`, где "живут" классы сущностей
для модуля *Application*.

В строке 4, как вы можете заметить, мы используем класс `Doctrine\ORM\Mapping` и его
псевдоним `ORM` для аннотаций Doctrine [^annotation_namespaces].

[^annotation_namespaces]: Предоставляемые Doctrine теги аннотаций реализованы как классы, содержащиеся 
                               внутри пространства имен `Doctrine/ORM/Mapping`. Это сделано для того, 
						       чтобы избежать конфликтов имен аннотаций (например, в случае, когда 
						       какой-то другой компонент имет аннотацию с именем `Entity` или `Table`, 
							   возникнет конфликт имен).

В строках 6-9 находится аннотация DocBlock для класса `Post`. Каждый тег аннотации начинается с
символа '@", имеет имя и (опционально) параметры, заключенные в круглые скобки.
							   
Предоставляемые Doctrine теги, используемые в аннотациях могут быть двух типов: на уровне класса и
на уровне свойства. Во фрагменте кода выше мы используем следующие теги на уровне класса (описывающие
весь класс сущности):

  * тег `@ORM\Entity` (строка 7), объявляет, что этот класс является сущностью ORM Doctrine;
  
  * тег `@ORM\Table(name="post")` (строка 8) сообщает Doctrine ORM, что этому классу сущности
    поставлена в соответствие таблица БД `post`.

Свойства сущности описываются с помощью следующих тегов на уровне свойства:

  * `@ORM\Id` указывает, что это свойство является уникальным идентификатором сущности (строка 13);
  
  * `@ORM\GeneratedValue` используется для того, чтобы сообщить ORM Doctrine, что это свойство использует
     некоторую автосгенерированную последовательность для своей инициализации (строка 14). В MySQL это, 
	 как правило, означает, что соответствующий столбец таблицы использует инициализатор `AUTO_INCREMENT`.  
  
  * `@ORM\Column(name="<column_name>")` используется для того, чтобы сообщить ORM Doctrine, с каким столбцом
    таблицы данному свойству необходимо установить соответствие (строки 15, 20, 25, 30, 35).
	
T> Полный список предоставляемых Doctrine тегов, используемых в аннотациях, можно найти по следующей
T> [ссылке](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/annotations-reference.html).	

## Создание сущностей
  
Для модуля *Application* сущности (по общепринятому стандарту) хранятся в каталоге *Entity*
под корневым каталогом модуля. Классы сущностей содержатся в пространстве имен `Application\Entity`.
  
### Добавление сущности Post

Начнем с создания сущности `Post`. Создайте файл *Post.php* под каталогом *Entity*.
(Если вы еще не создали каталог *Entity*, самое время это сделать.)
Поместите в этот файл следующий код:

{line-numbers=on,lang=php}
~~~
<?php
namespace Application\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * Этот класс представляет собой пост в блоге.
 * @ORM\Entity
 * @ORM\Table(name="post")
 */
class Post 
{
    // Константы статуса поста.
    const STATUS_DRAFT       = 1; // Черновик.
    const STATUS_PUBLISHED   = 2; // Опубликованный пост.

    /**
     * @ORM\Id
     * @ORM\GeneratedValue
     * @ORM\Column(name="id")   
     */
    protected $id;

    /** 
     * @ORM\Column(name="title")  
     */
    protected $title;

    /** 
     * @ORM\Column(name="content")  
     */
    protected $content;

    /** 
     * @ORM\Column(name="status")  
     */
    protected $status;

    /**
     * @ORM\Column(name="date_created")  
     */
    protected $dateCreated;
  
    // Возвращает ID данного поста.
    public function getId() 
    {
        return $this->id;
    }

    // Задает ID данного поста.
    public function setId($id) 
    {
        $this->id = $id;
    }

    // Возвращает заголовок.
    public function getTitle() 
    {
        return $this->title;
    }

    // Задает заголовок.
    public function setTitle($title) 
    {
        $this->title = $title;
    }

    // Возвращает статус.
    public function getStatus() 
    {
        return $this->status;
    }

    // Устанавливает статус.
    public function setStatus($status) 
    {
        $this->status = $status;
    }
    
    // Возвращает содержимое поста.
    public function getContent() 
    {
        return $this->content; 
    }
    
    // Задает содержимое поста.
    public function setContent($content) 
    {
        $this->content = $content;
    }
    
    // Возвращает дату создания данного поста.
    public function getDateCreated() 
    {
        return $this->dateCreated;
    }
    
    // Задает дату создания данного поста.
    public function setDateCreated($dateCreated) 
    {
        $this->dateCreated = $dateCreated;
    }
}
~~~

В этом фрагменте кода находятся:

  * Константы статуса (строки 14 и 15). Они удобным образом представляют возможные значения,
    которые может получить свойство `$status` (1 для черновика (draft), 2 для опубликованного поста (published)).  

  * Protected-свойства класса сущности (`$title`, `$content`, `$dateCreated` и т.д.). Это данные,
    которые содержит типичный пост в блоге (свойства и их краткое описание см. в таблице 12.2 ниже).
  	
T> Обратите внимание, что для свойств используется (по общепринятому стандарту) "верблюжий" (camel-case) регистр 
   (например, `$dateCreated`), в то время как для столбцов БД используются "канонизированные" имена 
   (в нижнем регистре и с нижними подчеркиваниями, разделяющими слова, например, `date_created`).
	
{title="Таблица 12.2. Свойства сущности Post"}
|--------------|----------------------|--------------------------------------------------|
| *Свойства*   | *Сопоставляемый столбец* | *Описание*                                   |
|--------------|----------------------|--------------------------------------------------|
| `$id`        | `id`                 | Уникальный идентификатор данного поста.          |
|--------------|----------------------|--------------------------------------------------|
| `$title`     | `title`              | Заголовок данного поста.                         |
|--------------|----------------------|--------------------------------------------------|
| `$content`   | `content`            | Содержимое данного поста.                        |
|--------------|----------------------|--------------------------------------------------|
| `$status`    | `status`             | Статус (черновик/опубликован) данного поста.     |
|--------------|----------------------|--------------------------------------------------|
| `$dateCreated`| `date_created`      | Дата создания данного поста.                     |
|--------------|----------------------|--------------------------------------------------|
	
  * Класс сущности и его свойства, помеченные аннотациями DocBlock, читаются ORM Doctrine
    во время выполнения. Тем самым, ORM знает, каким образом устанавливать соответствие
	между этой сущностью с ее свойствами и таблицей базы данных с ее столбцами.
	
  * Класс сущности имеет геттеры и сеттеры (строки 45-102) для обращения к protected-свойствам 
    и их изменения (методы и их краткое описание см. в таблице 12.3).

{title="Таблица 12.3. Геттеры и сеттеры сущности Post"}
|------------------------------------|--------------------------------------------------|
| *Метод*                            | *Описание*                                       |
|------------------------------------|--------------------------------------------------|
| `getId()`              | Возвращает ID данного поста.                                   |
|------------------------------------|--------------------------------------------------|
| `setId($id)`           | Задает ID данного поста.                                       |
|------------------------------------|--------------------------------------------------|
| `getTitle()`           | Возвращает заголовок.                                          |
|------------------------------------|--------------------------------------------------| 
| `setTitle($title)`     | Задает заголовок.                                              |
|------------------------------------|--------------------------------------------------|  
| `getStatus()`          | Возвращает статус (черновик/опубликован).                      |
|------------------------------------|--------------------------------------------------|
| `setStatus($status)`   | Устанавливает статус.                                          |
|------------------------------------|--------------------------------------------------|
| `getContent()`         | Возвращает содержимое поста.                                   |
|------------------------------------|--------------------------------------------------|
| `setContent($content)` | Задает содержимое поста.                                       |
|------------------------------------|--------------------------------------------------|  
| `getDateCreated()`     | Возвращает дату создания данного поста.                        |
|------------------------------------|--------------------------------------------------|  
| `setDateCreated()`     | Задает дату создания данного поста.                            |  
|------------------------------------|--------------------------------------------------|
	
T> Обратите внимание на то, что мы не помечаем методы класса сущности аннотациями Doctrine. В этом
   просто нет необходимости. Однако, если хотите, вы можете помечать методы обычными комментариями
   и аннотациями Docblock не из Doctrine.

### Добавление сущностей Comment и Tag

Аналогично сущности `Post`, далее мы создаем классы сущностей Comment` и `Tag` в каталоге
*Entity*. Для этого сперва создайте файл *Comment.php* и поместите в него следующий код:

{line-numbers=on,lang=php}
~~~
<?php
namespace Application\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * Этот класс представляет собой комментарий, относящийся к посту блога.
 * @ORM\Entity
 * @ORM\Table(name="comment")
 */
class Comment 
{
    /**
     * @ORM\Id
     * @ORM\Column(name="id")
     * @ORM\GeneratedValue
     */
    protected $id;

    /** 
     * @ORM\Column(name="content")  
     */
    protected $content;

    /** 
     * @ORM\Column(name="author")  
     */
    protected $author;
    
    /** 
     * @ORM\Column(name="date_created")  
     */
    protected $dateCreated;

    // Возвращает ID данного комментария.
    public function getId() 
    {
        return $this->id;
    }

    // Задает ID данного комментария.
    public function setId($id) 
    {
        $this->id = $id;
    } 
    
    // Возвращает текст комментария.
    public function getContent() 
    {
        return $this->content;
    }

    // Устанавливает статус.
    public function setContent($content) 
    {
        $this->content = $content;
    }
    
    // Возвращает имя автора.
    public function getAuthor() 
    {
        return $this->author;
    }

    // Задает имя автора.
    public function setAuthor($author) 
    {
        $this->author = $author;
    }

    // Возвращает дату создания этого комментария.
    public function getDateCreated() 
    {
        return $this->dateCreated;
    }
    
    // Задает дату создания этого комментария.
    public function setDateCreated($dateCreated) 
    {
        $this->dateCreated = $dateCreated;
    }
}
~~~  
   
Теперь создайте файл *Tag.php* и поместите в него следующий код:   

{line-numbers=on,lang=php}
~~~
<?php
namespace Application\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * Этот класс представляет собой тег.
 * @ORM\Entity
 * @ORM\Table(name="tag")
 */
class Tag 
{
    /**
     * @ORM\Id
     * @ORM\GeneratedValue
     * @ORM\Column(name="id")
     */
    protected $id;

    /** 
     * @ORM\Column(name="name") 
     */
    protected $name;

    // Возвращает ID данного тега.
    public function getId() 
    {
        return $this->id;
    }

    // Задает ID данного тега.
    public function setId($id) 
    {
        $this->id = $id;
    }

    // Возвращает имя.
    public function getName() 
    {
        return $this->name;
    }

    // Задает имя.
    public function setName($name) 
    {
        $this->name = $name;
    }
}
~~~

Так как сущности `Comment` и `Tag` аналогичны сущности `Post`, мы не будем разбирать фрагменты кода выше.


T> Заметьте, мы не создаем сущность для вспомогательной таблицы `post_tag`. Эта таблица будет косвенно
   использоваться далее в этой главе при определении отношений между сущностями.

### Определение отношений между сущностями

Теперь используем аннотации, чтобы определить отношения между сущностями. Если помните,
между нашими сущностями существуют два отношения:

  * отношение «один-ко-многим» между сущностями `Post` и `Comment`;
  * и отношение «многие-ко-многим» между сущностями `Post` и `Tag`. 

Для задания отношения между двумя сущностями в Doctrine, добавьте private-свойство вместе
с аннотацией Docblock.
 
T> Детальную информацию об отношениях между сущностями в Doctrine можно прочесть на
   [этой странице](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/association-mapping.html)
   документации Doctrine.

#### «Один-ко-многим» и «многие-к-одному»
   
Первым делом, давайте определим отношение «один-ко-многим» между сущностями `Post` и `Comment`. Внесите
следующие изменения в файл *Post.php*:

{line-numbers=on,lang=php}
~~~
<?php
// ...
use Doctrine\Common\Collections\ArrayCollection;
use Application\Entity\Comment;

/**
 * Этот класс представляет собой пост в блоге.
 * @ORM\Entity
 * @ORM\Table(name="post")
 */
class Post 
{
    // ...  
  
    /**
     * @ORM\OneToMany(targetEntity="\Application\Entity\Comment", mappedBy="post")
     * @ORM\JoinColumn(name="id", referencedColumnName="post_id")
     */
    protected $comments;
    
    /**
     * Конструктор.
     */
    public function __construct() 
    {
      $this->comments = new ArrayCollection();               
    }
    
    /**
     * Возвращает комментарии для этого поста.
     * @return array
     */
    public function getComments() 
    {
        return $this->comments;
    }
    
    /**
     * Добавляет новый комментарий к этому посту.
     * @param $comment
     */
    public function addComment($comment) 
    {
        $this->comments[] = $comment;
    }
}
~~~

Как видите из фрагмента выше, мы добавили свойство `$comments` (строка 19). Это
свойство будет *коллекцией* комментариев, относящихся к определенному посту.

Мы инициализируем свойство `$comments` в конструкторе класса (строки 24-27),
создав новый экземпляр класса `Doctrine\Common\Collections\ArrayCollection`.

T> `ArrayCollection` в Doctrine - это массив объектов, похожий на обычный `массив` PHP,
T> но с дополнительными особенностями, необходимыми Doctrine. Он реализован в компоненте *Doctrine\Common*.

В строках 15-18 мы добавляем аннотации Doctrine к свойству `$comments`, тем самым сообщая Doctrine, как
получать все комментарии к посту:

  * тег `@ORM\OneToMany` определяет отношение «один-ко-многим» между сущностями `Post` и `Comment`.
    the (target) `Comment` entity.
  * тег `@ORM\JoinColumn` указывает, какой столбец использовать для присоединения к таблицам, 
    связанным с сущностями.
  
Метод `getComments()` (строки 33-36) позволяет получить все комментарии, связанные с постом.

Помимо этого, мы добавили метод `addComment()` (строки 42-45) для добавления нового комментария
к посту. Как видите, мы используем оператор `[]`, точно так же, как и с обычным PHP-массивом.
  
Затем мы определяем другую часть этого отношения, изменяя сущность `Comment` следующим образом:
  
{line-numbers=off,lang=php}
~~~
<?php
// ...
use Doctrine\Common\Collections\ArrayCollection;

// ...
class Comment 
{
    /**
     * @ORM\ManyToOne(targetEntity="\Application\Entity\Post", inversedBy="comments")
     * @ORM\JoinColumn(name="post_id", referencedColumnName="id")
     */
    protected $post;
     
    /*
     * Возвращает связанный пост.
     * @return \Application\Entity\Post
     */
    public function getPost() 
    {
        return $this->post;
    }
    
    /**
     * Задает связанный пост.
     * @param \Application\Entity\Post $post
     */
    public function setPost($post) 
    {
        $this->post = $post;
        $post->addComment($this);
    }
}
~~~

В этом фрагменте мы добавили private-свойство `$post` к классу сущности. Это не коллекция, а один
экземпляр класса `Post`, так как один комментарий всегда принадлежит одному посту.
Теги аннотаций `@ORM\ManyToOne` и `@ORM\JoinColumn` аналогичны тем, что мы рассмотрели выше.

#### «Многие-ко-многим»

Теперь давайте определим отношение между сущностями `Post` и `Tag`. Для этого отношения мы косвенно
используем вспомогательную таблицу `post_tag`.

Измените сущность `Post` следующим образом:

{line-numbers=off,lang=php}
~~~
<?php
//...
use Application\Entity\Tag;

//...
class Post 
{
    //...
    
    /**
     * @ORM\ManyToMany(targetEntity="\Application\Entity\Tag", inversedBy="posts")
     * @ORM\JoinTable(name="post_tag",
     *      joinColumns={@ORM\JoinColumn(name="post_id", referencedColumnName="id")},
     *      inverseJoinColumns={@ORM\JoinColumn(name="tag_id", referencedColumnName="id")}
     *      )
     */
    protected $tags;
    
    // Конструктор.
    public function __construct() 
    { 
        //...  
        $this->tags = new ArrayCollection();        
    }

    // Возвращает теги для данного поста.
    public function getTags() 
    {
        return $this->tags;
    }      
    
    // Добавляет новый тег к данному посту.
    public function addTag($tag) 
    {
        $this->tags[] = $tag;        
    }
    
    // Удаляет связь между этим постом и заданным тегом.
    public function removeTagAssociation($tag) 
    {
        $this->tags->removeElement($tag);
    }
}
~~~

В коде выше мы делаем следующее:

  * добавляем private-свойство `$tags`;
  * помечаем свойство `$tags` аннотациями Docblock с помощью тегов аннотаций `@ORM\ManyToMany` и `@ORM\JoinTable`;
  * инициализируем свойство в конструкторе;
  * добавляем три метода, позволяющие получить/изменить значение свойства: `getTags()`, `addTag()` и `removeTagAssociation()`.

После этого измените сущность `Tag` таким образом:

{line-numbers=off,lang=php}
~~~
<?php
//...
use Doctrine\Common\Collections\ArrayCollection;

class Tag 
{
    // ...
  
    /**
     * @ORM\ManyToMany(targetEntity="\Application\Entity\Post", mappedBy="tags")
     */
    protected $posts;
    
    // Конструктор.
    public function __construct() 
    {        
        $this->posts = new ArrayCollection();        
    }
  
    // Возвращает посты, связанные с данным тегом.
    public function getPosts() 
    {
        return $this->posts;
    }
    
    // Добавляет пост в коллекцию постов, связанных с этим тегом.
    public function addPost($post) 
    {
        $this->posts[] = $post;        
    } 
}
~~~ 
 
В этом фрагменте мы аналогичным образом определяем другую часть отношения, а также геттер и сеттер для
извлечения коллекции постов, связанных с тегом, и добавления постов, связанных с заданным тегом.
 
### Указание местонахождений сущностей

Чтобы сообщить Doctrine, где найти сущности для модуля *Application* (или другого вашего модуля),
добавьте следующий код в файл *module.config.php*:

{line-numbers=on,lang=php}
~~~
<?php
namespace Application;

use Doctrine\ORM\Mapping\Driver\AnnotationDriver;

return [
  // ...
  'doctrine' => [
        'driver' => [
            __NAMESPACE__ . '_driver' => [
                'class' => AnnotationDriver::class,
                'cache' => 'array',
                'paths' => [__DIR__ . '/../src/Entity']
            ],
            'orm_default' => [
                'drivers' => [
                    __NAMESPACE__ . '\Entity' => __NAMESPACE__ . '_driver'
                ]
            ]
        ]
    ]  
];
~~~

В строке 2 данного фрагмента мы указываем пространство имен `Application`. Это должно
быть имя текущего модуля.

T> Обратите внимание на то, что обычно мы не указываем пространство имен в файлах конфигурации, но 
   в данном случае удобно это сделать. После того, как мы определили пространство имен, мы можем
   использовать плейсхолдер `__NAMESPACE__`.

В строке 8 находится ключ `doctrine`, и под ним подключ `driver`.
В строке 13 мы сообщаем ORM Doctrine, что наши сущности хранятся 
в каталоге *Entity* под корневым каталогом модуля *src*.
   
## О менеджере сущностей

*Менеджер сущностей* - это основная точка доступа к функциональности ORM.

I> `EntityManager` - это класс Doctrine, который "живет" в пространстве имен `Doctrine\ORM` и 
I> используется для извлечения сущностей из их репозиториев с помощью критериев поиска, а также 
I> для их сохранения в базу данных. 

`EntityManager` зарегистрирован в качестве сервиса в менеджере сервисов Zend Framework 3.
Он извлекается из менеджера сервисов в классе фабрики следующим образом (если вам нужно
другое соединение, просто замените `orm_default` именем необходимого соединения):

{line-numbers=off, lang=php}
~~~
// Получаем менеджер сущностей Doctrine
$entityManager = $container->get('doctrine.entitymanager.orm_default');   
~~~

Наиболее часто используемые методы класса `EntityManager` перечислены в таблице 12.4 ниже.

{title="Таблица 12.4. Методы EntityManager"}
|------------------------------------|--------------------------------------------------|
| *Метод*                            | *Описание*                                       |
|------------------------------------|--------------------------------------------------|
| `persist($entity)`                 | Помещает новую сущность в менеджер сущностей (делает ее управляемой). |
|------------------------------------|--------------------------------------------------|
| `remove($entity)`                  | Удаляет сущность из базы данных.                 |
|------------------------------------|--------------------------------------------------|
| `flush()`                          | Сбрасывает все изменения объектов в очереди в базу. |
|------------------------------------|--------------------------------------------------|
| `createQuery($dql)`                | Создает новый объект Query.                      |
|------------------------------------|--------------------------------------------------|
| `getRepository($entityName)`       | Получает репозиторий класса сущности.            |
|------------------------------------|--------------------------------------------------|

Давайте рассмотрим методы из таблицы 12.4.

Чтобы добавить недавно созданную сущность в менеджер сущностей (чтобы сделать ее "управляемой"),
используйте метод менеджера сущностей `persist()`.
Чтобы удалить сущность из базы данных, воспользуйтесь методом `remove()`.

Когда вы вызываете методы `persist()` или `remove()`, `EntityManager` запоминает ваши изменения
в памяти, но не применяет их к базе данных автоматически (из соображений производительности).
Чтобы применить все изменения к БД разом, используйте метод `flush()`.

Пример кода ниже, показывает, как создать экземпляр сущности `Post` и сохранить его в базе данных:

{line-numbers=off, lang=php}
~~~
// Создаем новую сущность Post.
$post = new Post();
$post->setTitle('Top 10+ Books about Zend Framework 3');
$post->setContent('Post body goes here');
$post->setStatus(Post::STATUS_PUBLISHED);
$currentDate = date('Y-m-d H:i:s');
$post->setDateCreated($currentDate);        

// Добавляем сущность в менеджер сущностей.
$entityManager->persist($post);

// Применяем изменения к БД.
$entityManager->flush();
~~~

Метод менеджера сущностей `createQuery()` предназначен для создания запроса из DQL-строки. Он возвращает
объект `Query`. Затем вы можете выполнить запрос и получить результаты (массив сущностей, соответствующих
условиям поиска).

Метод `getRepository()` предназначен для получения репозитория по имени класса сущности. Ниже вы можете
увидеть пример, где мы получаем репозиторий для нашей сущности `Post`:

{line-numbers=off, lang=php}
~~~
$repository = $entityManager->getRepository(Post::class);
~~~

### Репозитории сущностей

Теоретически, у каждого класса сущности есть свой репозиторий. Репозиторий предоставляет методы
для извлечения сущностей из базы данных. Репозиторий можно считать коллекцией всех доступных
сущностей определенного класса. Например, существуют репозитории для созданных нами сущностей
`Post`, `Comment`, и `Tag`.

Для того, чтобы загрузить данные из БД, нужно извлечь сущность из ее репозитория. Когда вы
запрашиваете у репозитория сущность, он загружает данные из таблицы, сопоставляемой с этой
сущностью, и присваивает данные полям сущности.

I> Класс `Doctrine\ORM\EntityRepository` реализует репозиторий по умолчанию. При необходимости,
I> расширив `EntityRepository`, вы можете создать свой собственный репозиторий для определенного 
I> класса сущности. Позже мы покажем, как это сделать.

Наиболее часто используемые методы класса `EntityRepository` перечислены в таблице 12.5.

{title="Таблица 12.5. Методы EntityRepository"}
|------------------------------------|--------------------------------------------------|
| *Метод*                            | *Описание*                                       |
|------------------------------------|--------------------------------------------------|
| `findAll()`                        | Находит все сущности в репозитории.              |
|------------------------------------|--------------------------------------------------|
| `find($id)`                        | Находит сущность по ее идентификатору.           |
|------------------------------------|--------------------------------------------------|
| `findBy($criteria, $orderBy, $limit, $offset)` | Находит сущности по набору критериев.|
|------------------------------------|--------------------------------------------------|
| `findOneBy($criteria, $orderBy)`    | Находит одну сущность по набору критериев.      |
|------------------------------------|--------------------------------------------------|
| `createQueryBuilder($alias)`       | Создает новый экземпляр QueryBuilder, предзаполненный для этого имени сущности. |
|------------------------------------|--------------------------------------------------|

Метод `findAll()` получает все сущности из репозитория. Простой пример его использования показан ниже:

{line-numbers=off, lang=php}
~~~
// Находит все посты в репозитории.
$posts = $entityManager->getRepository(Post::class)->findAll();
~~~

Метод `find()` - самый простой метод для поиска сущности. Он извлекает сущность
по ее ID (первичному ключу).

В примере ниже мы выбираем пост с ID = 1.

{line-numbers=off, lang=php}
~~~
// Находим пост по первичному ключу (ID).
$post = $entityManager->getRepository(Post::class)->find(1);
~~~

`findBy()` принимает критерии поиска (и, опционально, порядок сортировки и границы) и
возвращает коллекцию сущностей, соответствующих критериям. Метод `findOneBy()` очень похож
на `findBy()`, однако он возвращает первую соответствующую критериям сущность.

В следующем примере кода мы используем метод `findBy()` для выбора 50 последних опубликованных
постов:

In the code example below, we use the `findBy()` method for selecting 50 most recent published posts:

{line-numbers=off, lang=php}
~~~
// Находим 50 последних опубликованных постов
$posts = $entityManager->getRepository(Post::class)->findBy(
           ['status'=>Post::STATUS_PUBLISHED], 
           ['dateCreated'=>'DESC'], 50);
~~~

Для удобства, класс `EntityRepository` также предоставляет магические методы, позволяющие запрашивать сущности
по имени атрибута с помощью методов `findByX` and `findOneByX`, следующим способом (просто замените плейсхолдер X
именем атрибута):

{line-numbers=off, lang=php}
~~~
// Запрашивает один пост по его атрибуту ID
$post = $entityManager->getRepository(Post::class)->findOneById(1);

// Запрашивает посты по атрибуту статуса
$posts = $entityManager->getRepository(Post::class)
        ->findByStatus(Post::STATUS_PUBLISHED);
~~~

И наконец, наиболее сложный метод поиска - метод `createQueryBuilder()`. Он позволяет создавать
сложные DQL-запросы.

Если стандартных методов поиска недостаточно (или у вас сложные критерии поиска и DQL-запросы),
вы можете создать свой собственный репозиторий, расширив стандартный класс `EntityRepository` и
инкапсулировав в него алгоритм поиска. Мы покажем, как это сделать, позже, при реализации 
облака тегов для нашего приложения *Blog*.

## Добавление главной страницы блога

Чтобы показать, как использовать класс `EntityManager`, мы создадим главную страницу для
веб-приложения *Blog*. Эта страница будет выводить список постов, отсортированных по дате
в порядке убывания.

Для этого добавим конструктор и метод `indexAction()` в класс контроллера
`IndexController` следующим образом:

{line-numbers=on,lang=php}
~~~
<?php
namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;
use Application\Entity\Post;

class IndexController extends AbstractActionController 
{
    /**
     * Менеджер сущностей.
     * @var Doctrine\ORM\EntityManager
     */
    private $entityManager;
  
    // Метод конструктора, используемый для внедрения зависимостей в контроллер.
    public function __construct($entityManager) 
    {
        $this->entityManager = $entityManager;
    }
  
    // Действие по умолчанию "index". Оно отображает страницу 
    // Posts, содержащую последние посты блога.
    public function indexAction() 
    {
        // Получаем недавние посты.
        $posts = $this->entityManager->getRepository(Post::class)
                     ->findBy(['status'=>Post::STATUS_PUBLISHED], 
                              ['dateCreated'=>'DESC']);
        
        // Визуализируем шаблон представления.
        return new ViewModel([
            'posts' => $posts
        ]);
    }
}
~~~

В приведенном выше фрагменте мы сперва добавляем метод конструктора `__construct()`, который используется
для внедрения менеджера сущностей Doctrine в контроллер (строки 16-19).

Внутри метода `indexAction()` мы получаем репозиторий сущностей `Post` методом менеджера 
сущностей `getRepository()` (строка 26). С помощью метода `findBy()`, предоставляемого репозиторием,
мы выбираем опубликованные посты, отсортированные по дате в порядке убывания. Далее, в строке 31
мы передаем выбранные посты представлению для визуализации.

Теперь создадим фабрику для `IndexController`. Для этого добавьте файл *IndexControllerFactory.php*
в каталог *Controller/Factory* под корневым каталогом модуля. Поместите следующее содержимое в этот
файл:

{line-numbers=off,lang=php}
~~~
<?php
namespace Application\Controller\Factory;

use Interop\Container\ContainerInterface;
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Controller\IndexController;

/**
 * Это фабрика для IndexController. Ее целью является инстанцирование
 * контроллера.
 */
class IndexControllerFactory implements FactoryInterface
{
    public function __invoke(ContainerInterface $container, 
                     $requestedName, array $options = null)
    {
        $entityManager = $container->get('doctrine.entitymanager.orm_default');
        
        // Инстанцируем контроллер и внедряем зависимости.
        return new IndexController($entityManager);
    }
}
~~~

В фрагменте кода выше мы инстанцировали менеджер сущностей Doctrine и внедрили его в контроллер.

Не забудьте зарегистрировать фабрику контроллера в файле `module.config.php`. Для этого добавьте следующий код:

{line-numbers=off,lang=php}
~~~
//...
return [
    //...
    'controllers' => [
        //...
        'factories' => [
            Controller\IndexController::class => 
                            Controller\Factory\IndexControllerFactory::class,    
        ],
    ],
    //...
];
~~~

Далее, добавьте следующее содержимое в файл шаблона представления *index.phtml* в каталоге *application/index*
под каталогом модуля *view*:

{line-numbers=off,lang=php}
~~~
<h1>Posts</h1>

<?php foreach($posts as $post): ?>

<h3>
  <a href="#">
    <?= $this->escapeHtml($post->getTitle()); ?>
  </a>    
</h3>
        
<p>    
   <?= $this->escapeHtml($post->getContent()); ?>
</p>

<?php endforeach; ?>
~~~   

В этом шаблоне представления мы проходит по выбранным постам по очереди и визуализируем
заголовок и содержимое каждого. Настолько просто!

Теперь, если вы откроете веб-приложение *Blog* в своем браузере, вы должны будете увидеть
такую страницу, содержащую список постов (см. рисунок 12.6 ниже).
   
![Рисунок 12.6. Список постов](../en/images/doctrine/blog_posts.png)   

## Добавление нового поста

В этой главе мы создадим страницу *Add New Post*, которая позволит добавлять новые посты в блог.
Для этого нам понадобится следующее:

  * модель формы `PostForm`, которая будет использоваться для задания и валидации заголовка поста, содержимого, статуса и тегов;
  * модель сервиса `PostManager`, которая будет содержать бизнес-логику для сохранения нового поста в БД;
  * контроллер `PostController` и его метод действия `PostController::addAction()`, которые будут использоваться
    для получения данных формы и вызова PostManager` для сохранения данных в БД;
  * и шаблон представления *add.phtml*, который будет визуализировать форму.

### Добавление PostForm

Сначала добавим форму `PostForm`, которая позволит вводить данные одного поста:
его заголовок, содержимое, список связанных с ним тегов, разделенных запятыми, и
статус (опубликован или черновик). Чтобы это сделать, создайте файл *PostForm.php*
в каталоге *Form* под корневым каталогом модуля. Поместите в этот файл следующий код:

{line-numbers=off,lang=php}
~~~
<?php

namespace Application\Form;

use Zend\Form\Form;
use Zend\InputFilter\InputFilter;
use Application\Entity\Post;

/**
 * Эта форма используется для сбора данных о посте.
 */
class PostForm extends Form
{
    /**
     * Конструктор.     
     */
    public function __construct()
    {
        // Определяем имя формы.
        parent::__construct('post-form');
     
        // Задает для этой формы метод POST.
        $this->setAttribute('method', 'post');
                
        $this->addElements();
        $this->addInputFilter();         
    }
    
    /**
     * Этот метод добавляет элементы к форме (поля ввода и кнопку отправки формы).
     */
    protected function addElements() 
    {
                
        // Добавляем поле "title"
        $this->add([           
            'type'  => 'text',
            'name' => 'title',
            'attributes' => [
                'id' => 'title'
            ],
            'options' => [
                'label' => 'Title',
            ],
        ]);
        
        // Добавляем поле "content"
        $this->add([
            'type'  => 'textarea',
            'name' => 'content',
            'attributes' => [                
                'id' => 'content'
            ],
            'options' => [
                'label' => 'Content',
            ],
        ]);
        
        // Добавляем поле "tags"
        $this->add([
            'type'  => 'text',
            'name' => 'tags',
            'attributes' => [                
                'id' => 'tags'
            ],
            'options' => [
                'label' => 'Tags',
            ],
        ]);
        
        // Добавляем поле "status"
        $this->add([
            'type'  => 'select',
            'name' => 'status',
            'attributes' => [                
                'id' => 'status'
            ],
            'options' => [
                'label' => 'Status',
                'value_options' => [
                    Post::STATUS_PUBLISHED => 'Published',
                    Post::STATUS_DRAFT => 'Draft',
                ]
            ],
        ]);
        
        // Добавляем кнопку отправки формы
        $this->add([
            'type'  => 'submit',
            'name' => 'submit',
            'attributes' => [                
                'value' => 'Create',
                'id' => 'submitbutton',
            ],
        ]);
    }
    
    /**
     * Этот метод создает фильтр входных данных (используется для фильтрации/валидации).
     */
    private function addInputFilter() 
    {
        
        $inputFilter = new InputFilter();        
        $this->setInputFilter($inputFilter);
        
        $inputFilter->add([
                'name'     => 'title',
                'required' => true,
                'filters'  => [
                    ['name' => 'StringTrim'],
                    ['name' => 'StripTags'],
                    ['name' => 'StripNewlines'],
                ],                
                'validators' => [
                    [
                        'name'    => 'StringLength',
                        'options' => [
                            'min' => 1,
                            'max' => 1024
                        ],
                    ],
                ],
            ]);
        
        $inputFilter->add([
                'name'     => 'content',
                'required' => true,
                'filters'  => [                    
                    ['name' => 'StripTags'],
                ],                
                'validators' => [
                    [
                        'name'    => 'StringLength',
                        'options' => [
                            'min' => 1,
                            'max' => 4096
                        ],
                    ],
                ],
            ]);   
        
        $inputFilter->add([
                'name'     => 'tags',
                'required' => true,
                'filters'  => [                    
                    ['name' => 'StringTrim'],
                    ['name' => 'StripTags'],
                    ['name' => 'StripNewlines'],
                ],                
                'validators' => [
                    [
                        'name'    => 'StringLength',
                        'options' => [
                            'min' => 1,
                            'max' => 1024
                        ],
                    ],
                ],
            ]);
    }
}
~~~

Как видите из этого фрагмента, класс `PostForm` определяет ZF3-форму с полями заголовка
содержимого, тегов и статуса. У него также есть кнопка *Submit*.

I> Так как мы уже детально рассмотрели  формы в предыдущих главах, мы не будем
I> разбирать представленный выше код.

### Добавление сервиса PostManager

Согласно паттерну DDD , мы размещаем бизнес-логику в моделях сервисов. В нашем примере *Blog*
мы создадим и зарегистрируем сервис *PostManager*. Этот сервис будет иметь public-метод 
`addNewPost()`, содержащий бизнес-логику добавления сущности `Post` в БД и ее связи с одной
или несколькими сущностями `Tag`.

I> Сервис `PostManager` будет содержать бизнес-логику примера *Blog*. Эта бизнес-логика
   включает в себя добавление нового поста в блог (но не ограничена этим).

Создайте файл *PostManager.php* в каталоге *Service* под корневым каталогом
модуля. Поместите в этот файл следующий фрагмент кода:

{line-numbers=on,lang=php}
~~~
<?php
namespace Application\Service;

use Application\Entity\Post;
use Application\Entity\Comment;
use Application\Entity\Tag;
use Zend\Filter\StaticFilter;

// Сервис The PostManager, отвечающий за дополнение новых постов.
class PostManager 
{
    /**
     * Doctrine entity manager.
     * @var Doctrine\ORM\EntityManager
     */
    private $entityManager;
  
    // Конструктор, используемый для внедрения зависимостей в сервис.
    public function __construct($entityManager)
    {
        $this->entityManager = $entityManager;
    }
    
    // Этот метод добавляет новый пост.
    public function addNewPost($data) 
    {
        // Создаем новую сущность Post.
        $post = new Post();
        $post->setTitle($data['title']);
        $post->setContent($data['content']);
        $post->setStatus($data['status']);
        $currentDate = date('Y-m-d H:i:s');
        $post->setDateCreated($currentDate);        
        
        // Добавляем сущность в менеджер сущностей.
        $this->entityManager->persist($post);
        
        // Добавляем теги к посту.
        $this->addTagsToPost($data['tags'], $post);
        
        // Применяем изменения к базе данных.
        $this->entityManager->flush();
    }
  
    // Добавляет/обновляет теги в заданном посте.
    private function addTagsToPost($tagsStr, $post) 
    {
        // Удаляем связи тегов (если таковые есть)
        $tags = $post->getTags();
        foreach ($tags as $tag) {            
            $post->removeTagAssociation($tag);
        }
        
        // Добавляем теги к посту
        $tags = explode(',', $tagsStr);
        foreach ($tags as $tagName) {
            
            $tagName = StaticFilter::execute($tagName, 'StringTrim');
            if (empty($tagName)) {
                continue; 
            }
            
            $tag = $this->entityManager->getRepository(Tag::class)
                      ->findOneByName($tagName);
            if ($tag == null)
                $tag = new Tag();
            $tag->setName($tagName);
            $tag->addPost($post);
            
            $this->entityManager->persist($tag);
            
            $post->addTag($tag);
        }
    }    
}
~~~

В строках 25-43 находится public-метод `addNewPost()`, принимающий в качестве аргумента переменную `$data` (эта
переменная должна содержать данные, введенные пользователем сайта в форму). Мы создаем новый экземпляр сущности 
`Post` и заполняем его свойства введенными пользователем данными. Затем мы используем метод `persist()` класса
`EntityManager` (строка 36), чтобы добавить только что созданную сущность в менеджер сущностей. Private-метод
`addTagsToPost()` вызывается (строка 39), чтобы добавить к посту один или несколько тегов, а метод `flush()` -
чтобы применить изменения к базе данных в одно действие.

Private-метод `addTagsToPost()` содержит алгоритмы для удаления старых связей между постом и тегами (строки 49-52),
разбора списка разделенных запятыми тегов (строка 55) и добавления новых тегов к посту (строки 56-73).

Далее, добавим фабрику для класса `PostManager`. Для этого добавьте файл *PostManagerFactory.php*
под каталог *Service/Factory* под корневым каталогом модуля и заполните его следующим содержимым:

{line-numbers=off,lang=php}
~~~
<?php
namespace Application\Service\Factory;

use Interop\Container\ContainerInterface;
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\PostManager;

/**
 * Это фабрика для PostManager. Ее целью является
 * инстанцирование сервиса.
 */
class PostManagerFactory implements FactoryInterface
{
    public function __invoke(ContainerInterface $container, 
                    $requestedName, array $options = null)
    {
        $entityManager = $container->get('doctrine.entitymanager.orm_default');
        
        // Инстанцируем сервис и внедряем зависимости.
        return new PostManager($entityManager);
    }
}
~~~

И наконец, мы регистрируем сервис `PostManager` изменив файл конфигурации *module.config.php* таким образом:

{line-numbers=off,lang=php}
~~~
<?php
//...
return [
    //...
    'service_manager' => [
        //...
        'factories' => [
            Service\PostManager::class => Service\Factory\PostManagerFactory::class,
        ],
    ],
    //...
];
~~~  
  
### Создание действия контроллера и шаблона представления  

Для управления постами (добавления, изменения, просмотра и удаления) мы создадим класс
контроллера `PostController`. Внутри этого класса мы создадим метод действия `addAction()`,
который позволит добавлять новый пост в блог (см. код ниже):

{line-numbers=on,lang=php}
~~~
class PostController extends AbstractActionController 
{
    /**
     * Менеджер сущностей.
     * @var Doctrine\ORM\EntityManager 
     */
    private $entityManager;
    
    /**
     * Менеджер постов.
     * @var Application\Service\PostManager 
     */
    private $postManager;
    
    /**
     * Конструктор, используемый для внедрения зависимостей в контроллер.
     */
    public function __construct($entityManager, $postManager) 
    {
        $this->entityManager = $entityManager;
        $this->postManager = $postManager;
    }

    /**
     * Это действие отображает страницу "New Post". Она содержит 
     * форму, позволяющую ввести заголовок поста, содержимое и теги.
     * Когда пользователь нажимает кнопку отправки формы, создается
     * новая сущность Post.
     */
    public function addAction() 
    {     
        // Создаем форму.
        $form = new PostForm();
        
        // Проверяем, является ли пост POST-запросом.
        if ($this->getRequest()->isPost()) {
            
            // Получаем POST-данные.
            $data = $this->params()->fromPost();
            
            // Заполняем форму данными.
            $form->setData($data);
            if ($form->isValid()) {
                                
                // Получаем валидированные данные формы.
                $data = $form->getData();
                
                // Используем менеджер постов для добавления нового поста в базу данных.                
                $this->postManager->addNewPost($data);
                
                // Перенаправляем пользователя на страницу "index".
                return $this->redirect()->toRoute('application');
            }
        }
        
        // Визуализируем шаблон представления.
        return new ViewModel([
            'form' => $form
        ]);
    }   
}
~~~

В строке 33 фрагмента выше мы создаем экземпляр формы `PostForm`.
В строке 36 мы проверяем, является ли запрос POST-запросом. Если это так, мы заполняем
форму входными данными и валидируем данные. Если данные действительны, мы вызываем метод
`addNewPost()` для сервиса `PostManager` (строка 49) и перенаправляем пользователя к 
списку постов.

Чтобы инстанцировать `PostController`, нам понадобится фабрика. Создайте фабрику контроллера, добавив
файл *PostControllerFactory.php* в каталог *Controller/Factory* под корневым каталогом модуля:

{line-numbers=off,lang=php}
~~~
<?php
namespace Application\Controller\Factory;

use Interop\Container\ContainerInterface;
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\PostManager;
use Application\Controller\PostController;

/**
 * Это фабрика для PostController. Ее целью является инстанцирование
 * контроллера.
 */
class PostControllerFactory implements FactoryInterface
{
    public function __invoke(ContainerInterface $container, 
                           $requestedName, array $options = null)
    {
        $entityManager = $container->get('doctrine.entitymanager.orm_default');
        $postManager = $container->get(PostManager::class);
        
        // Инстанцируем контроллер и внедряем зависимости
        return new PostController($entityManager, $postManager);
    }
}
~~~

Затем зарегистрируйте контроллер `PostController` в файле *module.config.php*:

{line-numbers=off,lang=php}
~~~
<?php
//...
return [
    //...
    'controllers' => [
        //...
        'factories' => [
            Controller\PostController::class => 
                           Controller\Factory\PostControllerFactory::class,
        ],
    ],
    //...
];
~~~ 

Далее, добавьте маршрут *posts* для созданного контроллера (измените *module.config.php*, как показано ниже):

{line-numbers=off,lang=php}
~~~
<?php
//...
return [
    //...
    'router' => [
        'routes' => [
            //...
            'posts' => [
                'type'    => Segment::class,
                'options' => [
                    'route'    => '/posts[/:action[/:id]]',
                    'constraints' => [
                        'action' => '[a-zA-Z][a-zA-Z0-9_-]*',
                        'id' => '[0-9]*'
                    ],
                    'defaults' => [
                        'controller'    => Controller\PostController::class,
                        'action'        => 'index',
                    ],
                ],
            ],
        ],
    ],
    //...
];
~~~

И наконец, добавим шаблон представления. Создайте файл *add.phtml* в каталоге *application/post* под
каталогом модуля *view* и поместите в него следующий код:

{line-numbers=off,lang=php}
~~~
<?php
$form = $this->form;
$form->get('title')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'Enter post title here'
    ]);
$form->get('content')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'Type content here',
    'rows'=>6
    ]);
$form->get('tags')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'comma, separated, list, of, tags'
    ]);
$form->get('status')->setAttributes([
    'class'=>'form-control'   
    ]);
$form->get('submit')->setAttributes(['class'=>'btn btn-primary']);
$form->prepare();

?>

<h1>Add New Post</h1>

<p>
    Please fill out the following form and click the <i>Create</i> button.
</p>

<div class="row">
    <div class="col-md-6">
        <?= $this->form()->openTag($form); ?>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('title')); ?>
            <?= $this->formElement($form->get('title')); ?>
            <?= $this->formElementErrors($form->get('title')); ?>                  
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('content')); ?>
            <?= $this->formElement($form->get('content')); ?>
            <?= $this->formElementErrors($form->get('content')); ?>                  
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('tags')); ?>
            <?= $this->formElement($form->get('tags')); ?>
            <?= $this->formElementErrors($form->get('tags')); ?>                  
            <p class="help-block">Separate tags with comma.</p>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('status')); ?>
            <?= $this->formElement($form->get('status')); ?>
            <?= $this->formElementErrors($form->get('status')); ?>                  
        </div>
        
        <?= $this->formElement($form->get('submit')); ?>
        
        <?= $this->form()->closeTag(); ?>
    </div>    
</div>   
~~~

Теперь, если вы откроете в браузере URL *http://localhost/posts/add*, вы должны будете
увидеть страницу добавления нового поста *Add New Post*, как показано ниже на рисунке 12.7:

![Рисунок 12.7. Страница Add New Post](../en/images/doctrine/add_new_post.png) 

Заполнив форму и нажав кнопку *Create*, вы сохраните новый пост в базе данных. Затем вы
сможете посмотреть созданный вами пост в списке постов на странице *Home*.

## Изменение существующего поста

В этом разделе мы реализуем страницу *Edit Post*, которая будет содержать форму, позволяющую
изменять данные существующего поста, отправлять новые данные на сервер и применять изменения
к базе данных. Посетитель сайта сможет перейти на эту страницу, набрав в адресной строке своего
браузера URL *http://localhost/posts/edit/&lt;id&gt;*, где *&lt;id&gt;* - уникальный идентификатор
поста.

Для реализации этой страницы нам надо сделать следующее:

  * создать форму, которая позволит вводить заголовок поста, содержимое и т.д. Для этой страницы
    мы с успехом можем повторно использовать форму `PostForm`, созданную ранее (мы просто переименуем
	надпись кнопки *Create* в *Save*).
  * добавить метод `updatePost()` к сервису `PostManager`. Этот метод будет находить пост 
    по его ID в базе данных и обновлять его данные;
  * добавить метод `convertTagsToString()` к сервису `PostManager`. Этот метод будет принимать
    сущность поста и возвращать строку, содержащую список разделенных запятыми тегов;
  * добавить метод действия `PostController::editAction()`, который будет принимать введенные
    пользователем данные, передавать их моделям и возвращать данные для визуализации;
  * и добавить файл шаблона представления *edit.phtml*, который будет визуализировать форму.

### Изменение PostManager  
  
Сперва добавим методы `updatePost()` и `convertTagsToString()` к модели сервиса `PostManager`
следующим образом:

{line-numbers=on,lang=php}
~~~
<?php
//...
class PostManager
{
    //...
	
    // Этот метод позволяет обновлять данные одного поста.
    public function updatePost($post, $data) 
    {
        $post->setTitle($data['title']);
        $post->setContent($data['content']);
        $post->setStatus($data['status']);
        
        // Добавляем теги к посту.
        $this->addTagsToPost($data['tags'], $post);
        
        // Применяем изменения к базе данных.
        $this->entityManager->flush();
    }
        
    // Преобразовывает теги заданного поста в разделенный запятыми список (строку).
    public function convertTagsToString($post) 
    {
        $tags = $post->getTags();
        $tagCount = count($tags);
        $tagsStr = '';
        $i = 0;
        foreach ($tags as $tag) {
            $i ++;
            $tagsStr .= $tag->getName();
            if ($i < $tagCount) 
                $tagsStr .= ', ';
        }
        
        return $tagsStr;
    }    
}
~~~
  
Метод `updatePost()` во фрагменте выше (строки 8-19) принимает уже имеющуюся сущность `Post`, новые заголовок,
содержимое, статус и список тегов. Затем этот метод обновляет свойства сущности и сохраняет
изменения в базе данных, используя метод `flush()`.

I> Обратите внимание, метод `updatePost()` не использует метод менеджера сущностей `persist()`,
   потому что в данном случае сущность не новая, а уже существующая.
  
Затем, в строках 22-36, находится метод `convertTagsToString()`, который принимает пост, проходит
по сущностям `Tag`, связанных с этим постом, а затем форматирует и возвращает список тегов, разделенных
запятыми.

### Добавление действия контроллера и шаблона представления
  
Далее, добавьте действие `editAction` к классу контроллера `PostController` как показано ниже:
  
{line-numbers=off,lang=php}
~~~
<?php
namespace Application\Controller;
//...
use Application\Form\PostForm;
use Application\Entity\Post;

class PostController extends AbstractActionController 
{
    // Это действие отображает страницу, позволяющую отредактировать пост.
    public function editAction() 
    {
        // Создаем форму.
        $form = new PostForm();
    
        // Получаем ID поста.    
        $postId = $this->params()->fromRoute('id', -1);
    
        // Находим существующий пост в базе данных.    
        $post = $this->entityManager->getRepository(Post::class)
                ->findOneById($postId);        
        if ($post == null) {
            $this->getResponse()->setStatusCode(404);
            return;                        
        } 
        
        // Проверяем, является ли пост POST-запросом.
        if ($this->getRequest()->isPost()) {
            
            // Получаем POST-данные.
            $data = $this->params()->fromPost();
            
            // Заполняем форму данными.
            $form->setData($data);
            if ($form->isValid()) {
                                
                // Получаем валидированные данные формы.
                $data = $form->getData();
                
                // Используем менеджер постов, чтобы добавить новый пост в базу данных.                
                $this->postManager->updatePost($post, $data);
                
                // Перенаправляем пользователя на страницу "admin".
                return $this->redirect()->toRoute('posts', ['action'=>'admin']);
            }
        } else {
            $data = [
               'title' => $post->getTitle(),
               'content' => $post->getContent(),
               'tags' => $this->postManager->convertTagsToString($post),
               'status' => $post->getStatus()
            ];
            
            $form->setData($data);
        }
        
        // Визуализируем шаблон представления.
        return new ViewModel([
            'form' => $form,
            'post' => $post
        ]);  
    }
}
~~~

В куске кода выше мы извлекаем ID поста с помощью метода `fromRoute()` плагина контроллера
`params()` Затем мы ищем пост с этим ID, используя метод `findOneBy()`, предоставляемый
репозиторием сущности.

После этого мы проверяем, является ли пост POST-запросом. Если это так, заполняем
форму POST-данными и валидируем ее. Затем мы используем метод `updatePost()` сервиса
`PostManager`.

Наконец, создайте файл *application/post/edit.phtml* под каталогом модуля *view*. Поместите
в него следующее содержимое:

{line-numbers=off,lang=php}
~~~
<?php
$form = $this->form;
$form->get('title')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'Enter post title here'
    ]);
$form->get('content')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'Type content here',
    'rows'=>6
    ]);
$form->get('tags')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'comma, separated, list, of, tags'
    ]);
$form->get('status')->setAttributes([
    'class'=>'form-control'   
    ]);
$form->get('submit')->setAttributes(['class'=>'btn btn-primary']);
$form->get('submit')->setValue('Save');
$form->prepare();

?>

<h1>Edit Post</h1>

<p>
    Please fill out the following form and click the *Save* button.
</p>

<div class="row">
    <div class="col-md-6">
        <?= $this->form()->openTag($form); ?>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('title')); ?>
            <?= $this->formElement($form->get('title')); ?>
            <?= $this->formElementErrors($form->get('title')); ?>                  
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('content')); ?>
            <?= $this->formElement($form->get('content')); ?>
            <?= $this->formElementErrors($form->get('content')); ?>                  
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('tags')); ?>
            <?= $this->formElement($form->get('tags')); ?>
            <?= $this->formElementErrors($form->get('tags')); ?>                  
            <p class="help-block">Separate tags with comma.</p>
        </div>

        <div class="form-group">
            <?= $this->formLabel($form->get('status')); ?>
            <?= $this->formElement($form->get('status')); ?>
            <?= $this->formElementErrors($form->get('status')); ?>                  
        </div>
        
        <?= $this->formElement($form->get('submit')); ?>
        
        <?= $this->form()->closeTag(); ?>
    </div>    
</div>   
~~~

Если вы теперь откроете в своем браузере URL *http://localhost/posts/edit/&lt;id&gt;*, вы должны
будете увидеть страницу *Edit Post*, которая позволяет редактировать имеющиеся посты (см. рисунок 12.8 ниже):

![Рисунок 12.8. Страница Edit Post](../en/images/doctrine/edit_post.png) 

Нажав кнопку *Save*, вы сохраните изменения в базе данных.

## Удаление поста

В этом разделе мы реализуем действие `deleteAction()` класса `PostController`. Оно позволит
удалять определенный пост по заданному ID. Это действие будет принимать ID в виде GET-переменной,
проверять, существует ли пост с таким ID, и, если существует, удалять пост, относящиеся к нему
комментарии и связи тегов. Посетитель сайта сможет вызвать действие, набрав в адресной строке
браузера URL: *http://localhost/posts/delete/&lt;id&gt;*, где *&lt;id&gt;* - уникальный
идентификатор поста. После этого, действие перенаправляет пользователя на страницу *Admin*.

### Изменение PostManager

Сперва добавим метод `removePost()` к сервису `PostManager`. Этот метод будет удалять пост и связанные
с ним комментарии. Кроме того, он будет удалять связи между постом и тегами.

{line-numbers=off,lang=php}
~~~
<?php
//...
class PostManager
{
    //...
    
    // Удаляет пост и все связанные с ним комментарии.
    public function removePost($post) 
    {
        // Удаляем связанные комментарии.
        $comments = $post->getComments();
        foreach ($comments as $comment) {
            $this->entityManager->remove($comment);
        }
        
        // Удаляем связи тегов (если таковые есть)
        $tags = $post->getTags();
        foreach ($tags as $tag) {
            $post->removeTagAssociation($tag);
        }
        
        $this->entityManager->remove($post);
        
        $this->entityManager->flush();
    }
}
~~~

В этом фрагменте мы сначала извлекаем все комментарии, связанные с постом, используя метод
`getComments()` сущности `Post`. Затем мы вызываем метод менеджера сущностей `remove()` и
передаем ему каждый комментарий, который хотим удалить.

Далее, мы получаем все связанные с постом теги, вызывая метод `getTags()`. Связь между постом
и тегом (но не сам тег!) удаляется с помощью метода `removeTagAssociation()` сущности `Post`
(код метода смотрите ниже).

Наконец, мы удаляем сам пост методом менеджера сущностей `remove()`, а затем применяем изменения к
базе данных с помощью метода `flush()`.

Далее представлен код метода `Post::removeTagAssociation()`:

{line-numbers=off,lang=php}
~~~
// Удаляет связь между этим постом и заданным тегом.
public function removeTagAssociation($tag) 
{
    $this->tags->removeElement($tag);
}
~~~

### Добавление действия контроллера

Метод `PostController::deleteAction()` извлекает ID поста, который нужно удалить и затем
проверяет, действителен ли этот ID. Если это так, он вызывает метод  PostManager::removePost()`,
чтобы удалить пост и применить изменения к базе данных. После этого он перенаправляет посетителя
сайта на страницу *Admin*.

{line-numbers=off,lang=php}
~~~
<?php

//..
class PostController extends AbstractActionController 
{
    // Это действие отображает страницу Delete Post.
    public function deleteAction()
    {
        $postId = $this->params()->fromRoute('id', -1);
        
        $post = $this->entityManager->getRepository(Post::class)
                ->findOneById($postId);        
        if ($post == null) {
            $this->getResponse()->setStatusCode(404);
            return;                        
        }        
        
        $this->postManager->removePost($post);
        
        // Перенаправляем пользователя на страницу "index".
        return $this->redirect()->toRoute('posts', ['action'=>'admin']);
    }
}
~~~

## Реализация просмотра поста

В этом разделе мы создадим действие контроллера и соответствующий шаблон представления, которые
позволят посетителям сайта просмотреть определенный пост, набрав в адресной строке браузера
URL *http://localhost/posts/view/&lt;id&gt;*, где *&lt;id&gt;* - уникальный идентификатор поста.

На этой странице также можно будет добавлять комментарии к посту, используя форму, находящуюся
в нижней части страницы. Пример того, чего мы хотим добиться, показан на рисунке 12.9 ниже:

![Рисунок 12.9. Страница View Post](../en/images/doctrine/view_post.png)

Итак, нам понадобится сделать следующее: 

  * создать форму, которая позволит вводить комментарий и имя его автора;
  * изменить `PostManager` и добавить необходимую бизнес-логику;
  * создать действие контроллера `PostController::viewAction()`;
  * и создать шаблон представления *view.phtml*.

### Добавление CommentForm

Первым делом мы реализуем форму `CommentForm`, которая позволит добавлять комментарий
к посту. Создайте файл *CommentForm.php* в каталоге *Form* под корневым каталогом
модуля. Поместите в него следующее содержимое:

{line-numbers=on,lang=php}
~~~
<?php
namespace Application\Form;

use Zend\Form\Form;
use Zend\InputFilter\InputFilter;

/**
 * Эта форма используется для сбора данных комментария.
 */
class CommentForm extends Form
{
    // Конструктор.     
    public function __construct()
    {
        // Определяем имя формы
        parent::__construct('comment-form');
     
        // Задаем POST-метод для этой формы
        $this->setAttribute('method', 'post');
                
        $this->addElements();
        $this->addInputFilter();         
    }
    
    // Этот метод добавляет элементы к форме (поля ввода и кнопку отправки формы).
    protected function addElements() 
    {
        // Добавляем поле "author"
        $this->add([     
            'type'  => 'text',
            'name' => 'author',
            'attributes' => [
                'id' => 'author'
            ],
            'options' => [
                'label' => 'Author',
            ],
        ]);
        
        // Добавляем поле "comment"
        $this->add([            
           'type'  => 'textarea',
            'name' => 'comment',
            'attributes' => [
                'id' => 'comment'
            ],
            'options' => [
                'label' => 'Comment',
            ],
        ]);
                
        // Добавляем кнопку отправки формы
        $this->add([
            'type'  => 'submit',
            'name' => 'submit',
            'attributes' => [                
                'value' => 'Save',
                'id' => 'submitbutton',
            ],
        ]);
    }
    
    // Этот метод создает фильтр входных данных (используется для фильтрации/валидации).
    private function addInputFilter() 
    {
        $inputFilter = new InputFilter();        
        $this->setInputFilter($inputFilter);
        
        $inputFilter->add([
                'name'     => 'author',
                'required' => true,
                'filters'  => [                    
                    ['name' => 'StringTrim'],
                ],                
                'validators' => [
                    [
                        'name'    => 'StringLength',
                        'options' => [
                            'min' => 1,
                            'max' => 128
                        ],
                    ],
                ],
            ]);
        
        $inputFilter->add([
                'name'     => 'comment',
                'required' => true,
                'filters'  => [                    
                    ['name' => 'StripTags'],
                ],                
                'validators' => [
                    [
                        'name'    => 'StringLength',
                        'options' => [
                            'min' => 1,
                            'max' => 4096
                        ],
                    ],
                ],
            ]);   
    }
}
~~~

Как видите из данного кода, форма `CommentForm` содержит поля автора и комментария и кнопку отправки формы.

I> Так как мы уже детально рассмотрели формы в предыдущих главах, мы не будем
I> разбирать представленный выше код.

### Изменение PostManager

В этот класс мы добавим два метода:

  * метод `getCommentCountStr()` будет форматировать строку количества комментариев для заданного
    поста (например, "No comments", "1 comment", "2 comments" и т.д.);
  * а метод `addCommentToPost()` будет использоваться для добавления нового комментария к посту.
	
{line-numbers=off,lang=php}
~~~
<?php
//...

/**
 * Сервис PostManager отвечает за дополнение новых постов.
 */
class PostManager
{
    //...    

    // Возвращает количество комментариев для заданного поста в виде должным образом отформатированной строки.
    public function getCommentCountStr($post)
    {
        $commentCount = count($post->getComments());
        if ($commentCount == 0)
            return 'No comments';
        else if ($commentCount == 1) 
            return '1 comment';
        else
            return $commentCount . ' comments';
    }


    // Этот метод добавляет новый комментарий к посту.
    public function addCommentToPost($post, $data) 
    {
        // Создаем новую сущность Comment.
        $comment = new Comment();
        $comment->setPost($post);
        $comment->setAuthor($data['author']);
        $comment->setContent($data['comment']);        
        $currentDate = date('Y-m-d H:i:s');
        $comment->setDateCreated($currentDate);

        // Добавляем сущность к менеджеру сущность.
        $this->entityManager->persist($comment);

        // Применяем изменения.
        $this->entityManager->flush();
    }
}
~~~

### Добавление действия контроллера и шаблона представления

Теперь добавьте метод `PostController::viewAction()` и поместите в него следующий код:

{line-numbers=off,lang=php}
~~~
<?php
//...
use Application\Form\CommentForm;
use Application\Entity\Comment;

class PostController extends AbstractActionController 
{
    /**
     * Это действие отображает страницу "View Post", где можно посмотреть заголовок поста
     * и его содержимое. Она также содержит форму, позволяющую
     * добавить к посту комментарий. 
     */
    public function viewAction() 
    {       
        $postId = $this->params()->fromRoute('id', -1);
        
        $post = $this->entityManager->getRepository(Post::class)
              ->findOneById($postId);
        
        if ($post == null) {
            $this->getResponse()->setStatusCode(404);
            return;                        
        }        
        
        $commentCount = $this->postManager->getCommentCountStr($post);
        
        // Создаем форму.
        $form = new CommentForm();
        
        // Проверяем, является ли пост POST-запросом.
        if($this->getRequest()->isPost()) {
            
            // Получаем POST-данные.
            $data = $this->params()->fromPost();
            
            // Заполняем форму данными.
            $form->setData($data);
            if($form->isValid()) {
                                
                // Получаем валадированные данные формы.
                $data = $form->getData();
              
                // Используем менеджер постов для добавления нового комментарий к посту.
                $this->postManager->addCommentToPost($post, $data);
                
                // Снова перенаправляем пользователя на страницу "view".
                return $this->redirect()->toRoute('posts', ['action'=>'view', 'id'=>$postId]);
            }
        }
        
        // Визуализируем шаблон представления.
        return new ViewModel([
            'post' => $post,
            'commentCount' => $commentCount,
            'form' => $form,
            'postManager' => $this->postManager
        ]);
    }      
}
~~~ 

Наконец, добавим файл шаблона представления *view.phtml* и заполним его следующим содержимым:

{line-numbers=off,lang=php}
~~~
<?php
$form = $this->form;
$form->get('author')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'Author\'s name'
    ]);
$form->get('comment')->setAttributes([
    'class'=>'form-control',
    'rows'=>6, 
    'placeholder'=>'Text'
    ]);
$form->get('submit')->setAttributes(['class'=>'btn btn-primary']);
$form->prepare();        
?>

<a href="
    <?= $this->url('application', ['action'=>'index']); ?>">
    &lt;&lt; Back to list of posts
</a>

<h1>
    <?= $this->escapeHtml($post->getTitle()); ?>    
</h1>

<p class="comments-header">
    <?= $this->escapeHtml($postManager->getCommentCountStr($post)); ?> | 
    <a href="#comment">
        Add new comment
    </a>
</p>

<p>
    Published: <?= $this->escapeHtml(date('jS \of F Y', strtotime($post->getDateCreated()))); ?> 
    | Tags: <?= $this->escapeHtml($postManager->convertTagsToString($post)); ?>   
</p>

<p>    
    <?= $this->escapeHtml($post->getContent()); ?>
</p>

<h3><?= $this->escapeHtml($postManager->getCommentCountStr($post)); ?></h3>

<?php foreach ($post->getComments() as $comment): ?>

<hr>

<p>
    <?= $this->escapeHtml($comment->getAuthor()) ?> on 
    <?= $this->escapeHtml($comment->getDateCreated()); ?>
</p>

<p>
    <?= $this->escapeHtml($comment->getContent()); ?>    
</p>

<?php endforeach; ?>

<hr>

<a name="comment"></a>
<h3>Leave Reply</h3>

<div class="row">
    <div class="col-md-8">
        <?= $this->form()->openTag($form); ?>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('author')); ?>
            <?= $this->formElement($form->get('author')); ?>
            <?= $this->formElementErrors($form->get('author')); ?>                  
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('comment')); ?>
            <?= $this->formElement($form->get('comment')); ?>
            <?= $this->formElementErrors($form->get('comment')); ?>                  
        </div>
        
        <?= $this->formElement($form->get('submit')); ?>
        
        <?= $this->form()->closeTag(); ?>
    </div>    
</div>   
~~~

## Реализация страницы администратора

Страница администратора нашего примера *Blog* содержит список всех постов блога (как
опубликованных, так и черновиков) и позволяет просматривать, изменять и удалять посты.

Для реализации этой страницы добавьте метод действия `adminAction()` в класс `PostController`
как показано ниже:

{line-numbers=off,lang=php}
~~~
<?php

//..
class PostController extends AbstractActionController 
{
  /**
   * Это действие отображает страницу Manage Posts. Она содержит
   * список постов с возможностью изменить/удалить любой из них.
  */
  public function adminAction()
  {
    // Получаем посты.
    $posts = $this->entityManager->getRepository(Post::class)
               ->findBy([], ['dateCreated'=>'DESC']);
        
    // Визуализируем шаблон представления.
    return new ViewModel([
            'posts' => $posts,
            'postManager' => $this->postManager
        ]);        
  }
}
~~~

Кроме того, нам нужно показывать статус поста в текстовой форме ('Draft', черновик, или 'Published', опубликован).
Преобразования статуса типа integer в строку может быть реализовано в методе `getPostStatusAsString()`
сервиса `PostManager`. Добавьте метод `getPostStatusAsString()` в класс `PostManager` следующим образом:

{line-numbers=off,lang=php}
~~~
/**
 * Возвращает статус в виде строки.
 */
public function getPostStatusAsString($post) 
{
    switch ($post->getStatus()) {
        case Post::STATUS_DRAFT: return 'Draft';
        case Post::STATUS_PUBLISHED: return 'Published';
    }
    
    return 'Unknown';
}
~~~
    
Далее, добавьте файл соответствующего шаблона представления *admin.phtml* в каталог *application/post*
под каталогом модуля *view*:
	
{line-numbers=off,lang=php}
~~~
<h1>Manage Posts</h1>

<p>
<a class="btn btn-default" href="
    <?= $this->url('posts', ['action'=>'add']); ?>">
    New Post
</a>
</p>

<table class="table table-striped">

   <tr>
        <th>ID</th>
        <th>Post Title</th>
        <th>Date Created</th>
        <th>Status</th>        
        <th>Actions</th>        
    </tr>
    
    <?php foreach ($posts as $post): ?>
    
    <tr>
        <td><?= $this->escapeHtml($post->getId()); ?></td>
        <td>
            <a href="<?= $this->url('posts', ['action'=>'view', 'id'=>$post->getId()]); ?>">
                <?= $this->escapeHtml($post->getTitle()); ?>
            </a> 
        </td>
        <td><?= $this->escapeHtml($post->getDateCreated()); ?></td>        
        <td><?= $this->escapeHtml($postManager->getPostStatusAsString($post)); ?></td>
        <td>
            <a class="btn btn-info" href="<?= $this->url('posts', 
                    ['action'=>'edit', 'id'=>$post->getId()]); ?>">
                <span class="glyphicon glyphicon-pencil" ></span> Edit
            </a>
            <a class="btn btn-danger" href="<?= $this->url('posts',
                    ['action'=>'delete', 'id'=>$post->getId()]); ?>">
                <span class="glyphicon glyphicon-remove"></span> Delete
            </a>
        </td>    
    </tr>
        
    <?php endforeach; ?>   
    
</table>
~~~

Теперь, если вы откроете в своем браузере URL *http://localhost/posts/admin*, вы
должны будете увидеть страницу, как на рисунке 12.10 ниже:

![Рисунок 12.10. Страница блога Admin](../en/images/doctrine/blog_admin_page.png)  

## Реализация облака тегов

Еще одна часть примера *Blog*, которую мы реализуем в этом разделе, будет облако тегов. Оно
будет находиться на странице *Home*. Облако содержит самые популярные теги, а размер их шрифта
зависит от частоты употребления тега: более популярные будут большего размера. Нажатие на тег
в облаке приведет к фильтрации постов по этому тегу.

Пример того, чего мы хотим достичь, можно увидеть ниже, в правой части рисунка 12.11:

![Рисунок 12.11. Облако тегов](../en/images/doctrine/tag_cloud.png)  

Чтобы добавить облако, нам нужно:

  * создать пользовательский класс репозитория сущностей `PostRepository`, который будет инкапсулировать 
    сложный алгоритм фильтрации постов по тегу;
  * изменить `PostManager` и добавить функциональность для вычисления размеров шрифтов;
  * добавить действие контроллера и соответствующий шаблон представления.

### Добавление пользовательского репозитория постов

Ранее мы упоминали, что по умолчанию Doctrine использует в качестве репозитория класс
`Doctrine\ORM\EntityRepository`. Пользовательский репозиторий - это класс, расширяющий
`EntityRepository`. Как правило, он используется, когда необходимо инкапсулировать сложные
DQL-запросы и алгоритмы поиска в один компонент кода.

I> DQL-запросы также можно поместить в класс контроллера, но это сделает контроллер слишком "толстым".
   Так как мы используем шаблон проектирования MVC, мы стараемся этого избежать.
   
I> DQL похож на SQL в том плане, что он позволяет составлять и выполнять запросы к базе 
   данных, однако результатом запроса является не массив строк таблицы, а массив объектов. 
   Дополнительную информацию о DQL, а также примеры его использования, можно посмотреть на этой 
   [странице](http://docs.doctrine-project.org/en/latest/reference/dql-doctrine-query-language.html).

Для веб-приложения *Blog* нам понадобится пользовательский репозиторий, который позволит
находить опубликованные посты, имеющие хотя бы один тег (чтобы посчитать общее количество
постов, содержащих теги), и находить опубликованные посты, отфильтрованные по определенному
тегу. Мы планируем инкапсулировать этот алгоритм поиска в наш репозиторий `PostRepository`.

I> Doctrine работает с пользовательскими репозиториями прозрачно. Это значит, что вы извлекаете
   репозиторий из `EntityManager` как обычно и точно так же можете использовать его методы `findBy()`, 
   `findOneBy()` и другие.

Создайте файл *PostRepository.php* в каталоге *Repository* под корневым каталогом модуля. Ниже
представлен код класса `PostRepository`, который содержит два public-метода:

  * метод `findPostsHavingAnyTag()`, предназначенный для выбора всех постов, который имеют статус *Published*,
    а также один или несколько тегов, связанных с ними;
  * и метод `findPostsByTag()`, возвращающий все опубликованные посты, которые имеют определенный тег
   (то есть, фильтрующий посты по заданному тегу).

{line-numbers=on,lang=php}
~~~
<?php
namespace Application\Repository;

use Doctrine\ORM\EntityRepository;
use Application\Entity\Post;

// Это пользовательский класс репозитория для сущности Post.
class PostRepository extends EntityRepository
{
    // Находит все опубликованные посты, имеющие хотя бы один тег.
    public function findPostsHavingAnyTag()
    {
        $entityManager = $this->getEntityManager();
        
        $queryBuilder = $entityManager->createQueryBuilder();
    
        $queryBuilder->select('p')
            ->from(Post::class, 'p')
            ->join('p.tags', 't')
            ->where('p.status = ?1')
            ->orderBy('p.dateCreated', 'DESC')
            ->setParameter('1', Post::STATUS_PUBLISHED);
    
        $posts = $queryBuilder->getQuery()->getResult();
    
        return $posts;
    }
    
    // Находит все опубликованные посты, содержащие заданный тег.
    public function findPostsByTag($tagName)
    {
        $entityManager = $this->getEntityManager();
        
        $queryBuilder = $entityManager->createQueryBuilder();
    
        $queryBuilder->select('p')
            ->from(Post::class, 'p')
            ->join('p.tags', 't')
            ->where('p.status = ?1')
            ->andWhere('t.name = ?2')
            ->orderBy('p.dateCreated', 'DESC')
            ->setParameter('1', Post::STATUS_PUBLISHED)
            ->setParameter('2', $tagName);
    
        $posts = $queryBuilder->getQuery()->getResult();
            
        return $posts;
    }        
}
~~~

В этом фрагменты мы используем *построитель запросов* (query builder) для удобного создания сложных
DQL-запросов.

В строках 17-22 мы создаем запрос, который выбирает все опубликованные посты, упорядочивая их по дате создания
в порядке убывания. Мы выбираем только те посты, которые имеют хотя бы один тег. В строке 24 мы выполняем запрос.
Если вам интересно, какой DQL-код генерирует построитель запросов, вот он:

~~~
SELECT p FROM \Application\Entity\Post p JOIN p.tags t 
WHERE p.status=?1 ORDER BY p.dateCreated DESC
~~~

В строках 36-43 мы создаем запрос, который фильтрует посты по имени тега. Аналогичный DQL представлен ниже:

~~~
SELECT p FROM \Application\Entity\Post p JOIN p.tags t 
WHERE p.status=?1 AND t.name=?2 ORDER BY p.dateCreated DESC
~~~

T> Чтобы узнать больше о построителе запросов Doctrine, пожалуйста, обратитесь к
T> [этой странице](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/query-builder.html).

Чтобы сообщить Doctrine, что для сущности `Post` нужно использовать пользовательский
репозиторий, измените аннотацию сущности `Post` следующим образом:

{line-numbers=on,lang=php}
~~~
<?php
//...

/**
 * Этот класс представляет собой пост в блоге.
 * @ORM\Entity(repositoryClass="\Application\Repository\PostRepository")
 * @ORM\Table(name="post")
 */
class Post 
{
    //...
}
~~~

Во фрагменте выше мы используем параметр `repositoryClass` тега `@ORM\Entity`, чтобы сообщить Doctrine,
что нужно использовать репозиторий `PostRepository`.

### Вычисление облака тегов

Бизнес-логика для нашего облака тегов будет храниться внутри метода `PostManager::getTagCloud()`, как показано
ниже:

{line-numbers=off,lang=php}
~~~
<?php
//...
class PostManager 
{
    //...
	
    // Вычисляет частоту использования тегов.
    public function getTagCloud()
    {
        $tagCloud = [];
               
        $posts = $this->entityManager->getRepository(Post::class)
                    ->findPostsHavingAnyTag();
        $totalPostCount = count($posts);
        
        $tags = $this->entityManager->getRepository(Tag::class)
                ->findAll();
        foreach ($tags as $tag) {
            
            $postsByTag = $this->entityManager->getRepository(Post::class)
                    ->findPostsByTag($tag->getName());
            
            $postCount = count($postsByTag);
            if ($postCount > 0) {
                $tagCloud[$tag->getName()] = $postCount;
            }
        }
        
        $normalizedTagCloud = [];
        
        // Нормализуем значение
        foreach ($tagCloud as $name=>$postCount) {
            $normalizedTagCloud[$name] =  $postCount/$totalPostCount;
        }
        
        return $normalizedTagCloud;
    }
}
~~~

Этот фрагмент содержит метод `getTagCloud()`, который выбирает все посты, имеющие хотя бы
один связанный тег и вычисляет "частоту" каждого тега (насколько часто он встречается).
затем данный метод нормализует значения частоты (представляет их в виде числа от 0 до 1.0)

### Изменение действия контроллера

В этом разделе мы изменим `IndexController` с целью реализовать фильтр тегов.

{line-numbers=on,lang=php}
~~~
<?php
//...
class IndexController extends AbstractActionController 
{
    /**
     * Менеджер постов.
     * @var Application\Service\PostManager 
     */
    private $postManager;
    
    // Конструктор используется для внедрения зависимостей в контроллер.
    public function __construct($entityManager, $postManager) 
    {
        $this->entityManager = $entityManager;
        $this->postManager = $postManager;
    }
    
    public function indexAction() 
    {
        $tagFilter = $this->params()->fromQuery('tag', null);
        
        if ($tagFilter) {
         
            // Фильтруем посты по тегу.
            $posts = $this->entityManager->getRepository(Post::class)
                    ->findPostsByTag($tagFilter);
            
        } else {
            // Получаем недавние посты
            $posts = $this->entityManager->getRepository(Post::class)
                    ->findBy(['status'=>Post::STATUS_PUBLISHED], 
                             ['dateCreated'=>'DESC']);
        }
        
        // Получаем популярные теги.
        $tagCloud = $this->postManager->getTagCloud();
        
        // Визуализируем шаблон представления.
        return new ViewModel([
            'posts' => $posts,
            'postManager' => $this->postManager,
            'tagCloud' => $tagCloud
        ]);
    }
}
~~~

Метод действия извлекает тег из GET-переменной `tag`. Если HTTP-запрос содержит
эту переменную, мы используем наш репозиторий `findPostsByTag()` для фильтрации постов;
иначе, все посты извлекаются как обычно.

В строке 36 мы вызываем метод `PostManager::getTagCloud()`, который возвращает массив тегов
и их частоту использования. Мы используем эту информацию для визуализации облака.

I> Заметьте, что в этот раз мы используем сервис `PostManager` в контроллере, и нам необходимо
I> внедрить его в конструктор. Не забудьте внести соответствующие изменения в фабрику контроллера.

### Визуализация облака тегов

И наконец, измените файл *index.phtml* так, чтобы он выглядел следующим образом:

{line-numbers=off,lang=php}
~~~
<h1>Posts</h1>

<div class="row">
    
    <div class="col-md-8">

    <?php foreach($posts as $post): ?>

    <h3>
        <a href="<?= $this->url('posts', ['action'=>'view', 'id'=>$post->getId()]); ?>">
            <?= $this->escapeHtml($post->getTitle()); ?>
        </a>    
    </h3>
    
    <p>
        Published: <?= $this->escapeHtml(date('jS \of F Y', strtotime($post->getDateCreated()))); ?> 
        | Tags: <?= $this->escapeHtml($postManager->convertTagsToString($post)); ?>   
    </p>    
        
    <p class="comments-header">
        <?= $this->escapeHtml($postManager->getCommentCountStr($post)); ?> | 
        <a href="<?= $this->url('posts', ['action'=>'view', 'id'=>$post->getId()],
                ['fragment'=>'comment']); ?>">
            Add new comment
        </a>
    </p>

    <p>    
        <?= $this->escapeHtml($post->getContent()); ?>
    </p>

    <?php endforeach; ?>

    </div>
    
    <div class="col-md-4">
        <div class="panel panel-default">
            <div class="panel-heading">
                <h3 class="panel-title">Popular Tags</h3>
            </div>
            <div class="panel-body">
                <?php foreach($this->tagCloud as $tagName=>$frequency): ?>
                
                <a href="<?= $this->url('application', ['action'=>'index'],
                    ['query'=>['tag'=>$tagName]]); ?>">                   
        
                    <span style="font-size:<?= $this->escapeHtml(0.9 + $frequency*3) ?>em">
                        <?= $this->escapeHtml($tagName); ?>
                    </span>
                
                </a>    
                    
                <?php endforeach; ?>
            </div>
        </div>
    </div>
</div>
~~~

## Пагинация (Pagination)

Пока что у нас всего несколько постов на нашей странице *Posts*. Но представьте, что там будет много (сотни) постов. Страница будет загружаться очень долго. Также будет 
очень неудобно прокручивать страницу, чтобы прочитать все посты. В такой ситуации нам будет полезна *пагинация (pagination)*. 

I> *Пагинация* - это когда вы делите ваши результаты на страницы и перемещаетесь по страницам, кликая на ссылки с номерами страниц на виджете пагинации.

Пример виджета пагинации, стилизованного при помощи Twitter Bootstrap представлен ниже:

![Рисунок 12.12. Пример виджета пагинации](../en/images/doctrine/paginator_example.png) 

### Пагинатор из Doctrine ORM

Компонент *Doctrine\ORM* предоставляет класс пагинатора под названием `Paginator`, живущий в пространстве имен `Doctrine\ORM\Tools\Pagination`. 
Он берет на вход объект Doctrine `Query` и предоставляет несколько методов, чтобы разбить результаты на страницы (для простоты, мы не будем
обсуждать здесь эти методы). Но модуль Doctrine ORM не предоставляет никаких помощников вида, чтобы визуализировать пагинатор. Для этих целей мы
можем воспользваться функциональностью для пагинации, которую предоставляет нам Zend Framework 3. 

I> Хотя мы и планируем использовать компонент для пагинации из ZF3, мы все равно будем внутренне использовать пагинатор Doctrine ORM, чтобы подавать ему данные.
I> Пагинатор ZF3 будет всего лишь оберткой для пагинатора Doctrine ORM.

### ZF3 Paginator

В Zend Framework 3, пагинация реализована внутри компонента *Zend\Paginator*. Если вы еще не установили этот компонент,
сделайте это сейчас, набрав следующую команду Composer:

```
php composer.phar require zendframework/zend-paginator
```

Компонент *Zend\Paginator* предоставляет класс `Paginator`. Его наиболее полезные методы представлены в таблице 12.6:

{title="Таблица 12.6. Методы класса Paginator из ZF3"}
|------------------------------------|----------------------------------------------------|
| *Метод*                            | *Описание*                                         |
|------------------------------------|----------------------------------------------------|
| `setDefaultScrollingStyle($scrollingStyle = 'Sliding')`  | Устанавливает стиль скроллинга.        |
|------------------------------------|----------------------------------------------------|
| `setDefaultItemCountPerPage($count)` | Устанавливает максимальное количество результатов на страницу.          |
|------------------------------------|----------------------------------------------------|
| `setCurrentPageNumber($pageNumber)` | Устанавливает текущий номер страницы. |
|------------------------------------|----------------------------------------------------|
| `count()` | Возвращает количество страниц.        |
|------------------------------------|----------------------------------------------------|
| `getTotalItemCount()`  | Возвращает общее количество результатов.    |
|------------------------------------|----------------------------------------------------|
| `getCurrentItems()` | Возвращает элементы с текущей страницы. |
|------------------------------------|----------------------------------------------------|

Класс `Paginator` является очень "общим" и не знает ничего о нижележащей модели данных, так что вам нужно
иметь адаптер, который предоставляет данные пагинатору. Модуль *DoctrineORMModule* предоставляет такой
адаптер (класс `DoctrineORMModule\Paginator\Adapter\DoctrinePaginator`), который мы можем использовать, чтобы взять
данные из пагинатора ORM и передать их в пагинатор ZF3. 

Для примера, предположим, что у нас есть объект класса `Query` с DQL-запросом, который выбирает все опубликованные посты. 
Чтобы разбить результаты на страницы, мы можем использовать следующий код:

{line-numbers=off,lang=php}
~~~
<?php 
use DoctrineORMModule\Paginator\Adapter\DoctrinePaginator as DoctrineAdapter;
use Doctrine\ORM\Tools\Pagination\Paginator as ORMPaginator;
use Zend\Paginator\Paginator;

// Создаем ZF3 пагинатор.
$adapter = new DoctrineAdapter(new ORMPaginator($query, false));
$paginator = new Paginator($adapter);

// Устанавливаем номер страницы и размер страницы.
$paginator->setDefaultItemCountPerPage(10);        
$paginator->setCurrentPageNumber(1);

// Проходим по результатам с текущей страницы.
foreach ($paginator as $post) {
    // Делаем что-нибудь с текущим постом.
}
~~~

Теперь давайте применим этот пример к нашему блогу. Мы хотим отображать "пагинированные" посты на главной странице вебсайта Blog.

#### Модифицируем PostRepository

Прежде всего нам потребуется немного изменить подход, с которым мы получаем список постов из репозитория. Раньше мы пользовались методом `findBy()` 
класса `EntityRepository`, который возвращает массив постов. Но теперь нам придется делать это с помощью метода нашего кастомного репозитория 
`PostRepository`, потому что пагинатор Doctrine ORM берет на вход объект `Query`, а не массив постов:

Добавьте следующий метод к классу `PostRepository`:

{line-numbers=off,lang=php}
~~~
public function findPublishedPosts()
{
    $entityManager = $this->getEntityManager();
    
    $queryBuilder = $entityManager->createQueryBuilder();
    
    $queryBuilder->select('p')
        ->from(Post::class, 'p')
        ->where('p.status = ?1')
        ->orderBy('p.dateCreated', 'DESC')
        ->setParameter('1', Post::STATUS_PUBLISHED);
    
    return $queryBuilder->getQuery();
}
~~~

И измените метод `findPostsByTag()` репозитория, так как мы также хотим, чтобы он возвращал объект `Query` вместо `array`:

{line-numbers=off,lang=php}
~~~
public function findPostsByTag($tagName)
{
    $entityManager = $this->getEntityManager();
    
    $queryBuilder = $entityManager->createQueryBuilder();
    
    $queryBuilder->select('p')
        ->from(Post::class, 'p')
        ->join('p.tags', 't')
        ->where('p.status = ?1')
        ->andWhere('t.name = ?2')
        ->orderBy('p.dateCreated', 'DESC')
        ->setParameter('1', Post::STATUS_PUBLISHED)
        ->setParameter('2', $tagName);
    
    return $queryBuilder->getQuery();
}
~~~ 

T> Вам также придется немного изменить код метода `PostManager::getTagCloud()` так как он ожидает массив постов, а теперь он будет получать
T> объект `Query`. Это довольно простая модификация, так что мы не будем ее описывать здесь (обратитесь к примеру Blog для полного кода). 

#### Модифицируем IndexController

Затем измените метод действия `indexAction()` контроллера `IndexController` следующим образом:

{line-numbers=on,lang=php}
~~~
<?php
namespace Application\Controller;

// Add aliases for paginator classes
use DoctrineORMModule\Paginator\Adapter\DoctrinePaginator as DoctrineAdapter;
use Doctrine\ORM\Tools\Pagination\Paginator as ORMPaginator;
use Zend\Paginator\Paginator;
// ...

class IndexController extends AbstractActionController 
{
    // ...
    
    public function indexAction() 
    {
        $page = $this->params()->fromQuery('page', 1);
        $tagFilter = $this->params()->fromQuery('tag', null);
        
        if ($tagFilter) {
         
            // Фильтруем посты по тегу
            $query = $this->entityManager->getRepository(Post::class)
                    ->findPostsByTag($tagFilter);
            
        } else {
            // Получаем недавние посты
            $query = $this->entityManager->getRepository(Post::class)
                    ->findPublishedPosts();
        }
        
        $adapter = new DoctrineAdapter(new ORMPaginator($query, false));
        $paginator = new Paginator($adapter);
        $paginator->setDefaultItemCountPerPage(1);        
        $paginator->setCurrentPageNumber($page);
                       
        // Получаем популярные теги.
        $tagCloud = $this->postManager->getTagCloud();
        
        // Отображаем шаблон представления.
        return new ViewModel([
            'posts' => $paginator,
            'postManager' => $this->postManager,
            'tagCloud' => $tagCloud
        ]);
    }
}
~~~

Вы можете заметить, что в строке 16 мы получаем номер текущей страницы (`page`) из параметра GET. Так что вы можете установить номер страницы результатов путем ввода
следующего URL в вашем браузере: "http://localhost/application/index?page=&lt;page&gt;". Номер страницы по умолчанию - 1.

В строках 22 и 27 мы извлекаем объект `Query` из нашего репозитория `PostRepository` вместо массива (`array`) постов.
Мы затем передаем этот объект `Query` пагинатору ZF3 в строке 31.

В строках 33-34 мы устанавливаем текущий номер страницы пагинатора и размер страницы.

В строке 41 мы передаем пагинатор (!) вместо массива постов в шаблон представления.

#### Визуализация виджета пагинатора

Теперь осталась последняя по порядку (но не по значению) часть работы. Нам нужно отобразить виджет пагинации в нашем шаблоне представления.

Чтобы сделать это с привлекательным оформлением Bootstrap, нам нужно будет сначала создать частичный шаблон представления
*view/application/partial/paginator.phtml* и поместить следующий код в этот файл:

{line-numbers=off,lang=php}
~~~
<?php if ($this->pageCount): ?>

<nav>
<ul class="pagination">

<!-- Previous page link -->
<?php if (isset($this->previous)): ?>
    <li>
      <a href="<?= $this->url($this->route, [], ['query'=>['page'=>$this->previous]]); ?>" aria-label="Previous">
        <span aria-hidden="true">&laquo;</span>
      </a>
    </li>  
<?php else: ?>
    <li>
        <span aria-hidden="true">&laquo;</span>      
    </li>  
<?php endif; ?>

<!-- Numbered page links -->
<?php foreach ($this->pagesInRange as $page): ?>
  <?php if ($page != $this->current): ?>
    <li>
        <a href="<?= $this->url($this->route, [], ['query'=>['page'=>$page]]); ?>"><?= $this->escapeHtml($page); ?></a>
    </li>    
  <?php else: ?>
    <li>
        <span aria-hidden="true"><b><?= $this->escapeHtml($page); ?></b></span> 
    </li>    
  <?php endif; ?>
<?php endforeach; ?>

<!-- Next page link -->
<?php if (isset($this->next)): ?>
    <li>
      <a href="<?php echo $this->url($this->route, [], ['query'=>['page'=>$this->next]]); ?>" aria-label="Next">
        <span aria-hidden="true">&raquo;</span>
      </a>
    </li>  
<?php else: ?>
    <li>
        <span aria-hidden="true">&raquo;</span>      
    </li> 
<?php endif; ?>
</ul>
</nav>
<?php endif; ?>
~~~

Частичный шаблон представления будет использован помощником представления `PaginationControl` ZF3, чтобы визуализировать виджет пагинатора. Как вы можете увидеть,
этот частичный шаблон представления берет на вход несколько переменных (`$pageCount`, `$pagesInRange`, `$current`, `$previous`, `$next`, `$route`),
которые используются, чтобы определить как будет выглядеть виджет.

Теперь давайте отобразим виджет в нашем шаблоне представления *view/application/index/index.phtml* под списком постов следующим образом:

{line-numbers=off,lang=php}
~~~
<?= $this->paginationControl($posts,
            'Sliding',
            'application/partial/paginator', 
            ['route' => 'application']); ?>
~~~ 

Помощник представления `PaginationControl` принимает четыре аргумента:

  * `$posts` - это объект `Paginator`, который мы передали из действия контроллера через контейнер переменных `ViewModel`.
  * аргумент "Sliding" - это стиль пагинатора. Для дополнительной информации о доступных стилях пагинации обратитесь к руководству Zend Framework.
  * "application/partial/paginator" - это имя частичного шаблона представления, содержащего разметку виджета.
  * четвертый аргумент может быть использован, чтобы передавать параметры в частичный шаблон представления. Например, мы передаем туда параметр `route`, который используется при генерации
    кликабельных ссылок на страницы пагинатора.

#### Результаты

Ура! Наш блог готов теперь. Главная страница вебсайта теперь содержит красивый виджет пагинации (смотрите рис. 12.13 ниже):

![Рисунок 12.13. Главная страница с пагинатором](../en/images/doctrine/main_page_paginator.png)  

T> В этой главе мы реализовали только простую пагинацию. Для реальных вебсайтов, дополнительно к пагинации, 
T> вы можете также захотеть интерактивно сортировать ваши результаты по конкретным полям. Для такого сложного отображения табличных данных,
T> рассмотрите возможность использования jQuery-плагина [DataTables](https://datatables.net/).

## Выводы

Хотя Doctrine не является частью Zend Framework 3, мы рассматриваем примеры ее использования в
этой книге, так как данная библиотека предоставляет простой способ доступа к базе данных.

В этой главе мы рассмотрели использование такого компонента Doctrine, как объектно-реляционный 
преобразователь (Object Relational Mapper - ORM). Он предназначен для управления базой данных
объектно-ориентированным способом. С помощью ORM можно установить соответствие между таблицей
базы данных и PHP-классом, называемым сущностью, а также между столбцами этой таблицы и свойствами
данного класса.

Чтобы загрузить данные из базы данных, нужно извлечь сущность из ее репозитория. Репозиторий - 
это класс, который можно считать коллекцией всех доступных сущностей. Когда вы запрашиваете у
репозитория сущность, он загружает данные из таблицы, сопоставляемой с сущностью, а затем
присваивает данные полям этой сущности.
